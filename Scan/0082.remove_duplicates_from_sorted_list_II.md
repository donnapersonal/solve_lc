# 82.删除排序链表中的重复元素 II

题目链接：[82.删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

## 题目大意

给定一个已排序的链表的头 `head`，删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.3nrrzkju8o.webp)

限制：
- The number of nodes in the list is in the range [0, 300].
- -100 <= Node.val <= 100
- The list is guaranteed to be sorted in ascending order.

## 解题

最直接的方式是：
- 用哈希表统计每个值出现次数
- 第二次遍历时，只保留次数为 `1` 的节点
✅ 优点：逻辑简单
❌ 缺点：需要额外空间 `O(n)`，而且要遍历两次

题目说链表是`升序 `的，这意味着所有重复的节点一定是连续出现的 -> 可以在一次遍历中解决，不需要额外空间

最优思路
- 一次遍历，用两个指针：
  - `head`：当前扫描位置
  - `prev`：指向结果链表的“最后一个确定无重复的节点”
- 遍历时分三种情况：
  - 如果 `head` 后面节点存在且 `head.val == head.next.val`，说明 `head` 是重复段的起点：
    - 记录重复值 `val`
    - 一直跳过所有值等于 `val` 的节点，直到遇到不同值
    - 然后把 `prev.next` 指向这个跳过后的位置，实现“删除重复段”。
  - 否则，没有重复：`prev` 向前移动一格（确认当前节点保留）
- 遍历结束后返回 `dummy.next`

```js
var deleteDuplicates = function(head) {
    let dummy = new ListNode(0);
    dummy.next = head;
    let prev = dummy;
    while (head !== null) {
        if (head.next !== null && head.val === head.next.val) {
            let val = head.val;
            while (head !== null && head.val === val) {
                head = head.next;
            }
            prev.next = head;
        } else {
            prev = prev.next;
            head = head.next;
        }
    }
    return dummy.next;
};
```
```python
# 写法 1
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 创建一个 哑节点(dummy)，值任意（这里是 0）
        dummy = ListNode(0)
        # dummy.next = head：把哑节点接在链表头之前，方便处理头结点可能被删除的情况
        dummy.next = head
        # prev 指针初始化在 dummy，表示当前结果链表的“最后一个确定不会删除的节点”
        prev = dummy
        # 遍历链表，只要 head 不为空就继续
        while head:
            # 情况1：遇到重复段
            # 条件：head 后面还有节点，并且值相等 → 说明进入了一个重复段
            if head.next and head.val == head.next.val:
                # 记录重复段的值 val
                val = head.val
                # 跳过整个重复段：
                # - 当 head 不为空并且值等于 val，不断向后移动
                # - 跳出循环后，head 已经移动到第一个值不同的节点（或链表结尾）
                while head and head.val == val:
                    head = head.next
                # 把 prev.next 直接指向 head，跳过了所有重复节点，相当于把重复段删除
                prev.next = head
            else:
                # 情况2：当前节点无重复
                # 没有进入重复段 → 当前节点是安全的：
                # - prev 向前移动一格
                # - head 也向前移动一格
                prev = prev.next
                head = head.next
        
        # 返回 dummy.next，即处理后的链表头
        return dummy.next

# 写法 2
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 特判：空链表或只有一个节点时，直接返回 head
        if head == None or head.next == None:
            return head
        
        # 创建哑节点 dummy，值随意（这里是 -1）
        # dummy.next = head：把哑节点接到链表头之前，方便处理头节点删除的情况
        dummy = ListNode(-1)
        dummy.next = head
        # cur 指向当前检查位置的 前一个节点，初始为 dummy
        cur = dummy
        # 只要 cur 后面至少有两个节点，就继续检查：因为我们需要比较 cur.next.val 和 cur.next.next.val
        while cur.next and cur.next.next:
            # 如果 cur.next 和 cur.next.next 的值相同 → 发现重复段
            if cur.next.val == cur.next.next.val:

                # 用 temp 从重复段的第一个节点开始扫描
                temp = cur.next
                # 跳过所有值相同的节点：
                # - 一直移动 temp，直到 temp.next 为空或值不相同为止
                # - 跳出后，temp 指向重复段的最后一个节点
                while temp and temp.next and temp.val == temp.next.val:
                    temp = temp.next
                # 将 cur.next 直接指向 temp.next，跳过整个重复段
                cur.next = temp.next
            else:
                # 如果没有重复，说明 cur.next 是安全节点，把 cur 前移
                cur = cur.next
        # 返回去重后的链表头节点：dummy.next
        return dummy.next
```

- 时间复杂度：`O(n)`，尽管内部循环可能看起来会增加时间复杂度，但每个节点最多只被访问两次（一次在外部循环，一次在内部循环），所以总的时间复杂度仍然是线性的
- 空间复杂度：`O(1)`，该算法只使用了固定的额外空间，`dummy` 和 `cur` 节点指针，没有使用大小与输入数据量成比例的额外空间