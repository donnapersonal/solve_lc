# 57.插入区间

题目链接：[57.插入区间](https://leetcode.cn/problems/insert-interval/)

## 题目大意

给一个无重叠的、按照区间起始端点升序排序的区间列表 `intervals`，其中 `intervals[i] = [starti, endi]` 表示第 `i` 个区间的开始和结束。同样给定一个区间 `newInterval = [start, end]` 表示另一个区间的开始和结束

在 `intervals` 中插入 `newInterval`，使得 `intervals` 依然按照 `start_i` 升序排列，且区间之间不重叠（若有必要，可以合并区间）

返回插入后的 `intervals`

注意：不需要原地修改 `intervals`，可以创建一个新数组然后返回它

```js
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]

Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

限制：
- 0 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti <= endi <= 10^5
- intervals is sorted by starti in ascending order.
- newInterval.length == 2
- 0 <= start <= end <= 10^5

## 解题

暴力方法：
- 把 `newInterval` 插入到 `intervals` 里保持顺序，得到一个新的数组
- 然后对这个新数组再做一次“合并区间”的常规操作（类似 `LeetCode 56` 合并区间），即先排序，再遍历合并
- 可行，但缺点明显：需重新排序（O(n log n)），且重复扫描，效率不高

优化思路 - 利用 `intervals` 本身已经`按起点有序且不重叠`的性质，直接一次扫描解决：
- 跳过不重叠且在 `newInterval` 左边的区间：这些区间的结束点 `< newInterval.start`，它们不需合并，直接加入结果集
- 合并与 `newInterval` 有重叠的区间：对于所有和 `newInterval` 有交集的区间，不断更新 `newInterval` 的左右边界；合并结束后，把合并好的 `newInterval` 加入结果集
- 处理剩余不重叠且在 `newInterval` 右边的区间：这些区间的开始点 `> newInterval.end`，同样直接加入结果集

```js
var insert = function(intervals, newInterval) {
    let res = [];
    let n = intervals.length;
    if (n == 0) {
        res.push(newInterval);
        return res;
    }
    let curIndex = 0;
    while (curIndex < n && intervals[curIndex][1] < newInterval[0]) {
        res.push(intervals[curIndex]);
        curIndex++;
    }
    while (curIndex < n && intervals[curIndex][0] <= newInterval[1]) {
        newInterval[0] = Math.min(intervals[curIndex][0], newInterval[0]);
        newInterval[1] = Math.max(intervals[curIndex][1], newInterval[1]);
        curIndex++;
    }

    res.push(newInterval);
    while (curIndex < n) {
        res.push(intervals[curIndex]);
        curIndex++;
    }

    return res;
};
```
```python
# 写法 1
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        n = len(intervals)
        # curIndex：当前扫描位置
        curIndex = 0

        # 收集在左边的区间
        # 条件：当前区间的结束点 < newInterval.start → 表示当前区间完全在 newInterval 左侧，无需合并
        # 操作：直接加入 res，并移动 curIndex
        while curIndex < n and intervals[curIndex][1] < newInterval[0]:
            res.append(intervals[curIndex])
            curIndex += 1

        # 合并重叠区间
        # 条件：当前区间的起点 <= newInterval.end → 表示有重叠，需要合并
        # 更新 newInterval：
        # - 起点取较小值：newInterval[0] = min(...)
        # - 终点取较大值：newInterval[1] = max(...)
        # 合并完成后，继续检查下一个区间，直到不再重叠
        while curIndex < n and intervals[curIndex][0] <= newInterval[1]:
            newInterval[0] = min(intervals[curIndex][0], newInterval[0])
            newInterval[1] = max(intervals[curIndex][1], newInterval[1])
            curIndex += 1
        # 把合并后的 newInterval 加入结果集
        res.append(newInterval)

        # 收集在右边的区间
        # 条件：剩下的区间起点 > newInterval.end → 表示当前区间完全在右侧，无需合并，直接加入结果
        while curIndex < n:
            res.append(intervals[curIndex])
            curIndex += 1
        
        # 返回最终合并后的区间列表
        return res

# 写法 2
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = list()
        # 拆开 newInterval 的起点和终点，后续可能在合并过程中动态更新
        left, right = newInterval
        # placed 标记 newInterval 是否已经被加入 res，初始为 False
        placed = False
        # 遍历 intervals 中的每个区间 [l, r]
        for l, r in intervals:
            # 情况 1：当前区间在 newInterval 右侧且无重叠
            # 条件：当前区间的起点 l > right，说明当前区间在 newInterval 的右侧，且没有重叠
            if l > right:  
                # 如果 newInterval 还没放入结果，先把它放入，然后再把当前区间放入结果
                # 之后的区间都在右边，继续按顺序添加
                if not placed:
                    res.append([left, right])
                    placed = True
                
                res.append([l, r])
            # 情况 2：当前区间在 newInterval 左侧且无重叠
            # 条件：当前区间的终点 r < left，说明当前区间在 newInterval 的左侧，且没有重叠
            # 直接加入结果
            elif r < left:
                res.append([l, r])
            else:
                # 情况 3：当前区间和 newInterval 有重叠
                # 否则就是有重叠的情况：
                # - 更新 left 为两个区间起点的最小值
                # - 更新 right 为两个区间终点的最大值
                # 不立即加入结果，而是继续和后续区间合并
                left = min(left, l)
                right = max(right, r)
        
        # 遍历结束后，如果 newInterval 还没加入结果（如它在最后或被合并到最后），此时再把最终的 [left, right] 加入结果
        if not placed:
            res.append([left, right])
        
        # 返回最终的合并后区间列表 res
        return res
```

- 时间复杂度：`O(n)`，`n` 是数组 `intervals` 的长度，即给定的区间个数，整个算法需遍历 `intervals` 中的所有区间一次，每个区间只被处理一次
- 空间复杂度：`O(1)`，除了结果列表 `res` 外，算法中没有使用额外的辅助数据结构