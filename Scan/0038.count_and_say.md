# 38.外观数列

题目链接：[38.外观数列](https://leetcode.cn/problems/count-and-say/)

## 题目大意

「外观数列」是一个数位字符串序列，由递归公式定义：
- countAndSay(1) = "1"
- countAndSay(n) 是 countAndSay(n-1) 的行程长度编码
 

行程长度编码（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 "3322251" ，我们将 "33" 用 "23" 替换，将 "222" 用 "32" 替换，将 "5" 用 "15" 替换并将 "1" 用 "11" 替换。因此压缩后字符串变为 "23321511"

给定一个整数 n ，返回 外观数列 的第 n 个元素

```js
Example 1:
Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = RLE of "1" = "11"
countAndSay(3) = RLE of "11" = "21"
countAndSay(4) = RLE of "21" = "1211"

Example 2:
Input: n = 1
Output: "1"
Explanation: This is the base case.
```

限制:
- 1 <= n <= 30

## 解题

**暴力思路（递归 + 字符遍历）**
- 可以从第 `1` 项 `“1”` 开始，逐项构造第 `n` 项：
  - 用递归或迭代的方式，从前一个字符串生成下一个字符串
  - 每次通过遍历字符串，对连续相同字符进行计数，并拼接 “数量+字符”
- 但递归不必要，因为只需要前一项即可生成当前项 — 可用迭代替代，节省栈空间

**最优解思路（迭代 + 双指针 + 字符拼接）**
- 从第 2 项开始，逐项构造 countAndSay(i)
- 每一项的生成过程：
  - 遍历前一项字符串
  - 每次统计当前字符重复次数（使用双指针或计数器）
  - 拼接：`count + char`

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    if (n === 1) return "1";

    let res = "1";
    for (let i = 1; i < n; i++) {
        let temp = "";
        let count = 1;
        for (let j = 0; j < res.length; j++) {
            if (res[j] === res[j + 1]) {
                count++;
            } else {
                temp += count.toString() + res[j];
                count = 1;
            }
        }
        res = temp;
    }
    return res;
};
```
```python
class Solution:
    def countAndSay(self, n: int) -> str:
        # 边界条件，第 1 项直接返回 "1"
        if n == 1:
            return "1"
        
        # 初始化第 1 项为 "1"
        res = "1"
        # 从第 2 项开始构造，一共需要构造 n-1 次
        for _ in range(n - 1):
            # i 是指针，遍历当前字符串
            i = 0
            # new_res 用于构造下一项
            new_res = ""
            # 统计连续相同字符的数量 count
            while i < len(res):
                count = 1
                while i + 1 < len(res) and res[i] == res[i + 1]:
                    count += 1
                    i += 1
                # 拼接成 "count + char" 形式，如 2 个 1 → "21"
                new_res += str(count) + res[i]
                i += 1
            
            # 更新当前结果，进入下一轮迭代
            res = new_res
        
        # 返回最终构造出的第 n 项字符串
        return res
```

- 时间复杂度：`O(n×m)`，其中 `n` 为给定的正整数，`m` 为生成的字符串中的最大长度
- 空间复杂度：`O(m)`，其中 `m` 为生成的字符串中的最大长度