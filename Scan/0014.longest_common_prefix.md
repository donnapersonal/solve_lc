# 14.最长公共前缀

题目链接：[14.最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

## 题目大意

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`

```js
Example 1:
Input: strs = ["flower","flow","flight"]
Output: "fl"

Example 2:
Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```

限制：
- 1 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] consists of only lowercase English letters if it is non-empty.

## 解题

从左到右，竖着看
- 所有字符串的第 `0` 列须相同才能有公共前缀的第一个字符
- 所有字符串的第 `1` 列须相同才能有公共前缀的第二个字符
- 依次检查下去，直到某一列出现不匹配或某个字符串长度不够为止

因此这里的解法是采用`垂直扫描`算法

### 写法 1

实现：
- 用 `col` 表示正在检查的列索引，从 `0` 到第一个字符串的末尾
- 对于每一列，遍历所有字符串的当前列：
  - 如果某个字符串太短（没有这一列），或这一列的字符和前一个字符串不相等，说明公共前缀到此结束，直接返回前缀
- 优点：一次纵向扫描即可，不用重复比较，时间复杂度 `O(m * n)`（`m` 是字符串数量，`n` 是最短字符串长度），但实现清晰

> 为什么这是最优解？
> - 必须检查每个字符串对应位置的字符，无法跳过，所以 `O(m * n)` 已经是下界
> - 代码简洁，逻辑直接，提前遇到不匹配就返回，避免无谓比较

```js
var longestCommonPrefix = function(strs) {
    let m = strs.length, n = strs[0].length;
    for (let col = 0; col < n; col++) {
        for (let row = 1; row < m; row++) {
            let curStr = strs[row], preStr = strs[row - 1];
            if (col >= curStr.length || 
                col >= preStr.length ||
                curStr.charAt(col) !== preStr.charAt(col)
            ) {
                return strs[row].substring(0, col);
            }
        }
    }
    return strs[0];
};
```
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str: 
        # m = 字符串数组中字符串的数，n = 第一个字符串的长度
        # 因为最长公共前缀不会超过第一个字符串的长度，所以我可以把 n 当作最多检查的列数
        m, n = len(strs), len(strs[0])
        # 外层循环：按 列 遍历，从第 0 列开始检查，一直到 n-1
        for col in range(n):
            # 内层循环：按 行 遍历，检查当前列下，不同字符串之间的字符是否匹配
            # 从第 1 行开始（第二个字符串），拿它和前一个字符串对比
            for row in range(1, m):
                # cur_str 当前行的字符串
                # pre_str 当前行的前一行的字符串
                cur_str, pre_str = strs[row], strs[row-1]
                # 这一行是检查条件：
                # - col >= len(cur_str)：当前列已经超出当前字符串的长度 → 说明前缀到此结束
                # - col >= len(pre_str)：当前列已经超出前一个字符串的长度 → 说明前缀到此结束
                # - cur_str[col] != pre_str[col]：同一列的字符不匹配 → 前缀到此结束
                # 如果上述任意条件满足，说明最长公共前缀在当前列之前就已经终止
                if col >= len(cur_str) or col >= len(pre_str) or cur_str[col] != pre_str[col]:
                    # 如果发现不匹配或长度不够，直接返回从 0 到 col-1 的子串作为结果（取当前行的前缀，因为每一行此前都是匹配的）
                    return strs[row][:col]
        
        # 如果循环结束都没有提前返回，说明第一个字符串的所有列都匹配 → 返回整个第一个字符串
        return strs[0]
```

- 时间复杂度：`O(nm)`，其中 `n` 为字符串数量，`m` 为最短字符串的长度
- 空间复杂度：`O(1)`

### 写法 2

- 从第一条字符串出发，依次遍历它的每个字符 `strs[0][i]`
- 逐列检查其他字符串：
  - 对每个字符 `strs[0][i]`，依次比较其他字符串 `strs[j]` 的第 `i` 个字符
  - 如果发现 下标越界 或 字符不匹配，说明公共前缀在此终止，直接返回已经匹配到的位置 `strs[0][:i]`
- 若遍历完第一条字符串仍无不匹，说明第一条字符串本身就是公共前缀，直接返回 `strs[0]`

```js
var longestCommonPrefix = function(strs) {
    if (!strs || strs.length === 0) return "";
    for (let i = 0; i < strs[0].length; i++) {
        const c = strs[0][i];
        for (let j = 1; j < strs.length; j++) {
            if (i >= strs[j].length || strs[j][i] !== c) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0];
};
```
```python
# 写法 1
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        for i in range(len(strs[0])):
            c = strs[0][i]
            for j in range(1, len(strs)):
                if i >= len(strs[j]) or strs[j][i] != c:
                    return strs[0][:i]
        
        return strs[0]

# 写法 2
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        # 取第一个字符串 s0 作为基准：因为最长公共前缀一定不会比第一个字符串更长
        s0 = strs[0]
        # 使用 enumerate 遍历基准字符串 s0，j 是字符索引，c 是当前字符
        # 外层循环逐列扫描：从第 0 个字符开始
        for j, c in enumerate(s0):  
            # 内层循环：依次检查 strs 中的每一个字符串 s，看它在第 j 列是否和 c 一样
            for s in strs:  
                # 检查条件：
                # - j == len(s)：当前字符串 s 在 j 位置已经没有字符，长度不够 → 公共前缀在这之前结束
                # - s[j] != c：当前字符串在这个位置的字符和基准字符 c 不相同 → 公共前缀在这之前结束
                if j == len(s) or s[j] != c:  
                    # 一旦发现不满足条件，直接返回 从第 0 个到 j-1 的子串，即 s0[:j]，作为最长公共前缀
                    return s0[:j] 
        
        # 如果外层循环全部扫描完都没有提前返回，说明 s0 的所有字符在所有字符串中都匹配 → 直接返回 s0
        return s0
```

- 时间复杂度：`O(mn)`，其中 `m` 是字符串数组中的字符串的平均长度，`n` 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次
- 空间复杂度：`O(1)`，使用的额外空间复杂度为常数