# 228.汇总区间

题目链接：[228.汇总区间](https://leetcode.cn/problems/summary-ranges/)

## 题目大意

给定一个无重复元素的有序整数数组 `nums` 

返回恰好覆盖数组中所有数字的最小有序区间范围列表，即 `nums` 的每个元素都恰好被某个区间范围所覆盖，且不存在属于某个范围但不属于 `nums` 的数字 `x` 

列表中的每个区间范围 `[a, b]` 应该按如下格式输出：
- `"a->b"`，如果 `a != b`
- `"a"`，如果 `a == b`

```js
Example 1:
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: The ranges are:
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"

Example 2:
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: The ranges are:
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

限制：
- 0 <= nums.length <= 20
- -2^31 <= nums[i] <= 2^31 - 1
- All the values of nums are unique.
- nums is sorted in ascending order.

## 解题

### 写法 1

我们只需要一次`线性扫描`，用两个变量来记录

思路：
- 维护区间起点。用一个变量 `start` 记录当前连续区间的起始值（初始化为 `nums[0]`）
- 遍历数组：
  - 从第 `2` 个元素（索引 `1`）开始，依次判断当前元素与前一个元素是否连续（即 `nums[i] == nums[i-1] + 1`）
  - 如果不连续，说明之前的连续段已结束：
    - 将 `start -> nums[i-1]`（或单个元素）加入结果
    - 更新 `start = nums[i]` 为新起点
- 处理最后一个区间：遍历结束后，把最后一个区间加入结果

```js
var summaryRanges = function(nums) {
    let n = nums.length, res = [];
    if (nums.length === 0) return res;
    let start = nums[0];
    for (let i = 1; i < n; i++) {
        if (nums[i] !== nums[i - 1] + 1) {
            if (start === nums[i - 1]) {
                res.push(String(start));
            } else {
                res.push(`${start}->${nums[i - 1]}`);
            }
            start = nums[i];
        }
    }

    // 处理最后一个区间
    const last = nums[nums.length - 1];
    if (start === last) {
        res.push(String(start));
    } else {
        res.push(`${start}->${last}`);
    }
    
    return res;
};
```
```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        res = []
        # 如果输入数组为空，直接返回空结果
        if not nums:
            return res
        
        # 初始化当前区间的起点 start，从第一个元素开始
        start = nums[0]
        # 从第二个元素开始遍历（因为第一个元素已经记录在 start 里）
        for i in range(1, len(nums)):
            # 检查当前数字 nums[i] 是否与前一个数字连续：如果不连续，说明前一个区间 [start, nums[i-1]] 已经结束
            if nums[i] != nums[i - 1] + 1:
                # 把上一个区间加入结果：
                # 如果区间起点 start 和终点 nums[i-1] 相等，说明这个区间只有一个数字 → 直接加入 str(start)
                if start == nums[i - 1]:
                    res.append(str(start))
                else:
                    # 否则，加入 "start->end"
                    res.append(f"{start}->{nums[i - 1]}")
                
                # 当前元素 nums[i] 作为新一段区间的起点
                start = nums[i]
        
        # 别忘了处理最后一个区间
        # 循环结束后，还要处理最后一段区间（因为循环里只有在遇到不连续时才会记录）
        # 检查最后的区间：
        # - 如果只有一个数字：直接加 str(start)
        # - 否则：加 "start->end"
        if start == nums[-1]:
            res.append(str(start))
        else:
            res.append(f"{start}->{nums[-1]}")
        
        return res
```

- 时间复杂度：`O(n)`，只遍历数组一次
- 空间复杂度：`O(1)`（若不计输出所占空间），否则输出列表最多包含 `n` 个区间字符串

### 写法 2

从数组的位置 `0` 出发，向右遍历。每次遇到相邻元素之间的差值大于 `1` 时就找到了一个区间。遍历完数组后就能得到一系列的区间的列表

在遍历过程中，维护下标 `left` 和 `right` 分别记录区间的起点和终点，对于任何区间都有 `left ≤ right`。当得到一个区间时，根据 `left` 和 `right` 的值生成区间的字符串表示
- 当 `left < right` 时，区间的字符串表示为 `"left → right"`
- 当 `left = right` 时，区间的字符串表示为 `"left"`

```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        res = []
        i = 0
        n = len(nums)

        while i < n:
            left = i
            i += 1
            while i < n and nums[i] == nums[i - 1] + 1:
                i += 1
            
            right = i - 1
            temp = [str(nums[left])]

            if left < right:
                temp.append("->")
                temp.append(str(nums[right]))
            
            res.append("".join(temp))
        
        return res
```
