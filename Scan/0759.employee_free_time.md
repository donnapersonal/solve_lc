# 759.员工空闲时间

题目链接：[759.员工空闲时间](https://leetcode.cn/problems/employee-free-time/)

## 题目大意

给定员工的 `schedule` 列表，表示每个员工的工作时间

每个员工都有一个非重叠的时间段 `Intervals` 列表，这些时间段已经排好序

返回表示所有员工的共同，正数长度的空闲时间的有限时间段的列表，同样需排好序

```js
Example 1:
Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation: There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].
We discard any intervals that contain inf as they aren't finite.

Example 2:
Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]
```

限制：
- 1 <= schedule.length , schedule[i].length <= 50
- 0 <= schedule[i].start < schedule[i].end <= 10^8

## 解题

一个简单但低效的做法：
- 把每个员工的工作区间两两比较，看哪些时间段没有覆盖到任何区间，枚举时间点或者扫描时间轴
- 时间复杂度会非常高，尤其当区间多时，需要大量交叉检查

### 写法 1

我们要的是所有员工都空闲的时间段，本质就是`求所有区间的并集后，找到并集之间的间隙`，具体步骤：
- 合并所有员工的区间：
  - 把所有人的区间平铺到一个列表里
  - 根据开始时间排序
- 扫描并找间隙：
  - 用 `prev_end` 记录当前合并区间的最远结束时间
  - 遍历后续区间，如果下一个区间的 `start` 大于 `prev_end`，说明这中间是个空闲时间段
  - 更新 `prev_end = max(prev_end, 当前区间的 end)`，继续扫描
- 这样只需：
  - 一次排序 `O(nlogn)`（`n` 是区间总数）
  - 一次扫描 `O(n)`
  - 最终复杂度：`O(nlogn)`，空间复杂度 `O(n)`

```js
/**
 * // Definition for an Interval.
 * function Interval(start, end) {
 *    this.start = start;
 *    this.end = end;
 * };
 */

/**
 * @param {Interval[][]} schedule
 * @return {Interval[]}
 */
var employeeFreeTime = function(schedule) {
    // 将所有区间合并成一个数组
    let intervals = [];
    for (let employee of schedule) {
        for (let interval of employee) {
            intervals.push(interval);
        }
    }

    // 按照区间的开始时间进行排序
    intervals.sort((a, b) => a.start - b.start);
    // 用于保存结果的空闲时间段
    let freeTime = [];
    // 初始化第一个时间段
    let prevEnd = intervals[0].end;
    
    // 遍历排序后的所有时间段
    for (let i = 1; i < intervals.length; i++) {
        // 如果当前区间的开始时间大于前一个区间的结束时间，说明中间有空闲时间
        if(intervals[i].start > prevEnd) freeTime.push(new Interval(prevEnd, intervals[i].start));
        // 更新前一个区间的结束时间
        prevEnd = Math.max(prevEnd, intervals[i].end);
    }
    return freeTime;
};
```
```python
"""
# Definition for an Interval.
class Interval:
    def __init__(self, start: int = None, end: int = None):
        self.start = start
        self.end = end
"""

class Solution:
    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        # 将 schedule（二维结构）打平，得到所有员工的区间集合 intervals
        # 如：[[[1,2],[5,6]], [[1,3]]] → 打平后是 [1,2],[5,6],[1,3]
        intervals = [interval for employee in schedule for interval in employee]
        # 按照每个区间的 start 升序排序，方便后续合并扫描
        intervals.sort(key=lambda x: x.start)
        # 创建结果列表 free_time，用来存放最终的空闲时间段
        free_time = []
        # 用 prev_end 保存当前已经扫描到的区间合并后的 最远结束时间
        # 初始化为第一个区间的 end
        prev_end = intervals[0].end
        # 从第二个区间开始依次遍历，因为第一个区间已经初始化了 prev_end
        for i in range(1, len(intervals)):
            # 如果当前区间的 start 大于 prev_end，说明：
            # - 在 prev_end 和 intervals[i].start 之间没有任何区间覆盖
            # - 这是一个空闲时间段，创建 Interval(prev_end, intervals[i].start) 并加入 free_time
            if intervals[i].start > prev_end:
                free_time.append(Interval(prev_end, intervals[i].start))
            
            # 更新 prev_end：
            # - 如果当前区间的结束时间更靠后，就更新 prev_end
            # - 保证 prev_end 始终记录已合并区间的最远边界
            prev_end = max(prev_end, intervals[i].end)
        
        # 遍历完成后，free_time 中收集了所有的空闲时间段，返回它
        return free_time
```

- 时间复杂度: `O(nlogn)`
  - `n` 是所有员工的所有工作时间区间的总数
  - 主要时间消耗在排序操作上，为 `O(nlogn)`
  - 遍历和合并区间的操作是 `O(n)`
- 空间复杂度: `O(n)`
  - 需存储所有工作时间区间，空间为 `O(n)`
  - 合并后的区间也需要 `O(n)` 空间
  - 最终结果也需 `O(n)` 空间

### 写法 2

更通用且直观的做法：直接在时间线上把所有的“开始工作”与“结束工作”当作事件，然后按时间顺序扫描，看看什么时候所有人都不忙

我们想知道：在时间线上的某个时刻，有多少个员工正在工作
- 用`事件计数法（扫描线算法 / Sweep Line）`：
  - 把每个工作区间拆成两个事件：
    - `start` → 一个“打开”事件（开始工作）
    - `end` → 一个“关闭”事件（结束工作）
  - 把所有事件按照时间排序
  - 用一个 `bal` 变量来维护当前同时在工作的区间数（“活跃数”）
  - 当 `bal` 从 `0` 变成 `>0`，说明刚进入忙碌；当 `bal` 从 `>0` 变回 `0`，说明刚进入空闲
- 这样就能在一次扫描里找到所有“空闲”区间

思路步骤：
- 把所有区间拆成 `(time, type)` 事件，`type` 表示 `OPEN（开始工作`）或 `CLOSE（结束工作）`
- 按时间排序事件
- 用 `bal` 维护当前正在忙碌的员工数：
  - 当 `bal == 0` 且上一个时间 `prev` 存在，到下一个时间 `t`，这段 `[prev, t]` 就是所有人空闲的时间
  - 遇到 `OPEN` 事件 `bal++`，遇到 `CLOSE` 事件 `bal--`
- 返回所有找到的空闲时间段

```python
class Solution:
    def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
        # 定义两个常量，用来标记事件类型：
        # - OPEN = 0：表示某个区间的开始
        # - CLOSE = 1：表示某个区间的结束
        OPEN, CLOSE = 0, 1
        intervals = []
        # 遍历每个员工 emp 的每个区间 iv：
        # - 把 iv.start 转成一个 打开事件 (iv.start, OPEN)
        # - 把 iv.end 转成一个 关闭事件 (iv.end, CLOSE)
        # 收集到 intervals 列表里，这样 intervals 就是所有员工的所有开始/结束事件
        for emp in schedule:
            for iv in emp:
                intervals.append((iv.start, OPEN))
                intervals.append((iv.end, CLOSE))
        
        # 按时间排序所有事件，保证扫描时是按时间顺序处理的
        # Python 元组默认按第一个元素排序，如果时间相同，会按 OPEN/CLOSE 排序，这里 OPEN = 0、CLOSE = 1，意味着 同一时刻先处理开始事件再处理结束事件
        intervals.sort()

        res = []
        # prev：记录空闲时间段的起点，当 bal 从非零变为零时更新
        prev = None
        # bal：当前正在进行的工作区间数（活跃数），初始为 0
        bal = 0
        # 遍历每个事件 (t, cmd)：t 是时间点；cmd 是事件类型（OPEN or CLOSE）
        for t, cmd in intervals:
            # 如果此刻 bal == 0，表示之前处于空闲状态，且 prev 不是 None，说明有一个空闲时间段的起点
            # 则 Interval(prev, t) 就是一个空闲区间，加入 res
            if bal == 0 and prev is not None:
                res.append(Interval(prev, t))
            
            # 根据事件类型调整 bal：
            # - 如果是开始事件，活跃数 bal 加 1
            # - 如果是结束事件，活跃数 bal 减 1
            bal += 1 if cmd is OPEN else -1
            # 更新 prev 为当前时间点，作为下一段区间的起点参考
            prev = t
        
        # 扫描完成后，res 里就是所有的空闲区间，返回它
        return res
```

- 时间复杂度：`O(nlogn)`，主要来自事件排序（`n` 是总区间数 `× 2`）
- 空间复杂度：`O(n)`，用来存储事件和结果