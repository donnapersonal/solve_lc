# 208.实现 Trie (前缀树)

题目链接：[208.实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

## 题目大意

`Trie`（发音类似 `"try"`）或者说前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查

请实现 `Trie` 类：
- `Trie()` 初始化前缀树对象
- `void insert(String word)` 向前缀树中插入字符串 `word`
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即在检索之前已经插入）；否则，返回 `false` 
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix`，返回 `true`；否则，返回 `false`

```js
Example 1:
Input
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
Output
[null, null, true, false, true, null, true]

Explanation
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
```

限制:
- 1 <= word.length, prefix.length <= 2000
- word and prefix consist only of lowercase English letters.
- At most 3 * 104 calls in total will be made to insert, search, and startsWith.

## 解题

`Trie` 是一种树状结构：
- 每个节点代表一个字符
- 从根节点到某个节点的路径组成一个前缀
- 特别适合处理大量字符串的前缀匹配问题

优点：
- 插入、搜索、前缀匹配时间复杂度都是 O(k)，k 是字符串长度
- 节省空间（可共享前缀）

```js
class TrieNode {
    constructor() {
        // 使用 Map 存储子节点
        this.children = new Map();
        // 标志该节点是否为一个完整单词的结尾
        this.isEnd = false;
    }
}

var Trie = function() {
    // 初始化 Trie 树根节点
    this.root = new TrieNode();
};

/** 
 * @param {string} word
 * @return {void}
 */
Trie.prototype.insert = function(word) {
    // 从根节点开始插入
    let node = this.root;
    for (let char of word) {
        // 如果当前字符不在子节点中，则新建一个子节点
        if (!node.children.has(char)) node.children.set(char, new TrieNode());
        // 移动到子节点
        node = node.children.get(char);
    }
    // 插入结束后，标记最后一个字符节点为完整单词的结尾
    node.isEnd = true;
};

/** 
 * @param {string} word
 * @return {boolean}
 */
Trie.prototype.search = function(word) {
    // 从根节点开始查找
    let node = this.root;
    for (let char of word) {
        // 如果当前字符不在子节点中，返回 false
        if (!node.children.has(char)) return false;
        // 移动到子节点
        node = node.children.get(char);
    }
    // 判断最后一个字符节点是否为完整单词的结尾
    return node.isEnd;
};

/** 
 * @param {string} prefix
 * @return {boolean}
 */
Trie.prototype.startsWith = function(prefix) {
    // 从根节点开始查找前缀
    let node = this.root;
    for (let char of prefix) {
        // 如果当前字符不在子节点中，返回 false
        if (!node.children.has(char)) return false;
        // 移动到子节点
        node = node.children.get(char);
    }
    // 前缀存在，返回 true
    return true;
};
```
```python
# 定义 Trie 树的节点结构
class TrieNode:
    def __init__(self):
        # children 是一个字典，存储所有子节点
        # 存储子节点，key 是字符，value 是 TrieNode
        self.children = {}
        # is_end 表示是否为某个单词的结束字符节点
        # 表示以该节点结尾的是否是一个完整单词
        self.is_end = False

class Trie:
    # 初始化 Trie 树，创建一个空的根节点
    def __init__(self):
        # 创建根节点，表示空字符串
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        # 从根节点开始遍历字符串的每个字符
        node = self.root
        for char in word:
            # 若当前字符不存在于当前节点的子节点中，就创建一个新的节点
            if char not in node.children:
                node.children[char] = TrieNode()
            
            # 移动到下一个节点
            node = node.children[char]
        
        # 最后将最后一个字符的节点设置为 is_end = True，表示一个完整的单词已插入
        node.is_end = True   
       
    def search(self, word: str) -> bool:
        # 同样从根节点出发，遍历字符
        node = self.root
        for char in word:
            # 若中途找不到对应字符，说明单词不存在
            if char not in node.children:
                # 路径中断，说明单词不存在
                return False
            
            node = node.children[char]
        
        # 最后返回 is_end 判断是否是完整单词，而不是仅仅是前缀
        # 必须是完整单词才返回 True
        return node.is_end

    # 判断是否存在前缀
    # 与 search 类似，但只要能遍历完 prefix 的所有字符就返回 True，不要求是完整单词 
    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            
            node = node.children[char]
        return True
```

- 时间复杂度：
  - 初始化：`O(1)`
  - 插入操作、查找操作和前缀查找操作的时间复杂度：`O(∣S∣)`，`∣S∣` 是插入或查找字符串的长度
- 空间复杂度：`O(∣T∣×∣Σ∣)`，其中 `∣T∣` 是所有插入字符串的长度之和，`∣Σ∣` 是字符集的大小