# 86.分隔链表

题目链接：[86.分隔链表](https://leetcode.cn/problems/partition-list/)

## 题目大意

给一个链表的头节点 `head` 和一个特定值 `x`，请对链表进行分隔，使得所有`小于 x`的节点都出现在`大于或等于 x`的节点前

应当`保留`两个分区中每个节点的初始相对位置

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2vewhvlwev.webp)

限制：
- The number of nodes in the list is in the range [0, 200].
- -100 <= Node.val <= 100
- -200 <= x <= 200

## 解题

最初思路：原地移动节点
- 从头遍历链表，遇到 `< x` 的节点就“剪切”出来放到前面，遇到 `>= x` 的节点就保持不动
- 问题：
  - 不方便直接在原链表中随意插入，链表插入和删除操作较麻烦
  - 需要不断更新前驱节点、当前节点，容易写出 `bug`，逻辑混乱

既然要区分两类节点，不如新建两个链表：
- `list1`：保存所有 `< x` 的节点
- `list2`：保存所有 `>= x` 的节点
- 遍历一遍后，把 `list1` 和 `list2` 串联起来，得到最终结果

优点：
- 逻辑清晰，避免频繁插入、删除操作
- 遍历一次即可完成，时间复杂度 `O(n)`
- 保持相对顺序，因为只是按顺序连接到两个新链表里

```js
var partition = function(head, x) {
    let dummy1 = new ListNode(-1), dummy2 = new ListNode(-1);
    let p1 = dummy1, p2 = dummy2;
    let p = head;
    while (p != null) {
        if (p.val >= x) {
            p2.next = p;
            p2 = p2.next;
        } else {
            p1.next = p;
            p1 = p1.next;
        }

        let temp = p.next;
        p.next = null;
        p = temp;
    }
    p1.next = dummy2.next;
    return dummy1.next;
};
```
```python
# 写法 1
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        # 创建两个虚拟头节点，分别表示：
        # - dummy1：小于 x 的链表头
        # - dummy2：大于等于 x 的链表头
        # 为什么用虚拟头？- 避免处理头节点时写复杂的特判逻辑
        dummy1, dummy2 = ListNode(-1), ListNode(-1)
        # p1 指向当前“小于 x”链表的最后一个节点，初始时指向 dummy1
        # p2 指向当前“大于等于 x”链表的最后一个节点，初始时指向 dummy2
        p1, p2 = dummy1, dummy2
        # p 用于遍历原始链表，从 head 开始逐个节点处理
        p = head
        # 当 p 不为空时，说明还有节点没处理
        # 注意：这里没有改变节点顺序，只是按类别分配到两个链表，顺序保持原样
        while p != None:
            # 如果当前节点 p.val >= x：
            # - 将此节点接到“大于等于 x”链表的末尾：p2.next = p
            # - 移动 p2 到新添加的节点：p2 = p2.next
            if p.val >= x:
                p2.next = p
                p2 = p2.next
            else:
                # 否则（当前节点 < x）：
                # - 将此节点接到“小于 x”链表的末尾：p1.next = p
                # - 移动 p1 到新添加的节点：p1 = p1.next
                p1.next = p
                p1 = p1.next
            
            # 断开原链表的指向
            # temp = p.next：记录当前节点的下一个节点
            temp = p.next
            # p.next = None：把当前节点从原链表“断开”，避免形成环
            p.next = None
            # p = temp：移动 p 到下一个待处理节点
            p = temp
        
        # 合并两个链表
        # 小于 x 的链表接上大于等于 x 的链表
        # dummy2.next 是大于等于 x 链表的第一个真实节点
        p1.next = dummy2.next
        # 返回 dummy1.next，即最终重新组合后的链表头
        return dummy1.next

# 写法 2
class Solution:
    def partition(self, head: Optional[ListNode], x: int) -> Optional[ListNode]:
        small_dummy = ListNode(0)
        large_dummy = ListNode(0)
        small = small_dummy
        large = large_dummy
        
        while head:
            if head.val < x:
                small.next = head
                small = small.next
            else:
                large.next = head
                large = large.next

            head = head.next
        
        # 拼接
        large.next = None
        small.next = large_dummy.next
        
        return small_dummy.next
```

- 时间复杂度：`O(n)`，其中 `n` 是原链表的长度，对该链表进行了一次遍历
- 空间复杂度：`O(1)`