# 161.相隔为 1 的编辑距离

题目链接：[161.相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)

## 题目大意

给定两个字符串 s 和 t ，如果它们的编辑距离为 1 ，则返回 true ，否则返回 false 

字符串 s 和字符串 t 之间满足编辑距离等于 1 有三种可能的情形：
- 往 s 中插入 恰好一个 字符得到 t
- 从 s 中删除 恰好一个 字符得到 t
- 在 s 中用 一个不同的字符 替换 恰好一个 字符得到 t

```js
Example 1:
Input: s = "ab", t = "acb"
Output: true
Explanation: We can insert 'c' into s to get t.

Example 2:
Input: s = "", t = ""
Output: false
Explanation: We cannot get t from s by only one step.
```

限制:
- 0 <= s.length, t.length <= 10^4
- s and t consist of lowercase letters, uppercase letters, and digits.

## 解题

思路：`左右双指针 + 长度匹配`
- 先扫描前缀相同部分 → 得到左指针 `l`
- 再扫描后缀相同部分 → 得到右指针 `r`
- 检查剩余部分长度是否为 `1`
- 如果是 → 正好一处不同 → 返回 `True`；否 → 返回 `False`

优点：
- 时间复杂度 `O(n)`
- 空间复杂度 `O(1)`
- 不生成新字符串，不需要多余操作

```js
var isOneEditDistance = function(s, t) {
    let l = 0, r = 0;
    const ns = s.length, nt = t.length;

    while (l < ns && l < nt && s[l] === t[l]) {
        l++;
    }

    while (r + l < ns && r + l < nt && s[ns - r - 1] === t[nt - r - 1]) {
        r++;
    }

    return l + r + 1 === Math.max(ns, nt);
};
```
```python
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        # l → 左指针，从字符串开头向右扫描
        l = 0
        # r → 右指针，从字符串结尾向左扫描
        r = 0
        ns, nt = len(s), len(t)

        # 扫描前缀相同部分
        # 条件解释：
        # l < ns and l < nt → 指针不越界
        # s[l] == t[l] → 当前字符相同，继续扫描
        # l += 1 → 左指针右移
        # 作用：找到两个字符串第一个不同字符的位置（或者前缀完全相同）
        while l < ns and l < nt and s[l] == t[l]:
            l += 1
        
        # 扫描后缀相同部分
        # 条件解释：r + l < ns and r + l < nt → 避免前后指针交叉
        # 前缀已经匹配 l 个字符
        # 后缀匹配 r 个字符
        # 避免重复计算或越界
        # s[ns - r - 1] == t[nt - r - 1] → 从结尾开始字符相同，继续扫描
        # r += 1 → 右指针增加匹配长度
        # 作用：找到两个字符串最后一个不同字符的位置（或者后缀完全相同）
        while r + l < ns and r + l < nt and s[ns - r - 1] == t[nt - r - 1]:
            r += 1
        
        # 判断剩余中间部分长度是否为 1
        # l + r → 前后匹配的字符总数
        # +1 → 剩下中间不匹配的字符正好是 唯一的一次编辑操作
        # max(ns, nt) → 长度较长的字符串总长度
        # 如果相等 → 正好一处不同 → 返回 True
        # 否则 → 返回 False
        return l + r + 1 == max(ns, nt)

# 写法 2
class Solution:
   def isOneEditDistance(self, s: 'str', t: 'str') -> 'bool':
       ns, nt = len(s), len(t)

       # 确保 s 比 t 短
       if ns > nt:
           return self.isOneEditDistance(t, s)

       # 如果长度差异大于 1，则字符串不是一个编辑距离
       if nt - ns > 1:
           return False

       for i in range(ns):
           if s[i] != t[i]:
               # 如果字符串具有相同的长度
               if ns == nt:
                   return s[i + 1:] == t[i + 1:]
               # 如果字符串具有不同的长度
               else:
                   return s[i:] == t[i + 1:]
       
       # 如果在 ns 距离上没有差异，则仅当 t 有多一个字符时，字符串才有一次编辑
       return ns + 1 == nt
```

- 时间复杂度：`O(min(n, m))`，只需扫描前缀和后缀，不需要遍历整个字符串
- 空间复杂度：`O(1)`，仅使用常数指针 `l` 和 `r`