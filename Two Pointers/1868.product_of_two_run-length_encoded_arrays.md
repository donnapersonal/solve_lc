# 1868.两个行程编码数组的积

题目链接：[1868.两个行程编码数组的积](https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays/)

## 题目大意

行程编码（Run-length encoding）是一种压缩算法，能让一个含有许多段连续重复数字的整数类型数组 nums 以一个（通常更小的）二维数组 encoded 表示。每个 encoded[i] = [vali, freqi] 表示 nums 中第 i 段重复数字，其中 vali 是该段重复数字，重复了 freqi 次

例如， nums = [1,1,1,2,2,2,2,2] 可表示称行程编码数组 encoded = [[1,3],[2,5]] 。对此数组的另一种读法是“三个 1 ，后面有五个 2 ”
两个行程编码数组 encoded1 和 encoded2 的积可以按下列步骤计算：
- 将 encoded1 和 encoded2 分别扩展成完整数组 nums1 和 nums2 
- 创建一个新的数组 prodNums ，长度为 nums1.length 并设 prodNums[i] = nums1[i] * nums2[i] 
- 将 prodNums 压缩成一个行程编码数组并返回之
- 给定两个行程编码数组 encoded1 和 encoded2 ，分别表示完整数组 nums1 和 nums2 。nums1 和 nums2 的长度相同。 每一个 encoded1[i] = [vali, freqi] 表示 nums1 中的第 i 段，每一个 encoded2[j] = [valj, freqj] 表示 nums2 中的第 j 段

返回 encoded1 和 encoded2 的乘积

注：行程编码数组需压缩成可能的最小长度

```js
Example 1:
Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
Output: [[6,6]]
Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].
prodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [[6,6]].

Example 2:
Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
Output: [[2,3],[6,1],[9,2]]
Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].
prodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [[2,3],[6,1],[9,2]].
```

限制:
- 1 <= encoded1.length, encoded2.length <= 10^5
- encoded1[i].length == 2
- encoded2[j].length == 2
- 1 <= vali, freqi <= 10^4 for each encoded1[i].
- 1 <= valj, freqj <= 10^4 for each encoded2[j].
- The full arrays that encoded1 and encoded2 represent are the same length.

## 解题

`双指针`思路：
- 维持 `i` 和 `j` 两个指针分别指向 `encode1` 和 `encoded2`
- 每次遍历取当前最短的长度，那么结果和长度就是新的结果，同时减去对应的长度
- 一旦出现长度为 `0`，则递增对应的 `i` 和 `j`
- 需要考虑乘法后相等情况，需要和当前结果最后数值比较，相等则直接加数字即可

```js
/**
 * @param {number[][]} encoded1
 * @param {number[][]} encoded2
 * @return {number[][]}
 */
var findRLEArray = function(encoded1, encoded2) {
    const res = [];
    let i = 0, j = 0;
    const n1 = encoded1.length, n2 = encoded2.length;
    
    while (i < n1 && j < n2) {
        // Determine overlap length
        const length = Math.min(encoded1[i][1], encoded2[j][1]);
        const mul = encoded1[i][0] * encoded2[j][0];
        
        // Merge with last if same value
        if (res.length > 0 && res[res.length - 1][0] === mul) {
            res[res.length - 1][1] += length;
        } else {
            res.push([mul, length]);
        }
        
        // Subtract used length
        encoded1[i][1] -= length;
        encoded2[j][1] -= length;
        
        // Move pointers if zero
        if (encoded1[i][1] === 0) i++;
        if (encoded2[j][1] === 0) j++;
    }
    
    return res;
};
```
```python
class Solution:
    def findRLEArray(self, encoded1: List[List[int]], encoded2: List[List[int]]) -> List[List[int]]:
        res = []
        i = j = 0
        n1, n2 = len(encoded1), len(encoded2)
        
        while i < n1 and j < n2:
            # Determine overlap length
            length = min(encoded1[i][1], encoded2[j][1])
            mul = encoded1[i][0] * encoded2[j][0]
            
            # Merge with last if same value
            if res and res[-1][0] == mul:
                res[-1][1] += length
            else:
                res.append([mul, length])
            
            # Subtract used length
            encoded1[i][1] -= length
            encoded2[j][1] -= length
            
            # Move pointers if zero
            if encoded1[i][1] == 0:
                i += 1
            if encoded2[j][1] == 0:
                j += 1
        
        return res
```