# 215.数组中的第K个最大元素

题目链接：[215.数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 题目大意

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素

请注意，需找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素

不经过排序能解决吗？必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题

```js
Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5

Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
```

限制：
- 1 <= k <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4

## 解题

初始思路：排序法（Brute Force）
- 直接对 `nums` 排序，然后返回第 `k` 个最大的元素（即第 `len(nums) - k` 个）
  ```python
  nums.sort()
  return nums[-k]
  ```
- 但时间复杂度：`O(nlogn)`，排序的代价较高
- 在大多数面试场景下，面试官希望不使用全排序，因为不关心其他无用元素的顺序

### 思路 1: 优先级队列 - 使用最小堆（Min Heap）

不必排序整个数组，只需找出第 `k` 大的元素 — 可以维护一个`大小为 k 的最小堆`，这样堆顶始终是当前第 `k` 大的元素

核心思想：
- 最小堆里最多保留 `k` 个数
- 遍历整个数组：
  - 把每个数都放进堆
  - 一旦堆的大小超过 `k`，就把堆顶（最小值）移除
- 最终，堆中保留的是当前最大的 `k` 个数，其中最小的那个就是`第 k 大`

可把小顶堆 `pq` 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 `k` 时，就删掉堆顶的元素，因为这些元素比较小，而想要的是前 `k` 个最大元素

当 `nums` 中的所有元素都过了一遍后，筛子里留下的就是最大的 `k` 个元素，而堆顶元素是堆中最小的元素，即「第 `k` 个最大的元素」

```js
var findKthLargest = function(nums, k) {
    let pq = new MinPriorityQueue();
    for (let num of nums) {
        pq.enqueue(num);
        if (pq.size() > k) pq.dequeue();
    }
    // pq 中剩下的是 nums 中 k 个最大元素，
    // 堆顶是最小的那个，即第 k 个最大元素
    return pq.front().element;
};
```
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 初始化一个空列表 pq，它将用作最小堆
        # Python 中的 heapq 默认是最小堆
        pq = []

        # 遍历整个 nums 数组，将每个数都放入堆中处理
        for num in nums:
            # 使用 heapq.heappush() 把当前的 num 加入堆中，堆会自动维护最小堆结构
            heapq.heappush(pq, num)

            # 如果当前堆的大小超过了 k，就说明多了，需移除一个最小值（堆顶元素），保证只保留当前最大的 k 个数
            if len(pq) > k:
                # heappop() 会弹出最小的元素
                # 这步保证了堆中始终只保留关心的前 `k` 大元素
                heapq.heappop(pq)

        # 遍历完后，pq 中剩下的是 nums 中 k 个最大元素，堆顶元素 pq[0] 就是第 k 大的数
        # 因为堆中保留的是最大的 k 个数，而堆顶是这 k 个数中最小的
        return pq[0]
```

- 时间复杂度：`O(nlogk)`
  - 二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里堆的大小不会超过 `k`，所以插入和删除元素的复杂度是 `O(logk)`
  - 再套一层 `for` 循环，总的时间复杂度就是 `O(nlogk)`
- 空间复杂度：`O(k)`，只维护了 `k` 个元素的最小堆

### 思路 2: 快速排序 - 写法 1

核心思想：
- 与快速排序类似，选择一个随机基准值 `pivot`，然后将数组分成三类：
  - `big`：比 `pivot` 大的数
  - `equal`：等于 `pivot` 的数
  - `small`：比 `pivot` 小的数
- 然后根据 `k` 的位置判断：
  - 如果第 `k` 大在 `big` 中：递归查找 `big` 中的第 `k` 大
  - 如果第 `k` 大在 `small` 中：递归查找 `small` 中的第 `k - len(big) - len(equal)` 大
  - 否则第 `k` 大就是 `pivot`

优点：平均时间复杂度是 `O(n)`，比堆更快

缺点：最坏情况下退化成 `O(n²)`，但可通过随机化 `pivot` 来降低风险

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 参数 nums：输入的无序整数数组
        # 参数 k：需要找到第 k 大的元素
        # 返回值：数组中第 k 大的数字
        return self.quickSelect(nums, k)

    def quickSelect(self, nums: List[int], k: int) -> int:
        # 在 nums 中随机选择一个元素作为基准值 pivot
        # 随机化可以有效降低最坏时间复杂度出现的概率
        pivot = random.choice(nums)

        # 三分法划分数组：这是 QuickSelect 的核心操作，目的是将问题缩小规模
        # big：所有比 pivot 大的元素
        big = [x for x in nums if x > pivot]
        # equal：所有等于 pivot 的元素
        equal = [x for x in nums if x == pivot]
        # small：所有比 pivot 小的元素
        small = [x for x in nums if x < pivot]

        # 如果 k 小于等于 big 的个数，说明第 k 大的元素一定在 big 中
        if k <= len(big):
            # 继续在 big 里查找第 k 大
            # 不用转换 k，因为仍在寻找前 k 大
            return self.quickSelect(big, k)
        
        # 如果 k 大于 big + equal 的元素数量，说明第 k 大在 small 中
        if k > len(big) + len(equal):
            # 要在 small 中查找的是第 k - len(big) - len(equal) 大
            # 因为已经排除掉了 big 和 equal 的所有元素
            return self.quickSelect(small, k - len(big) - len(equal))
        
        # 否则，pivot 就是第 k 大的元素
        # 即，k 落在 equal 区间中，直接返回 pivot 即可
        return pivot
```

- 时间复杂度：`O(n)`
  - 平均情况：`O(n)`
  - 最坏情况（极端划分）：`O(n²)`
- 空间复杂度：`O(n)`，因为每次递归都新建了三个列表（`big/equal/small`）

如果要优化空间，可以使用原地 `partition`，但那样写法会复杂很多

### 思路 2: 快速排序 - 写法 2

使用：`快速选择（QuickSelect）+ 原地划分` -> 这是 快速排序思想的改进版本
- 不必对所有元素排序
- 每次随机选一个基准值（这里用的是左边界值）
- 将数组划分为两边，判断第 `k` 大在哪边
- 只对一边继续递归
- 平均时间复杂度：`O(n)`
✅ 最优方案，且是`原地操作`，空间复杂度低

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        # Python 的快速选择函数一般用于找「第 k 小」，所以转换成「第 n - k 小」
        # 如：找第 2 大 → 等价于找第 n - 2 小
        return self.quickselect(nums, 0, n - 1, n - k)
    
    def quickselect(self, nums, l, r, k):
        # 递归终止条件：如果左右指针重合，说明区间只剩一个数了，直接返回第 k 个
        if l == r:
            return nums[k]
        
        # 选择划分的基准值 x（这里取的是区间左端点 nums[l]）
        x = nums[l]
        # i 初始化为 l - 1，用于从左往右扫描
        # j 初始化为 r + 1，用于从右往左扫描
        i, j = l - 1, r + 1

        # 当两个指针没有交叉时，继续划分过程
        while i < j:
            # 从左往右移动 i，直到找到一个大于等于 x 的元素（需交换）
            # 因为要找第 k 大，所以排序方向是：大值在左，小值在右
            while True:
                i += 1
                if nums[i] >= x:
                    break
            
            # 从右往左移动 j，直到找到一个小于等于 x 的元素（需要交换）
            while True:
                j -= 1
                if nums[j] <= x:
                    break

            # 如果两个指针未交叉，则交换 i 与 j 的元素，使得：
            # 左边的值更大；右边的值更小
            # 这个过程本质是在进行 Hoare Partition（荷兰国旗） 的变种 —— 原地划分
            if i < j:
                nums[i], nums[j] = nums[j], nums[i]
        
        # 如果目标位置 k 落在左边 l ~ j 的区间中，那么递归左半部分继续查找
        if k <= j:
            return self.quickselect(nums, l, j, k)
        else:
            # 否则，说明第 k 个元素在右侧区间 j+1 ~ r，递归右半部分
            return self.quickselect(nums, j + 1, r, k)
```

- 时间复杂度：平均 `O(n)`，最坏 `O(n²)`（极端分区）
- 空间复杂度：`O(1)`，`原地划分`，无需额外存储（递归栈 `O(log n)`）

> 相比使用 `list` 切片的三分法（每轮都复制数组），这个写法更高效更节省内存