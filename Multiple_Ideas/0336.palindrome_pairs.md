# 336.回文对

题目链接：[336.回文对](https://leetcode.cn/problems/rearrange-string-k-distance-apart/)

## 题目大意

给定一个由唯一字符串构成的 `0` 索引数组 `words` 

回文对是一对整数 `(i, j)`，满足以下条件：
- `0 <= i, j < words.length`
- `i != j`，并且
- `words[i] + words[j]`（两个字符串的连接）是一个回文串

返回一个数组，它包含 `words` 中所有满足回文对条件的字符串

必须设计一个时间复杂度为 `O(sum of words[i].length)` 的算法

```js
Example 1:
Input: words = ["abcd","dcba","lls","s","sssll"]
Output: [[0,1],[1,0],[3,2],[2,4]]
Explanation: The palindromes are ["abcddcba","dcbaabcd","slls","llssssll"]

Example 2:
Input: words = ["bat","tab","cat"]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["battab","tabbat"]

Example 3:
Input: words = ["a",""]
Output: [[0,1],[1,0]]
Explanation: The palindromes are ["a","a"]
```

限制：
- 1 <= words.length <= 5000
- 0 <= words[i].length <= 300
- words[i] consists of lowercase English letters.
  
## 解题

### 思路 1: 贪心 + 哈希表 + 回文检查

解题思路：
- 构建哈希表：将每个字符串和它的索引存储到哈希表 `word_map` 中，方便后续查找
- 遍历每个单词：对于每个单词 `words[i]`，将它分成两部分 -- 前缀和后缀，并检查这两部分是否能与其他单词拼接成回文
- 检查条件：
  - 若 `prefix` 是回文且 `suffix` 的反转存在于 `word_map` 且不是当前单词本身，则 `suffix + words[i]` 是一个回文
  - 若 `suffix` 是回文且 `prefix` 的反转存在于 `word_map` 且不是当前单词本身，则 `words[i] + prefix` 是一个回文
- 特殊情况：如果 `words[i]` 本身是回文且 `""`（空字符串）存在于 `words` 中，则 `words[i]` 和 `""` 的组合也满足条件

```js
var palindromePairs = function(words) {
    const res = [];
    // 创建单词到索引的映射
    const wordMap = new Map();
    words.forEach((word, index) => wordMap.set(word, index));

    const isPalindrome = function(word, start, end) {
        while (start < end) {
            if (word[start] !== word[end]) return false;
            start++;
            end--;
        }
        return true;
    };

    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const n = word.length;

        // 检查每个单词的前缀
        for (let j = 0; j <= n; j++) {
            // 检查后缀是否为回文
            if (isPalindrome(word, j, n - 1)) {
                // 找反转的前缀
                const revPrefix = word.slice(0, j).split('').reverse().join('');
                if (wordMap.has(revPrefix) && wordMap.get(revPrefix) !== i) {
                    res.push([i, wordMap.get(revPrefix)]);
                }
            }
            
            // j > 0 避免重复
            if (j > 0 && isPalindrome(word, 0, j - 1)) {
                // 找反转的后缀
                const revSuffix = word.slice(j).split('').reverse().join('');
                if (wordMap.has(revSuffix) && wordMap.get(revSuffix) !== i) {
                    res.push([wordMap.get(revSuffix), i]);
                }
            }
        }
    }
    return res;
}
```
```python
class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        def is_palindrome(word: str, start: int, end: int) -> bool:
            while start < end:
                if word[start] != word[end]:
                    return False
                start += 1
                end -= 1
            return True
        
        # 创建单词到索引的映射
        word_dict = {word: i for i, word in enumerate(words)}
        res = []

        for i, word in enumerate(words):
            n = len(word)
            # 将字符串分为两部分：
            # - 前缀： word[:j]，即 word[0] 到 word[j-1]
            # - 后缀： word[j:]，即 word[j] 到 word[n-1]
            for j in range(n + 1):
                # 检查后缀是否为回文
                if is_palindrome(word, j, n - 1):
                    # 找反转的前缀
                    rev_prefix = word[:j][::-1]
                    if rev_prefix in word_dict and word_dict[rev_prefix] != i:
                        res.append([i, word_dict[rev_prefix]])
                
                # j > 0 避免重复
                # 避免重复处理某些特殊情况（例如，前缀为空和后缀为空的情况）
                if j > 0 and is_palindrome(word, 0, j - 1):
                    # 找反转的后缀
                    rev_suffix = word[j:][::-1]
                    if rev_suffix in word_dict and word_dict[rev_suffix] != i:
                        res.append([word_dict[rev_suffix], i])
                        
        return res
```

- 时间复杂度：`O(n⋅k^2)`
  - 构建哈希表：构建这个哈希表需遍历 `words` 数组一次，因此时间复杂度为 `O(n)`，`n` 是 `words` 中的单词数量
  - 遍历每个单词：外层循环遍历每个单词 `word`，总共有 `n` 个单词，因此这部分的时间复杂度为 `O(n)`
  - 检查每个单词的前缀和后缀：对每个单词，检查所有可能的分割点：`O(k)`，`k` 是平均单词长度；对每个分割点：检查回文需 `O(k)`，字符串反转和字典查找需 `O(k)`
  - `n` 个单词的总复杂度为 `O(n⋅k^2)`
- 空间复杂度：`O(n^2)`
  - 哈希表的存储：需要存储每个单词的索引映射，因此哈希表 `word_dict` 的空间复杂度为 `O(n)`
  - `res` 列表存储满足条件的索引对，最坏情况下，所有单词都可以组成回文对，`res` 的空间复杂度为 `O(n^2)`

### 思路 2: 字典树

```python
from typing import List

class Node:
    def __init__(self):
        self.children = [None] * 26  # a-z
        self.words = []              # indices of words ending exactly here
        self.suffixes = []           # indices of words whose remaining suffix is palindrome

class Solution:
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
        self.root = Node()
        n = len(words)

        # Helper function to check palindrome
        def is_palindrome(word: str) -> bool:
            return word == word[::-1]

        # Build Trie with reversed words
        for i, word in enumerate(words):
            rev = word[::-1]
            cur = self.root
            if is_palindrome(rev):
                cur.suffixes.append(i)
            for j, ch in enumerate(rev):
                idx = ord(ch) - ord('a')
                if cur.children[idx] is None:
                    cur.children[idx] = Node()
                cur = cur.children[idx]
                if is_palindrome(rev[j+1:]):
                    cur.suffixes.append(i)
            cur.words.append(i)

        res = []

        # Search pairs
        for i, word in enumerate(words):
            cur = self.root
            j = 0
            while j < len(word):
                # If remaining part of word is palindrome, all words ending at cur.words can pair
                if is_palindrome(word[j:]):
                    for k in cur.words:
                        if k != i:
                            res.append([i, k])
                idx = ord(word[j]) - ord('a')
                if cur.children[idx] is None:
                    break
                cur = cur.children[idx]
                j += 1

            # If full word is traversed, all words in suffixes list can form palindrome pairs
            if j == len(word):
                for k in cur.suffixes:
                    if k != i:
                        res.append([i, k])

        return res
```

- 时间复杂度：`O(n*k^2)`，`n` 是单词数量，`k` 是最长单词的长度
  - 构建 `Trie` 树：将 `n` 个长度为 `k` 的单词插入前缀树中，总计：`O(n*k)`
  - 查找回文对：对于每个单词 `word[i]`，遍历它的每个前缀和后缀，对每个前缀和后缀进行回文判断和前缀树查找操作
    - 回文判断 `isPalindrome` 的时间复杂度是 `O(k)`
    - 前缀树查找的时间复杂度也是 `O(k)`
    - 每个单词最多检查 `k` 个前缀和 `k` 个后缀
- 空间复杂度：`O(n*k + n^2)`
  - `Trie` 树存储：`O(n*k)`
  - 结果数组：`O(n^2)` 最坏情况
