# 32.最长有效括号

题目链接：[32.最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

## 题目大意

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度

```js
Example 1:
Input: s = "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()".

Example 2:
Input: s = ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()".

Example 3:
Input: s = ""
Output: 0
```

限制：
- 0 <= s.length <= 3 * 10^4
- s[i] is '(', or ')'.

## 解题

### 思路 1: 栈

思路：栈 + 下标

核心思想：用下标栈来记录“最近一个无法与之配对的边界”与“尚未匹配的左括号的位置”

关键技巧：栈内存下标而不是字符；栈底放一个哨兵 `-1` 作为“最后一个不合法位置”的边界

过程：
- 遇到 `'('`：把它的下标入栈（潜在的“开括号”）
- 遇到 `')'`：先弹出一个栈顶（尝试匹配一个 `'('`）
- 如果栈非空：说明成功拥有“未匹配边界”，用 `i - stack[-1]` 计算以当前 `i` 结尾的最长有效长度
- 如果栈为空：说明以当前 `i` 为止不存在可连接的有效串，把 `i` 当作新的“无效边界”入栈（相当于替换哨兵）

为什么要哨兵 `-1`：
- 便于统一计算长度，如当最前面就形成 `()` 时，长度是 `i - (-1) = i + 1`，无需特判“从开头开始”的情况
- 优点：实现简洁、常数小、推理直观

```js
var longestValidParentheses = function(s) {
    let maxLen = 0;
    // 初始栈顶元素，用于计算长度
    const stack = [-1]; 
    for (let i = 0; i < s.length; i++) {
        if (s[i] === '(') {
            // 将'('的索引入栈
            stack.push(i); 
        } else {
            // 将栈顶元素出栈，匹配')'
            stack.pop(); 
            if (stack.length > 0) {
                maxLen = Math.max(maxLen, i - stack[stack.length - 1]);
            } else {
                // 如果栈为空，将')'的索引入栈作为新的起始位置
                stack.push(i); 
            }
        }
    }
    return maxLen;
};
```
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # max_len：当前发现的最长有效括号子串长度
        max_len = 0
        # 初始化栈为 [-1]：
        # -1 是哨兵边界，表示“上一个不合法位置”
        # 这样当从索引 0 开始就出现有效串时，长度可直接 i - (-1) 计算
        stack = [-1] 

        # 遍历字符串，同时拿到下标 i 和字符 char
        # 用下标是为了后续直接计算长度
        for i, char in enumerate(s):
            # 遇到 '('：把它的下标入栈，表示一个“尚未匹配”的开括号位置
            # 未来如果遇到 ')'，就有机会把它和这个 '(' 配对
            if char == '(':
                stack.append(i) 
            else:
                # 遇到 ')'：先弹出一个位置
                # 理想情况：弹出的是最近的 '(' 的下标，完成一次匹配
                # 如果弹出后栈空了，说明刚刚没有可匹配的 '('（要么开头是 ')'，要么 ')' 太多），需重置边界
                stack.pop() 

                # 如果弹出后栈仍不为空：
                # 栈顶 stack[-1] 是“最近一个未被匹配的边界（可能是某个多余的 ')' 的下标，或哨兵 -1）”
                # 以当前 i 结尾的最长有效子串长度 = i - stack[-1]，更新 max_len
                if stack:
                    max_len = max(max_len, i - stack[-1])
                else:
                    # 如果弹出后栈空了：
                    # 说明当前 ')' 无法配对，以它为界之后才可能出现新的有效串
                    # 把当前下标 i 入栈，作为新的“无效边界”
                    stack.append(i) 

        # 返回全局最大长度
        # 关键不变量：栈里始终存放“未匹配的下标”，以及“最近无效位置的下标”（栈底）
        # 每次能配出一段有效串时，用当前下标减去“最近无效位置”来得到这段的长度
        return max_len
```

- 时间复杂度：`O(n)`，`n` 是字符串的长度
  - 只需要遍历字符串一次
  - 每个字符最多被压入和弹出栈一次
  - 所有操作都是常数时间
- 空间复杂度：`O(n)`
  - 使用一个栈来存储索引
  - 最坏情况下，栈中可能存储 `n` 个元素（当所有字符为 `'('` 时）

### 思路 2: 动态规划

可以发现：
- 有效括号一定以 `')'` 结尾（不能以 `'('` 结尾）
- 如果能快速找到前面已构成的有效串，并“接上”当前的括号对，就能构造更长子串

状态定义：设 `dp[i]` 表示以第 `i` 个字符结尾的最长有效括号子串的长度

状态转移：
- 如果 `s[i] == ')'` 且 `s[i-1] == '('`
  - 找到一对 `"()"`：则 `dp[i] = dp[i-2] + 2`（如果 `i-2` 存在）
- 如果 `s[i] == ')'` 且 `s[i-1] == ')'`
  - 说明可能是形如 `"((...))"` 的嵌套结构，需去 `i - dp[i-1] - 1` 判断前面是不是 `'('`
  - 如果是：`dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`（注意前缀还要加上之前的有效串）

动态规划思路：
- 初始化一个数组 `dp`，长度为字符串 `s` 的长度，初始值为 `0`。`dp[i]` 表示以 `s[i]` 结尾的最长有效括号的长度
- 遍历字符串 `s`，从索引 `1` 开始（因为以 `')'` 开头的子串不可能是有效的括号）
  - 如果 `s[i]` 是 `')'`，则分以下两种情况：
    - 情况 1：如果 `s[i - 1]` 是 `'('`，则 `s[i-1]` 和 `s[i]` 构成了一个新的有效括号对。此时 `dp[i] = dp[i - 2] + 2`（如果 `i >= 2`，则加上 `dp[i - 2]`，否则只加 `2`）
    - 情况 2：如果 `s[i - 1]` 是 `')'`，且 `i - dp[i - 1] - 1` 的位置是 `'('`，则 `s[i - dp[i - 1] - 1]` 和 `s[i]` 组成新的有效括号对。因此，`dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2`（如果 `i - dp[i - 1] >= 2`）
- `dp` 数组中的最大值即为最长有效括号的长度

```js
var longestValidParentheses = function(s) {
    const n = s.length;
    const dp = new Array(n).fill(0); // 初始化 dp 数组
    let maxLen = 0;
    for (let i = 1; i < n; i++) {
        if (s[i] === '(') continue
        if (s[i - 1] == '(') {
            dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
        } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] === '(') {
            dp[i] = dp[i - 1] + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
};
```
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # 获取字符串长度
        n = len(s)
        # 定义 dp 数组，dp[i] 表示以第 i 个字符结尾的最长有效括号子串的长度
        # 初始化为全 0
        dp = [0] * n
        # 用于记录当前找到的最大有效长度
        max_len = 0

        # 从索引 1 开始遍历（因为索引 0 不可能构成以 ')' 结尾的合法括号串）
        for i in range(1, n):
            # 如果当前位置是 '('，它无法成为一个有效括号串的结束，所以跳过
            if s[i] == '(':
                continue
            
            # 检查是否形成 "()" 的情况
            # 如果 s[i] 是 ')' 且 s[i - 1] 是 '('，说明找到一个直接配对的括号对 ()
            if s[i - 1] == '(':
                # 如果前两个字符是 "()"，我们可以加上前面已经构成的有效串（如果存在）
                # dp[i-2] 是 "()" 前面的有效串长度
                if i >= 2:
                    dp[i] = dp[i - 2] + 2
                else:
                    # 如果 i == 1，即子串刚好就是 "()"，直接为 2
                    dp[i] = 2
            # 第二种情况：当前是 ')'，前一个是 ')'，且前面刚好是一个 '('
            # 检查是否满足形如 "((...))" 的嵌套或连接情况
            # 当 s[i] == ')' 且 s[i - 1] == ')' 时
            # i - dp[i - 1] 表示从 i 位置往前跳过 dp[i - 1] 个有效括号子串的起始位置
            # 如果 s[i - dp[i - 1] - 1] == '('，则说明在 s[i] 和 s[i - dp[i - 1] - 1] 之间形成了一个新的有效括号子串
            # i - dp[i - 1] - 1 表示当前有效括号子串的前一个字符
            elif i - dp[i - 1] > 0 and s[i - dp[i - 1] - 1] == '(':
                # 如果再往前还有合法序列，就加上它
                # dp[i - 1] 是前一个合法串长度
                # dp[i - dp[i - 1] - 2] 是其之前的有效串
                # 最外层的 "()" 是 +2
                if i - dp[i - 1] >= 2:
                    dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2
                else:
                    # 没有更早的合法串可加，只能加当前的 2 和 dp[i-1]
                    dp[i] = dp[i - 1] + 2
            
            # 每次更新最大值
            max_len = max(max_len, dp[i])
        
        # 返回最终结果
        return max_len
```

- 时间复杂度：`O(n)`，其中 `n` 是字符串的长度，只需遍历字符串一次
- 空间复杂度：`O(n)`，需一个数组 `dp` 来存储每个位置的最长有效括号的长度

### 思路 3: 双指针

思路：双指针扫描 + 常数空间

注意到一个性质：如果从某个位置开始，左右括号的数量相等且在整个扫描过程中左括号数量不小于右括号，那这就是一个合法子串

因此可以：
- 从左往右扫描：统计 `(` 和 `)` 的数量
- 从右往左再扫一遍：防止像 `"(()"` 这类只有左括号的尾部被忽略

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        # 初始化结果变量 max_len，记录最大长度
        max_len = 0

        # 第一次扫描：从左往右
        # 初始化两个计数器，分别记录当前扫描过程中的 '(' 和 ')' 的数量
        left = right = 0

        # Left to Right
        # 遍历字符串，从左往右扫描每个字符
        for char in s:
            # 如果是 '('，左括号数量加一
            # 否则右括号加一
            if char == '(':
                left += 1
            else:
                right += 1
            
            # 当左右括号数量相等时，说明目前这一段是合法的，更新最大长度
            if left == right:
                max_len = max(max_len, 2 * right)
            
            # 如果右括号多于左括号，说明已经不可能构成合法括号串，重置计数器
            elif right > left:
                left = right = 0
        
        # 第二次扫描：从右往左
        # 重新初始化计数器，准备从右往左扫描
        left = right = 0
        # Right to Left
        # reversed(s) 表示字符串反向迭代
        for char in reversed(s):
            # 这次相反：遇到 ')' 增加右括号数量，'(' 增加左括号数量
            if char == ')':
                right += 1
            else:
                left += 1

            # 同样，如果数量相等，说明当前子串合法，更新最大长度
            if left == right:
                max_len = max(max_len, 2 * left)
            # 如果左括号比右括号多（不合法），重置
            elif left > right:
                left = right = 0

        # 返回遍历过程中记录的最大长度
        return max_len
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)` ✅最优空间！