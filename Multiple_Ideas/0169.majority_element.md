# 169.多数元素

题目链接：[169.多数元素](https://leetcode.cn/problems/majority-element/)

## 题目大意

给定一个大小为 `n` 的数组 `nums`，返回其中相同元素个数最多的元素（在数组中出现次数大于 `⌊ n/2 ⌋` 的元素）

可以假设给定的数组总是存在众数

```js
Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2
```

限制：
- n == nums.length
- 1 <= n <= 5 * 10^4
- -10^9 <= nums[i] <= 10^9

## 解题

### 思路 1: 哈希表

思路：使用哈希表（Map）计数 → O(n)
- 遍历数组 `nums`，对于当前元素 `num`，用一个哈希表（字典）来记录每个数字的出现次数：
  - 每次遇到一个数字，就将它在哈希表中的计数 `+1`
  - 一旦某个数字的出现次数超过 `n // 2`，立即返回它

为什么这方法合理？
- 题目保证多数元素一定存在
- 一旦某个元素出现次数大于 `n // 2`，就可以返回它
- 使用字典（哈希表）是快速统计频率的标准方式

```js
// 写法 1
var majorityElement = function(nums) {
    let n = nums.length;
    const newMap = new Map();
    for (let num of nums) {
        newMap.set(num, (newMap.get(num) || 0) + 1);
        if (newMap.get(num) > n / 2) return num;
    }
    return 0;
};

// 写法 2
var majorityElement = function(nums) {
    const newMap = new Map();
    for (const num of nums) {
        newMap.set(num, (newMap.get(num) || 0) + 1);
    }

    let max = -Infinity;
    let maxIndex = -1;
    for (const [num, count] of newMap) {
        if (count > max) {
            max = count;
            maxIndex = num;
        }
    }
    return maxIndex;
};
```
```python
# 写法 1
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # 记录数组的长度 n，后续用于判断出现次数是否超过 n // 2
        n = len(nums)
        # 创建一个空字典 newMap，用于统计每个元素的出现次数
        newMap = {}
        # 遍历数组中的每个数字 num
        for num in nums:
            # 使用 dict.get(key, default) 的方式来更新字典中该数字的出现次数
            # 如果 num 不在 newMap 中，则默认值为 0，+1 后变为 1
            # 如果已存在，就在原有计数基础上 +1
            newMap[num] = newMap.get(num, 0) + 1
            # 检查当前数字的计数是否超过一半
            # 如果超过，就立即返回该数字。因为题目保证多数元素一定存在，所以一旦满足条件就可以提前终止
            if newMap[num] > n // 2:
                return num
        
        # 理论上不会执行到这一行，因为题目已说明「多数元素一定存在」
        # 但加上它是良好的编程习惯，用于函数的默认返回值
        return 0

# 写法 2
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        newMap = dict()
        for num in nums:
            if num in newMap: 
                newMap[num] += 1  
            else:  
                newMap[num] = 1  
        
        # 初始化 max 为负无穷，max_index 为 -1
        max = float('-inf')
        max_index = -1
        for num in newMap:
            if newMap[num] > max:  
                max = newMap[num]
                max_index = num

        # 返回出现次数最多的元素（即众数）
        return max_index
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

### 思路 2: Moore's Voting Algorithm

> 寻找数组 `nums` 中的众数（即出现次数超过一半的元素），且题目指出是存在这个出现的次数过半的众数的，因此可以使用 `Boyer-Moore` 多数投票算法，具体可看：[如何理解摩尔投票算法？](https://www.zhihu.com/question/49973163/answer/235921864)

核心思想：多数元素的出现次数多于其他所有元素的出现次数之和，所以我们可以用“投票”方式逐步消除其他元素，最后剩下的一定是多数元素

思路：
- 初始化候选人 `res = 0`，计数器 `count = 0`
- 遍历数组：
  - 如果 `count == 0`，则当前元素 `nums[i]` 成为新的候选人
  - 如果当前元素 `== res`，就投票 `+1`
  - 否则投票 `-1`
- 遍历完后，`res` 即为多数元素（根据题意保证存在）

```js
var majorityElement = function(nums) {
    let n = nums.length;
    let res = nums[0], count = 0;

    for (let i = 0; i < n; i++) {
        if (count == 0) {
            res = nums[i];
            count = 1;
        } else if (nums[i] == res) {
            count++;
        } else {
            count--;
        }
    }
    return res;
};
```
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # res：当前候选元素，初始值为 0（可以是任意值，因为它会被第一个元素替代）
        # count：计数器，表示当前候选元素 res 出现的次数，初始值为 0
        res, count = 0, 0
        # 获取数组长度
        n = len(nums)
        # 遍历数组
        for i in range(n):
            # 当 count 为 0 时，表示当前没有候选元素（或之前的候选元素已经被抵消完）
            # 需将 nums[i] 设置为新的候选元素 res，并将 count 设置为 1
            if count == 0:
                # 把当前元素设为候选人
                res = nums[i]
                # 候选人得 1 票
                count = 1
            # 如果当前元素是候选人
            elif res == nums[i]:
                # 得票数 +1
                count += 1
            # 否则，认为是不同阵营，抵消一票
            else:
                # 如果当前元素 nums[i] 与候选元素 res 不同，说明这个元素可以与候选元素 res 进行抵消，减少 count 的值
                # 如果 count 变为 0，则表示之前的 res 出现的次数和其他元素出现的次数已经抵消完了，需要重新选取新的候选元素
                count -= 1
        
        # 当遍历完数组 nums 后，最终的 res 就是数组中的多数元素
        # 多数元素的个数超过了 ⌊ n/2 ⌋，所以在计数过程中，多数元素最终一定会胜出，即使与非多数元素进行相互抵消，剩下的最后一个 res 也必然是多数元素
        return res
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`，无需额外存储