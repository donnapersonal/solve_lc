# 347.前 K 个高频元素

题目链接：[347.前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

## 题目大意

给一个整数数组 `nums` 和一个整数 `k`，请返回其中出现频率前 `k` 高的元素，可以按`任意顺序`返回答案

```js
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:
Input: nums = [1], k = 1
Output: [1]
```

限制：
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- k is in the range [1, the number of unique elements in the array].
- It is guaranteed that the answer is unique.

## 解题

暴力解法思路：
- 统计每个数字的出现频率
- 按频率排序
- 取前 k 个结果

时间复杂度：
- 构建频率字典：`O(n)`
- 排序：`O(n log n)`
- 总体：`O(n log n)`

### 思路 1: 优先级队列 - 小顶堆

不需要对所有元素排序，只需维护一个大小为 `k` 的小顶堆（`min heap`），堆中保留当前频率最高的 `k` 个元素

为什么选小顶堆？
- 这样可以始终让堆顶保持为当前频率最小的那个元素
- 一旦有更大频率的新元素，就替换堆顶，确保最终留下频率前 `k` 高的

```js
var topKFrequent = function(nums, k) {
    // nums 中的元素 -> 该元素出现的频率
    let valToFreq = new Map();
    for (let v of nums) {
        valToFreq.set(v, (valToFreq.get(v) || 0) + 1);
    }

    let que = new MinPriorityQueue({ compare: (entry1, entry2) => {
        // 队列按照键值对中的值（元素出现频率）从小到大排序
        return entry1[1] - entry2[1];
    }});

    for (let entry of valToFreq.entries()) {
        que.enqueue(entry);
        if (que.size() > k) {
            // 弹出最小元素，维护队列内是 k 个频率最大的元素
            que.dequeue();
        }
    }

    let res = new Array(k);
    for (let i = k - 1; i >= 0; i--) {
        // res 数组中存储前 k 个最大元素
        res[i] = que.dequeue()[0];
    }
    return res;
};
```
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 使用 Python 内建的 collections.Counter 统计每个数字出现的频率
        # 示例：nums = [1,1,1,2,2,3] → valToFreq = {1:3, 2:2, 3:1}
        valToFreq = Counter(nums)
        # 初始化一个空的最小堆（Python 的 heapq 默认是小顶堆）
        pq = []
        # 遍历每个元素及其对应的出现频率
        for num, freq in valToFreq.items():
            # 将 (频率, 数字) 元组压入堆中
            # 因为 Python 的 heapq 是以元组第一个元素作为排序依据，这样堆顶就是频率最小的元素
            heapq.heappush(pq, (freq, num))

            # 如果堆的大小超过 k，说明目前保留了超过 k 个频率高的元素，需移除频率最小的那一个（即堆顶）
            # 保证堆中始终只保留 k 个高频元素
            if len(pq) > k:
                heapq.heappop(pq)
        
        # 初始化一个结果数组，用于保存最终的前 k 个高频元素
        res = []

        # 将堆中的元素逐个弹出，把数字（num）部分加入结果数组
        # 注意：此时的结果是 倒序的频率（从低到高），如有需求可以反转
        while pq:
            res.append(heapq.heappop(pq)[1])
        
        # 返回结果数组
        # 可以原样返回（顺序不重要），也可 res[::-1] 反转
        return res
```

- 时间复杂度: `O(nlogk)`，`n` 是输入数组的长度
  - 构建 valToFreq：`O(n)`
  - 维护堆：这个循环会执行 `k` 次，每次 `heappop` 操作的时间复杂度是 `O(logk)`，`O(nlogk)`
  - 构建结果列表：`O(klogk)`
- 空间复杂度: `O(n)`
  - 频率哈希表：`O(n)`
  - 最小堆：`O(k)`

### 思路 2: 桶排序（Bucket Sort）

核心思想：频率最多也只能是 `n`（即某个元素出现了 `n` 次）
- 构建一个 `bucket`，第 `i` 个桶里放出现频率为 `i` 的所有元素
- 倒序遍历桶，收集前 `k` 个元素即可

时间复杂度：`O(n)`，因为没有显式排序

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 使用 collections.Counter 来统计每个元素出现的频率
        # 如：nums = [1,1,1,2,2,3] -> 得到：valToFreq = {1: 3, 2: 2, 3: 1}
        valToFreq = Counter(nums)
        # 找出最大的频率值，作为桶排序中桶的数量依据
        # 例如：最大频率是 3，就需要 buckets[0] ~ buckets[3] 共 4 个桶
        max_count = max(valToFreq.values())

        # 构造一个桶数组 buckets，buckets[i] 代表所有出现频率为 i 的元素
        # 每个桶是一个列表，因为可能多个元素频率一样
        buckets = [[] for _ in range(max_count + 1)] 

        # 遍历频率表，把每个元素 x 放入对应频率 c 的桶中
        # 如：buckets[3] = [1], buckets[2] = [2], buckets[1] = [3]
        for x, c in valToFreq.items():
            buckets[c].append(x)
        
        # 初始化结果数组 res，用于存放前 k 个高频元素
        res = []

        # 从后向前遍历桶（因为频率高的在后面），优先拿到频率更高的元素
        for bucket in reversed(buckets):
            # 把当前桶里的所有元素加入结果数组
            # 这里使用的是 +=（而不是 append），可以一次加入多个元素
            res += bucket

            # 如果已经找够 k 个元素，提前返回
            # 注意：这个写法 只适用于频率刚好凑够 k 个元素的情况，如果出现多个频率相同的元素，可能需要改成 >= k 再截断前 k 个（见扩展）
            if len(res) == k:
                return res
        
        # 兜底返回，虽然正常流程下前面就应该返回了
        return res
```

- 时间复杂度: `O(n)`
- 空间复杂度: `O(n)`


### 思路 3: 计数排序

```js
var topKFrequent = function(nums, k) {
    let valToFreq = new Map();
    for (let num of nums) {
        valToFreq.set(num, (valToFreq.get(num) || 0) + 1);
    }

    let freqToVals = new Array(nums.length + 1).fill(null).map(() => []);
    for (let [val, freq] of valToFreq.entries()) {
        freqToVals[freq].push(val);
    }

    let res = new Array(k);
    let p = 0;
    for (let i = freqToVals.length - 1; i > 0; i--) {
        let valList = freqToVals[i];
        if (valList.length === 0) continue;
        for (let j = 0; j < valList.length; j++) {
            res[p] = valList[j];
            p++;
      ``      if (p === k) return res;
        }
    }
    return null;
};
```
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        valToFreq = Counter(nums)
        freqToVals = [[] for _ in range(len(nums) + 1)]
        for num, freq in valToFreq.items():
            freqToVals[freq].append(num)
        
        res = []
        for i in range(len(freqToVals) - 1, 0, -1):
            for val in freqToVals[i]:
                res.append(val)
                if len(res) == k:
                    return res
        
        return res
```

- 时间复杂度: `O(n)`
- 空间复杂度: `O(n)`