# 233.数字 1 的个数

题目链接：[233.数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)

## 题目大意

给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数

```js
Example 1:
Input: n = 13
Output: 6

Example 2:
Input: n = 0
Output: 0
```

限制：
- 0 <= n <= 10^9

## 解题

这道题在问：**`1` 到 `n` 这些数里，所有位数上（个位、十位、百位……）一共出现了多少次 `1`？**

最初直觉：暴力枚举
- 最简单的做法：从 `1` 遍历到 `n`，把每个数转成字符串，数一数 `1` 出现了多少次
- 时间复杂度：`O(nlog n)`，当 `n` 很大（如 `10^9`）时，显然无法在合理时间内完成

> 数学拆位法：有一种数学公式按位分析每一位 1 出现的次数，但推导较复杂，容易出错

### 思路 1：数位 DP

为了高效统计所有数位中 `1` 的出现次数，可以用`数位 DP`：
- 把问题转化为对每一位进行状态转移：
  - 从高位到低位枚举每一位数字
  - 记录「已经出现了多少个 1」
  - 根据是否受到 `n` 的上界约束来控制当前位的可选范围

> 一个关键观察：对于 `n = 5342`，如果我们想统计 `0 ~ 5342` 中 `1` 的出现次数，可以从最高位开始，逐位“决策”：
> - 第一位可以选择 `0~5`（受到 `n` 限制）
> - 第二位可以选择 `03`（如果第一位选的就是 `5`，否则可以选 `09`）
> - 第三位可以选择 `0~4`（同理，如果前两位和 `n` 对应的相同，就限制，否则可随便选）
> - 第四位可以选择 `0~2`（同理）
> 在做这些选择时：我们要统计下，到目前为止选了多少个 `1`，然后继续往下递归

状态设计：
- `i`：当前处理到第几位（从左到右）
- `cnt1`：之前选的数字中一共出现了多少次 `1`
- `is_limit`：当前位是否受上界约束（若前面的数位都与 `n` 的相等，则当前位的取值 `≤ n` 的当前位，否则可以取 `0~9`）

> 理解 `is_limit`
> - `is_limit` 表示当前这一层的前缀数字是否还和 `n` 的前缀完全相同
> - 如果还相同，则本位选的数字 `d` 就不能超过 `n` 这一位的数字
> - 如果前面已经小于 `n` 了，那后面就可以随便选 `0~9`（因为无论选什么都不会超过 `n`）

转移：
- 枚举当前位的数字 `d`，更新出现的 `1` 次数，进入下一位

终止条件：
- 如果 `i` 处理到最后一位 (`i == len(s)`)，返回目前累计的 `cnt1`

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        # 将整数 n 转换为字符串 s，方便逐位访问
        s = str(n)
        # 使用 Python 内置的 functools.cache 装饰器，给递归函数做记忆化缓存，避免重复计算相同状态
        @cache  
        # 定义一个递归函数 dfs 作为数位 DP
        # - i：当前处理到第几位（0 表示最高位）
        # - cnt1：前面已经统计到的 1 的数量
        # - is_limit：当前位是否受到上界约束
        def dfs(i: int, cnt1: int, is_limit: bool) -> int:
            # 递归结束条件：如果已经处理完所有位数 (i == len(s))，返回目前累计的 cnt1
            if i == len(s):
                return cnt1
            
            # 初始化本层递归结果 res 为 0
            res = 0
            # 确定当前位的最大可选数字：
            # - 如果 is_limit 为 True，这位最多取 s[i]
            # 否则，这位可以随便取 0~9
            up = int(s[i]) if is_limit else 9
            # 枚举当前位要放的数字 d：
            # - 如果 d == 1，就把计数 cnt1 加 1
            # - 下一层递归的 is_limit 只有在本层是 is_limit 且 d == up 时才为 True
            # - 对所有可能的 d 求和，累加到 res
            for d in range(up + 1): 
                # is_limit：本层之前的前缀必须没有超出 n（还保持相等的状态）
                # d == up：本层当前选的数字必须等于 n 当前位的数字（继续维持相等）
                # 只有这两个条件都满足，下一位才继续受限制，否则，就已经小于上界了，后续不用再限制
                # 否则：
                # - 如果本层前缀已经小于 n（is_limit=False），那后面都随便选 → 下一层 is_limit=False
                # - 如果本层选的 d < up，那么本层这一位就已经让数小于 n，后面都随便选 → 下一层 is_limit=False 
                res += dfs(i + 1, cnt1 + (d == 1), is_limit and d == up)
            
            # 返回当前状态下的统计结果
            return res
        
        # 从第 0 位开始，累计 1 的次数为 0，且最开始受到上界约束（因为还没选数）
        return dfs(0, 0, True)
```

- 时间复杂度：`O(m^2D)`，其中 `m=O(logn)`，`D=10`
  - 由于每个状态只会计算一次，动态规划的时间复杂度 = `状态个数 × 单个状态的计算时间`
  - 本题 `i` 和 `cnt1` 都有 `O(m)` 个，所以状态个数为 `O(m^2)`，单个状态的计算时间为 `O(D)`，所以动态规划的时间复杂度为 `O(m^2D)`
- 空间复杂度：`O(m^2)`，即状态个数

### 思路 2: 数学拆位法

由于本题只需求 `1` 出现的次数，而不需要求解 `0` 到 `9` 的出现次数，同时意味着不需要考虑统计 `0` 次数时的前导零边界问题

因此，也可以不当作数位 `DP` 题来做，直接用数学规律来直接算出 `1` 出现次数

观察每一位：
- 我们可以把 `n` 拆分成`「当前位 cur」「高位 high」「低位 low」`三部分来分析 -> `n = [高位部分][当前位][低位部分]`
- 假设我们正在统计某一位上的 `1` 出现次数，单位是 `factor`（个位时 `factor=1`，十位时 `factor=10`，百位时 `factor=100`…）

按 `cur` 不同情况分类：
- `当前位 = 0`：这一位上 `1 的次数 = high * factor`（因为高位每滚动一次，就产生 `factor` 次 `1`）
- `当前位 = 1`：这一位上 `1 的次数 = high * factor + (low + 1)`（除了高位滚动带来的次数，还要加上当前高位固定、当前位为 `1` 时低位贡献的部分）
- `当前位 > 1`：这一位上 `1 的次数 = (high + 1) * factor`（因为当前位已经过了 `1` 的那一轮，所以高位的次数要 `+1`）

对每一位重复上述计算，把结果累加

```js
var countDigitOne = function(n) {
    let count = 0, factor = 1;

    while (factor <= n) {
        const high = Math.floor(n / (factor * 10));
        const cur = Math.floor(n / factor) % 10;
        const low = n % factor;

        if (cur === 0) {
            count += high * factor;
        } else if (cur === 1) {
            count += high * factor + (low + 1);
        } else {
            count += (high + 1) * factor;
        }

        factor *= 10;
    }

    return count;
};
```
```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        # 最终答案：统计1的总次数
        count = 0
        # 当前要分析的位对应的权值，初始为 1（个位）
        # 每处理一位就乘 10，依次处理个位、十位、百位…
        factor = 1
        # 当 factor 超过 n 时，说明已经处理完最高位，结束循环
        while factor <= n:
            # 计算当前位的「高位部分」
            # 例如 n=5327，factor=10（十位）：high = 5327 // 100 = 53
            # 表示在十位左边的数字
            high = n // (factor * 10)
            # 当前位的数字
            # 例如 n=5327，factor=10：cur = (5327 // 10) % 10 = 532 % 10 = 2
            # 表示十位上是 2
            cur = (n // factor) % 10
            # 当前位右边的「低位部分」
            # 例如 n=5327，factor=10：low = 5327 % 10 = 7
            low = n % factor  


            # 当前位是 0，说明该位上不会出现 1
            # 如果当前位是 0（factor = 100）：
            # - 当前位上 1 的次数完全由高位决定
            # 百位只能由高位循环来产生 1：
            # - 每当高位从 00 → 01 → 02 … → 23，百位上的 1 都会出现一次完整的 100 个数
            # 所以次数 = 高位 * factor = 23 * 100 = 2300
            if cur == 0:
                # 所以只根据 更高位 来统计：比如 high=23，说明该位出现了 23 次 1，每次是连续的 factor 个
                count += high * factor
            elif cur == 1:
                # 如果当前位是 1：
                # - 先加上 high * factor（完整轮数的贡献，高位决定的完整次数）
                # - 再加上 (low + 1)（当前位固定为 1 时，低位从 0 到 low 的额外贡献）
                # 这一位中低位形成的额外部分：从 ...10 到 ...14 总共是 low + 1 次
                count += high * factor + (low + 1)
            else: 
                # 如果当前位 > 1：当前位是 2 ~ 9，说明 1 在当前位上出现了 (high + 1) 次完整的循环
                # 举例：cur = 3，那这一位的 1 完整出现了high + 1次（因为 cur > 1，多出了额外的一整段）
                count += (high + 1) * factor
            
            # 把 factor 提升到下一位（个位 → 十位 → 百位 →…）
            factor *= 10
        
        # 最终返回累计的次数
        return count
```

- 时间复杂度：`O(logn)`，`n` 包含的数位个数与 `n` 呈对数关系
- 空间复杂度：`O(1)`