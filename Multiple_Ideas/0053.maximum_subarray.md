# 53.最大子数组和

题目链接：[53.最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

## 题目大意

给一个整数数组 `nums`，请找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

子数组是数组中的一个连续部分

```js
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

Example 2:
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.

Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
```

限制:
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4

## 解题

暴力枚举
- 枚举所有子数组，计算每个子数组的和
- 两层循环（枚举起点、终点），一层求和

时间复杂度：`O(n³)`（或优化到 `O(n²)`）

问题：即使优化到 `O(n²)`，在数据量很大时仍然会超时

### 思路 1：前缀和 + 贪心

核心思想：
- 维护当前的前缀和 `pre_sum`
- 同时维护前缀和的最小值 `min_pre_sum`
- 当前能获得的最大子数组和为：`pre_sum - min_pre_sum`

为什么对？
- 某一段子数组和：`sum(i..j) = pre_sum[j+1] - pre_sum[i]`
- 想让结果尽可能大，就让前缀和差值最大 → 即：当前前缀和减去历史最小前缀和

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 初始化结果变量 res，表示当前找到的最大子数组和
        # 初始值设为负无穷，确保能被替换（防止数组中全是负数时出错）
        res = -inf
        # pre_sum：表示到当前位置为止的前缀和
        # min_pre_sum：表示遍历过程中遇到的最小前缀和（初始为 0）
        min_pre_sum = pre_sum = 0
        # 遍历每个元素 x
        for x in nums:
            # 更新前缀和，表示从起点到当前位置的累计和
            pre_sum += x  
            # 当前最大子数组和为 pre_sum - min_pre_sum：
            # 其中 min_pre_sum 是历史最小的前缀和
            # 当前这一步代表从某个历史最小点到当前位置的子数组的最大和
            res = max(res, pre_sum - min_pre_sum)  
            # 更新历史最小前缀和，为下一步比较做准备
            min_pre_sum = min(min_pre_sum, pre_sum)  
        
        # 返回最终结果，即最大子数组和
        return res
```

- 时间复杂度：`O(n)`，其中 `n` 为 `nums` 的长度
- 空间复杂度：`O(1)`，仅用到若干额外变量

### 思路 2：DP

`dp[i]` 有两种`选择`，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组

优化：因为只需前一个状态 `dp[i-1]` 的值就可推导出当前状态 `dp[i]` 的值。因此，可以将 `dp` 数组优化为常量空间变量，从而将空间复杂度优化为 `O(1)`

核心思想：
- 以第 `i` 个元素为结尾的最大子数组，可能有两个选择：
  - ① 继续接上前一个子数组（`cur_sum + nums[i]`）
  - ② 单独从当前位置开始新的子数组（`nums[i]`）
- 于转化为如下递推：`cur_sum = max(nums[i], cur_sum + nums[i])`
- 每一步都更新历史最大值：`max_sum = max(max_sum, cur_sum)`

```js
var maxSubArray = function(nums) {
    // 使用两个变量来替代 dp 数组
    let cur_sum = nums[0]  // 当前的子数组和
    let max_sum = nums[0]  // 最大子数组和
    for (let i = 1; i < nums.length; i++) {
        // 如果前面的子数组和小于 0，直接放弃，从 nums[i] 重新开始
        cur_sum = Math.max(nums[i], cur_sum + nums[i])
        // 更新最大子数组和
        max_sum = Math.max(max_sum, cur_sum)
    }
    return max_sum
};
```
```python
# 写法 1
# 时间复杂度：`O(n)`，代码只需遍历一次数组，因此时间复杂度为 `O(n)`，`n` 是数组 `nums` 的长度
# 空间复杂度：`O(n)`，代码使用了一个大小为 `n` 的 `dp` 数组来存储以每个 `nums[i]` 为结尾的最大子数组和
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        # 初始化 dp 数组，长度为 n，每个元素初始化为 0
        dp = [0] * (n)
        # dp[0] 表示第一个元素的最大子数组和，即为 nums[0]
        dp[0] = nums[0]
        # 从数组第二个元素开始遍历
        for i in range(1, n):
            # 如果前一个位置的最大子数组和是负数
            # 重新开始一个新的子数组，不包含前面的元素，因为负数会让和变小
            if dp[i - 1] < 0:
                # 则当前最大子数组和从 nums[i] 开始，不加前面的元素
                dp[i] = nums[i]
            else:
                # 如果前一个位置的最大子数组和是正数，则加上当前元素
                dp[i] = dp[i - 1] + nums[i]
        
        # 返回 dp 数组中的最大值
        return max(dp)

# 写法 2：Kadane’s Algorithm
# 空间优化
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 初始化两个变量：
        # - cur_sum：表示当前以第 i 个元素结尾的最大子数组和
        # - max_sum：表示全局历史最大子数组和
        # 为什么初始化为 nums[0]？
        # - 防止全为负数时错误返回 0
        # - 从第一个元素开始构造递推关系
        cur_sum = nums[0]
        max_sum = nums[0]

        # 从第二个元素开始遍历，逐步构建后续状态
        for i in range(1, len(nums)):
            # 核心递推公式：
            # nums[i]：如果之前累积的和是负数，不如从当前值重新开始
            # cur_sum + nums[i]：如果之前累积的是正贡献，继续加上当前值更优
            # 这步决定了是否要“断掉”前面的序列，从当前重新开始
            cur_sum = max(nums[i], cur_sum + nums[i])
            # 更新全局最大值
            # 如果当前子数组更大，则更新答案
            max_sum = max(max_sum, cur_sum)
        
        # 返回最终答案，即最大连续子数组的和
        return max_sum

# 写法 3
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = -inf  
        cur_sum = 0
        for x in nums:
            cur_sum = max(cur_sum, 0) + x
            res = max(res, cur_sum)
            
        return res
```

- 时间复杂度：`O(n)`，其中 `n` 为 `nums` 的长度
- 空间复杂度：`O(1)`，仅用到若干额外变量