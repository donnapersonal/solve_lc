# 24.两两交换链表中的节点

题目链接：[24.两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

## 题目大意

给一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点

必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9rjr9uwp60.webp)

限制：
- The number of nodes in the list is in the range [0, 100].
- 0 <= Node.val <= 100

## 解题

### 思路 1: 迭代

观察链表中每一对节点，执行如下操作：

```js
原始：cur → a → b → next  
交换：cur → b → a → next
```

也就是：
- 先记录 `a` 和 `b`（即 `cur.next` 和 `cur.next.next`）
- 改变三条指针关系：
  - `cur.next = b`
  - `b.next = a`
  - `a.next = next`
- 然后 `cur` 移动两步（到 `a`），进入下一轮
- 通过使用虚拟头节点 `dummy`，可以避免处理特殊情况（如头节点参与交换）时的复杂逻辑

```js
var swapPairs = function(head) {
    let dummy = new ListNode(-1);
    dummy.next = head;
    let cur = dummy;
    let temp, first, second;
    while (cur.next != null && cur.next.next != null) {
        temp = cur.next.next.next;
        first = cur.next;
        second = cur.next.next;
        cur.next = second;
        second.next = first;
        first.next = temp;
        cur = first;
    }
    return dummy.next;
};
```
```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 创建一个虚拟头节点 dummy，值任意，指向原链表的 head
        # 好处：方便处理头节点也参与交换的情况，避免复杂判断
        dummy = ListNode(-1)
        dummy.next = head

        # 定义 cur 指针，用于遍历链表，永远指向当前一对需要交换节点的前一个节点
        cur = dummy

        # 当 cur 后面有两个节点时（即还可以成对交换），进入循环
        # cur.next 是第一个要交换的节点（first），cur.next.next 是第二个（second）
        while cur.next and cur.next.next:
            # 保存第二个节点之后的那个节点（也就是下一对的第一个节点）—— 用于连接新链表
            temp = cur.next.next.next

            # 分别记录当前要交换的两个节点
            first = cur.next
            second = cur.next.next

            # 第一步交换：让 cur 指向 second（原本是 first 的位置）
            cur.next = second
            # 第二步交换：让 second 指向 first
            second.next = first
            # 第三步：让 first 指向下一组的第一个节点（原来的 second.next.next）
            # 此时链表变为：cur → second → first → temp
            first.next = temp
            # 将 cur 前移两步，准备处理下一对节点
            cur = first
        
        # 返回 dummy.next 即为新链表的头节点（防止原 head 被换掉）
        return dummy.next
```

- 时间复杂度：`O(n)`，每个节点只访问和操作一次
- 空间复杂度：`O(1)`，只使用了有限数量的指针变量

### 思路 2: 递归

为什么用递归？
- 链表天然具有递归结构
- 每一次只处理前两个节点，剩下的链表交给递归处理即可
- 代码短小清晰，思路直接

递归过程的关键：
- 当前层做的事：交换当前两个节点
- 递归调用：处理后续链表并接回前面交换过的节点
- 递归终止条件：节点为 `None` 或没有成对节点可交换

```js
// 写法 1
var swapPairs = function(head) {
    if (head == null || head.next == null) return head;
    let temp = head.next;
    let newNode = swapPairs(temp.next);
    temp.next = head;
    head.next = newNode;
    return temp;
};

// 写法 2
var swapPairs = function(head) {
    if (head == null || head.next == null) return head;
    let first = head;
    let second = head.next;
    let third = head.next.next;

    second.next = first;
    first.next = swapPairs(third);
    return second;
};`
```
```python
# 写法 1
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 递归终止条件：如果当前节点为 None（空链表），或当前节点后面没有节点了（只剩一个节点），无法成对交换，直接返回当前节点即可
        if head == None or head.next == None:
            return head
        
        # 定义当前要交换的一对节点：
        # first 是当前节点（即 head）
        # second 是 first.next，即下一个节点
        first, second = head, head.next
        # third 是接在 second 后面的节点（即下一段待递归处理的子链表头）
        third = head.next.next
        # 这一步完成 交换操作：
        # 原来是 first → second
        # 现在改成 second → first
        second.next = first

        # 将后续链表交给递归函数处理：
        # self.swapPairs(third) 会返回“剩下部分交换后”的新头节点
        # 然后把这个新头节点接到 first 的 .next 上
        first.next = self.swapPairs(third)
        # 返回交换后的新的子链表头：second
        # 原来是 first 在前，现在 second 已经是当前这对的头
        return second

# 写法 2
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        
        temp = head.next
        newNode = self.swapPairs(temp.next)
        temp.next = head
        head.next = newNode
        return temp
```

- 时间复杂度：`O(n)`
  - 每次递归调用都会将问题规模缩小两个节点，从而得到大约 `n/2` 递归调用，其中 `n` 是列表中节点的总数
  - 每次递归调用都执行恒定时间操作（在两个节点之间交换指针）
- 空间复杂度：`O(n)`
  - 对于每对节点，都会将一个新框架添加到堆栈中，由于递归每次进行两个节点，因此递归调用堆栈的最大深度为 `2/n`