# 322.零钱兑换

题目链接：[322.零钱兑换](https://leetcode.cn/problems/coin-change/)

## 题目大意

给一个整数数组 `coins`，表示不同面额的硬币；以及一个整数 `amount`，表示总金额

计算并返回可以凑成总金额所需的`最少的硬币个数`。如果没有任何一种硬币组合能组成总金额，返回 `-1` 

可以认为每种硬币的数量是`无限`的

```js
Example 1:
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Example 2:
Input: coins = [2], amount = 3
Output: -1

Example 3:
Input: coins = [1], amount = 0
Output: 0
```

限制：
- 1 <= coins.length <= 12
- 1 <= coins[i] <= 2^31 - 1
- 0 <= amount <= 10^4

## 解题

### 思路 1: BFS

这是一个 典型的“最少步数”问题，可以将它建模为从 `amount` 开始，每次减去一个 `coin`，直到减到 `0`

即可以将每个状态 `x` 视为图中的一个节点，边是“用掉一个 coin”，题目就是让我们找到从 `amount` 到 `0` 的最短路径长度

因此，用 `BFS` 求最短路径是最合适的思路

可以从 `amount` 开始，每次从 `coins` 的硬币中选中 `1` 枚硬币，并记录当前挑选硬币的次数，则最快减到 `0` 的次数就是凑成总金额所需的最少的硬币个数

```js
var coinChange = function(coins, amount) {
    if (amount === 0) return 0;
    const visited = new Set([amount]);
    const que = [amount];
    let step = 0;
    while (que.length > 0) {
        step++;
        const size = que.length;
        for (let i = 0; i < size; i++) {
            let cur = que.shift();
            for (let coin of coins) {
                if (cur == coin) return step;
                if (cur > coin && !visited.has(cur - coin)) {
                    que.push(cur - coin);
                    visited.add(cur - coin);
                }
            }
        }
    }
    return -1;
};
```
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 如果金额是 0，直接返回 0 —— 不需要任何硬币
        if amount == 0:
            return 0
        
        # 初始化 visited 集合，记录已经访问过的金额，避免重复搜索
        # 初始加入 amount，表示起点
        visited = set([amount])
        # 初始化 BFS 队列，起点是当前的金额 amount
        # BFS 的每一层表示“用了几枚硬币”
        que = collections.deque([amount])

        # 初始化步数（硬币数量），即我们 BFS 层数
        step = 0
        # 当队列不为空时，继续 BFS
        while que:

            # 每遍历一层，就相当于多用了一个硬币，步数 +1
            step += 1
            # 当前队列长度表示这一层的节点个数
            size = len(que)
            for i in range(size):
                # 遍历当前层所有节点，取出当前金额 cur
                cur = que.popleft()
                
                for coin in coins:
                    # 遍历所有硬币：如果当前金额刚好等于某个 coin，意味着刚好凑齐了，返回当前步数
                    if cur == coin:
                        return step
                    
                    # 否则，如果当前金额大于 coin 并且差值没访问过，则加入队列：
                    # cur - coin 就是下一层的状态
                    # 标记为已访问，避免重复入队
                    if cur > coin and cur - coin not in visited:
                        visited.add(cur - coin)
                        que.append(cur - coin)
        
        # 如果 BFS 完成都没有凑成 0，说明无解，返回 -1
        return -1
```

- 时间复杂度：`O(amount * n)`，每次迭代最多会产生 `n`(硬币种类数) 个新的状态，总共最多可能会遍历 `O(amount)` 层 `BFS`（即从 `amount` 减到 `0` 的过程）
- 空间复杂度：`O(amount)`，队列和集合中最多可能会存储所有从 `amount` 到 `0` 的所有状态，即可能会存储 `amount` 个状态

### 思路 2: 动态规划


这题可以看成是`完全背包`问题，转为使用「自底向上」的 一维动态规划
- 定义 `dp[i]` 表示凑出金额 `i` 所需的最少硬币数
- 初始值：`dp[0] = 0`（凑出 `0` 元需 `0` 枚硬币）
- 状态转移方程：`dp[i] = min(dp[i], dp[i - coin] + 1)` → 用当前 `coin` 来更新凑出金额 `i` 的最优方案

```js
// 先遍历物品再遍历背包
var coinChange = function(coins, amount) {
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0; 
    // 遍历每个硬币面值
    for(const coin of coins) {
        // 从当前硬币面值开始遍历，直到目标金额
        for(let i = coin; i <= amount; i++) {
            // 更新凑成金额 i 所需的最少硬币数量
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    // 若 dp[amount] 还是 Infinity，表示无法凑成目标金额，返回 -1
    return dp[amount] === Infinity ? -1 : dp[amount];
};

// 先遍历背包后遍历物品
var coinChange = function(coins, amount) {
    // 初始化 dp 数组，大小为 amount + 1，所有值初始化为 Infinity（表示无法凑成该金额）
    const dp = new Array(amount + 1).fill(Infinity);
    dp[0] = 0;  // 当金额为 0 时，所需硬币数为 0
    // 遍历背包容量
    for (let i = 1; i <= amount; i++) {
        // 遍历硬币
        for (const coin of coins) {
            if (i - coin >= 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    // 若 dp[amount] 还是 Infinity，表示无法凑成目标金额，返回 -1
    return dp[amount] === Infinity ? -1 : dp[amount];
};
```
```python
# 先遍历物品再遍历背包
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 创建一个大小为 amount + 1 的一维数组 dp
        # 初始将所有值设为 float("inf")，表示尚未计算或无法到达该金额
        # dp[i] 表示「凑出金额 i 所需的最少硬币数」
        dp = [float("inf")] * (amount + 1)
        # 初始化边界条件：凑出金额 0 不需要任何硬币，因此设为 0
        dp[0] = 0
        # 遍历每一种硬币 coin
        # 外层循环遍历「硬币维度」，确保不会重复使用同一个硬币在一个状态下更新两次（即支持完全背包
        for coin in coins:
            # 遍历金额从 coin 到 amount（即从能用该硬币的最小金额开始）
            # 内层循环用于更新所有可能由该 coin 构成的 i
            for i in range(coin, amount + 1):
                # 状态转移方程核心：
                # 如果能从 i - coin 这个金额凑出硬币数为 dp[i - coin]
                # 那么加上这枚 coin 后，凑出金额 i 所需硬币数就是 dp[i - coin] + 1
                # 和当前已有的 dp[i] 取最小值
                dp[i] = min(dp[i], dp[i - coin] + 1)
        
        # 最后判断：如果 dp[amount] 仍为无穷，说明无法凑出该金额 → 返回 -1
        # 否则，返回最少硬币数
        return dp[amount] if dp[amount] != float('inf') else -1

# 先遍历背包后遍历物品
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float("inf")] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin >= 0:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        
        return dp[amount] if dp[amount] != float("inf") else -1
```

- 时间复杂度: `O(amount * n)`，
  - 其中 `amount` 表示目标金额，`n` 表示硬币的种类数
  - 一共需要计算 `O(amount)` 个状态，`amount` 为题目所给的总金额
  - 对于每个状态，每次需枚举 `n` 个面额来转移状态，所以一共需要 `O(amount * n)` 的时间复杂度
- 空间复杂度: `O(amount)`，只使用了一个长度为 `amount + 1` 的数组 `dp` 来存储状态