# 23.合并 K 个升序链表

题目链接：[23.合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

## 题目大意

给一个链表数组，每个链表都已经按升序排列

请将所有链表合并到一个升序链表中，返回合并后的链表

```js
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6

Example 2:
Input: lists = []
Output: []

Example 3:
Input: lists = [[]]
Output: []
```

限制：
- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] is sorted in ascending order.
- The sum of lists[i].length will not exceed 10^4.

## 解题

### 思路 1: 优先级队列

核心：每条链表都已排序，因此它们各自的头结点中，最小值一定来自某个头；把这 `k` 个头放入小根堆，每次弹出最小的节点接到结果链表后，再把该节点的下一个节点压入堆

堆的大小始终 `≤ k`，所以每弹出/压入一次是 `O(log k)`；总共弹出 `n` 次 → `O(n log k)`

空间：堆大小 `O(k)`，结果链表就地复用原节点，额外空间小

这份代码采用的就是优先队列思路，并且通过 `(node.val, id(node), node)` 三元组入堆来解决 `Python` 中值相同节点无法比较的问题（否则 `heapq` 会尝试比较 `ListNode` 对象，报 `TypeError`）

```js
var mergeKLists = function(lists) {
    if (lists.length == 0) return null;
    let dummy = new ListNode(-1);
    let p = dummy;
    let pq = new MinPriorityQueue({compare: (a,b) => a.val - b.val});
    // 将 k 个链表的头结点加入最小堆
    for (let head of lists) {
        if (head != null) pq.enqueue(head);
    }

    while (!pq.isEmpty()) {
        let node = pq.dequeue();
        p.next = node;
        if (node.next != null) {
            pq.enqueue(node.next);
        }
        p = p.next;
    }

    return dummy.next;
};
```
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # 边界：如果 lists 为空（没有任何链表），直接返回空
        if not lists:
            return None
        
        # 新建虚拟头节点 dummy，用指针 p 作为结果链表的构造游标
        # 使用虚拟头是链表题的常用技巧：便于统一处理头节点连接，避免特判
        dummy = ListNode(-1)
        p = dummy

        # 定义一个最小堆（Python 用 heapq 实现的列表），用于按节点值从小到大取出当前最小的节点
        pq = []

        # 把每条链表的首节点入堆
        # 
        for head in lists:
            if head:
                # 入堆三元组是 (值, id(节点), 节点对象)：
                # heapq 比较元组时会先比第一项（值）；若值相等，会继续比第二项
                # 由于 ListNode 自身不可比较，若只放 (val, node)，当 val 相等时会去比较 node 对象，导致 TypeError，加入 id(node) 可作为稳定的次关键字来打破平局
                # id(node) 是 Python 解释器分配的对象地址/标识，确保不同节点在“值相等”时仍可比较
                heapq.heappush(pq, (head.val, id(head), head))
        
        # 循环直到堆空
        while pq: 
            # heappop 取出当前堆中最小值对应的三元组，[2] 拿到第三项，即真实的 ListNode 节点 node
            node = heapq.heappop(pq)[2]
            # 把这个最小节点接到结果链表当前尾部（p 的后面）
            p.next = node

            # 若该最小节点在原链表中还有后继（node.next），就把后继节点入堆
            # 这样就始终维持“每条链表的当前候选最小”在堆里，保证下次弹出仍然是全局最小
            if node.next:
                heapq.heappush(pq, (node.next.val, id(node.next), node.next))

            # 结果链表的游标后移一位，准备接下一个弹出的最小节点
            p = p.next
        
        # 返回虚拟头之后的真实头节点，即合并完成的有序链表
        return dummy.next
```

- 时间复杂度：`O(nlogk)`，其中 `n` 是所有节点的总数，`k` 是链表的数量
  - 每次都需从 `k` 个链表中找到当前最小的节点。堆的大小最多是 `k`，因为最多有 `k` 个链表在堆中排队
  - 在堆中插入元素的时间复杂度是 `O(logk)`，从堆中取出最小元素的时间复杂度也是 `O(logk)`
  - 总共有 `n` 个节点，因此 `n` 次插入与弹出操作，每次操作的复杂度是 `O(log k)`
- 空间复杂度：`O(k)`，其中 `k` 是链表的数量
  - 优先队列（最小堆）的最大空间是 `k`，因为每次只需将每个链表的头节点加入堆中，堆中最多同时存在 `k` 个元素，所以空间复杂度是 `O(k)`

### 思路 2: 分治归并法

分而治之的思想：将链表数组不断二分，转为规模为二分之一的子问题，然后再进行归并排序
- 可以将问题转化为合并两个有序链表的问题，通过递归地将 `k` 个链表两两合并

类似归并排序的思想：
- 将 `lists` 从中间划分为左右两半
- 分别对左右递归合并
- 最后把左右两个合并结果再合并成一个

不会破坏链表结构，空间更优

```js
var mergeKLists = function(lists) {
    if (lists.length == 0) return null;
    return mergeSort(lists, 0, lists.length - 1);
};

var mergeSort = function(lists, left, right) {
    if (left == right) return lists[left];
    let mid = left + Math.floor((right - left) / 2);
    let leftNode = mergeSort(lists, left, mid);
    let rightNode = mergeSort(lists, mid+1, right);
    return merge(leftNode, rightNode);
};

var merge = function(left, right) {
    let dummy = new ListNode(-1);
    let cur = dummy;

    while (left && right) {
        if (left.val < right.val) {
            cur.next = left;
            left = left.next;
        } else {
            cur.next = right;
            right = right.next;
        }
        cur = cur.next;
    }

    if (left) cur.next = left;
    if (right) cur.next = right;
    return dummy.next;
};
```
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # 处理边界情况：如果 lists 为空，则返回空指针 None
        if not len(lists):
            return None
        
        # 调用自定义的分治归并函数 mergeSort，初始区间为 [0, len-1]
        return self.mergeSort(lists, 0, len(lists) - 1)
    
    # 定义分治函数，作用是将 lists[left:right+1] 区间内的链表合并为一个
    def mergeSort(self, lists, left, right):
        # 递归终止条件：只剩一个链表，直接返回该链表
        if left == right:
            return lists[left]
        
        # 计算中点索引，防止溢出
        mid = left + (right - left) // 2

        # 递归处理左右两部分链表，最终返回两个已经合并的有序链表
        leftNode = self.mergeSort(lists, left, mid)
        rightNode = self.mergeSort(lists, mid + 1, right)
        # 合并这两个链表，并将结果返回
        return self.merge(leftNode, rightNode)
    
    # 合并两个有序链表
    def merge(self, left, right):
        # 创建一个哑节点 dummy 和指针 cur，用于构建结果链表
        dummy = ListNode(-1)
        cur = dummy

        # 进入循环：比较两个链表当前节点的值，较小者接入结果链表，并移动对应指针
        while left and right:
            if left.val < right.val:
                cur.next = left
                left = left.next
            else:
                cur.next = right
                right = right.next
            # 始终更新 cur 指针指向新尾部
            cur = cur.next
        
        # 如果左链表还有剩余，直接接上
        if left:
            cur.next = left
        
        # 同理，如果右链表还有剩余，也直接接上
        if right:
            cur.next = right
        
        # 返回合并链表的头部（去掉 dummy）
        return dummy.next
```

- 时间复杂度：`O(nlogk)`，`n` 是所有链表中节点的总数
  - 每次 `merge` 操作的时间复杂度为 `O(n)`，其中 `n` 是两个链表的总长度
  - 分治法将 `k` 个链表两两合并，递归的深度为 `O(log k)`
- 空间复杂度：`O(logk)`
  - 主要空间消耗来自递归调用栈，递归深度为 `O(logk)`
  - 其他辅助空间为常数级别 `O(1)`

