# 279.完全平方数

题目链接：[279.完全平方数](https://leetcode.cn/problems/perfect-squares/)

## 题目大意

给你一个整数 `n`，返回和为 `n` 的完全平方数的最少数量 

完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1、4、9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是

```js
Example 1:
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.

Example 2:
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
```

限制：
- 1 <= n <= 10^4

## 解题

思考方向：给定一个整数 n，我们要找出「最少多少个完全平方数」的和等于 n

例子：
n = 12  
=> 4 + 4 + 4 = 3 个  
=> 9 + 1 + 1 + 1 = 4 个（不是最优）

最直觉的方式是：对每一个平方数都尝试用它减掉 `n`，然后递归看还需要多少个

暴力解法（递归）：

```python
def dfs(n):
    if n == 0:
        return 0
    res = float('inf')
    for i in range(1, int(n ** 0.5) + 1):
        res = min(res, dfs(n - i*i) + 1)
    return res
```

问题：子问题会大量重复，导致超时

### 思路 1: BFS

为什么可以用 BFS？-> **这道题等价于一个 “最短路径”问题：从 n 开始，每次减去一个平方数，目标是走到 0，问最少走几步**
- 每一层代表「使用的平方数个数」
- 每一层扩展的是「当前数减去所有可能平方数」的结果
- `BFS` 最先找到的就是最短路径

BFS 的优势：
- 每一层就是用 `1` 个平方数、`2` 个平方数…
- 一旦某次减法结果为 `0`，说明当前层数就是答案！

```js
var numSquares = function(n) {
    if (n === 0) return 0;
    const visited = new Set();
    const que = [];
    visited.add(n);
    que.push(n);
    let count = 0;
    while (que.length) {
        // 最少步数
        count++;
        const size = que.length;
        for (let i = 0; i < size; i++) {
            const value = que.pop();
            for (let j = 1; j * j <= value; j++) {
                const x = value - j * j;
                if (x === 0) return count;
                if (!visited.has(x)) {
                    que.unshift(x);
                    visited.add(x);
                }
            }
        }
    }
}
```
```python
class Solution:
    def numSquares(self, n: int) -> int:
        # 处理边界情况，n == 0 时，不需要任何平方数
        if n == 0:
            return 0
        
        # 初始化：
        # visited：记录已经访问过的状态（避免重复访问）
        # que：BFS 队列，存储当前层要处理的数字
        visited = set()
        que = collections.deque([])
        
        # 从 n 开始向下搜索，所以把 n 加入队列和 visited 集
        visited.add(n)
        que.append(n)
        
        # count 表示当前 BFS 走了几步，也就是用了几个平方数
        count = 0

        # 只要队列不为空，就继续处理
        while que:
            # 每进入一层，代表多用了一个平方数
            count += 1
            # 记录当前层的大小，用于逐层处理
            size = len(que)
            for _ in range(size):
                # 弹出当前层的所有元素，进行下一步拓展。使用 pop() 是为了配合下面的 appendleft() 保持 BFS 顺序
                value = que.pop()
                # 尝试所有可能的平方数 i*i，其中 i 从 1 到 sqrt(value)
                for i in range(1, int(math.sqrt(value)) + 1):
                    # 下一层节点：从当前数减去平方数后的结果
                    x = value - i * i
                    # 如果减完等于 0，说明找到了目标，返回当前使用的平方数个数 count
                    if x == 0:
                        return count
                    
                    # 若当前结果没访问过，则加入队列头部，并标记为已访问
                    if x not in visited:
                        # 注意：这里使用 appendleft + pop，是为了保持 BFS 的正确顺序（也可改为 popleft + append，等价但更易懂）
                        que.appendleft(x)
                        visited.add(x)
```

- 时间复杂度：`O(n * √n)`，最坏情况下需遍历 `n` 层（`BFS` 的层数），每层最多检查 `O(√n)` 个完全平方数
- 空间复杂度：`O(n)`，`visited` 集合和 `que` 队列最多需要 `n` 个元素来记录每层可能的值

### 思路 2: 动态规划

可将这道题转换为`完全背包问题`中恰好装满背包的方案数问题
- 将 `k = 1, 4, 9, 16,...` 看做是 `k` 种物品，每种物品都可以无限次使用
- 将 `n` 看做是背包的装载上限
- 这道题就变成了，从 `k` 种物品中选择一些物品，装入装载上限为 `n` 的背包中，恰好装满背包最少需要多少件物品

定义状态：`dp[i]` 表示「组成数字 `i` 所需的最少完全平方数的个数」

状态转移方程：`dp[i] = min(dp[i - j*j] + 1), 其中 j*j ≤ i`
- 含义：枚举所有 `j`，其中 `j*j ≤ i`，尝试用 `j*j` 来构造当前的 `i`，然后取所有方案中的最小值

```js
var numSquares = function(n) {
    const dp = new Array(n + 1).fill(Infinity);
    dp[0] = 0;
    for (let i = 1; i <= n; i++) {
        let j = 1;
        while (j * j <= i) {
            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            j++;
        }
    }
    return dp[n];
}
```
```python
# 写法 1
class Solution:
    def numSquares(self, n: int) -> int:
        # 初始化一个大小为 n + 1 的数组 dp，下标从 0 到 n
        # 每个位置初始化为无穷大（表示尚未计算）
        # dp[i] 的含义是组成整数 i 所需的最少完全平方数的个数
        dp = [float('inf')] * (n + 1)

        # 边界条件：组成数字 0 不需要任何数，初始化为 0
        dp[0] = 0
        # 枚举从 1 到 n 的所有数字，依次填表，构建 dp[i]
        for i in range(1, n + 1):
            # 初始化平方根变量 j，从 1 开始尝试 j*j
            j = 1
            # 只要 j² ≤ i，就可以尝试用这个平方数 j*j 来构成当前的 i
            while j * j <= i:
                # 状态转移方程：
                # 当前的 i 可以由 i - j² 加上一个 j² 得到
                # 所以：dp[i] = min(dp[i], dp[i - j*j] + 1)
                # 取所有可能组合中的最小值
                dp[i] = min(dp[i], dp[i - j * j] + 1)
                # 尝试下一个平方数 j = 2, 3, 4... 直到 j*j > i
                j += 1
        
        # 最后返回 dp[n]，即组成 n 所需的最少平方数个数
        return dp[n]

# 写法 2
class Solution:
    def numSquares(self, n: int) -> int:
        # 初始化一个长度为 n + 1 的一维 dp 数组
        # dp[i] 表示凑出和为 i 所需的最小完全平方数个数
        # 初始值设置为 n + 1（即一个大于最大可能解的无穷大近似值，最大也就用 1 加 n 次）
        dp = [n + 1 for _ in range(n + 1)]

        # 边界条件：凑出 0 不需要任何数
        dp[0] = 0

        # 枚举所有可能的完全平方数 i*i，例如：1, 4, 9, 16...，不超过 n
        for i in range(1, int(sqrt(n)) + 1):
            # 当前的完全平方数，即「物品体积」
            num = i * i
            # 完全背包的核心写法：正序枚举背包容量 w，从 num 到 n
            # 正序保证每个物品可以被重复使用（即多次使用当前平方数）
            for w in range(num, n + 1):
                # 状态转移方程（完全背包模板）：
                # 要构造 w，可以使用一个 num（平方数），再加上 dp[w - num] 的最优解
                # 所以取 min(dp[w], dp[w - num] + 1)
                dp[w] = min(dp[w], dp[w - num] + 1)
        
        # 如果 dp[n] 被更新过，说明找到了凑出 n 的方案，直接返回
        if dp[n] != n + 1:
            return dp[n]
        
        # 理论上不会发生，因为根据数论定理（拉格朗日四平方和），任何正整数都可以表示为最多 4 个平方数之和
        # 但作为安全性处理，加上这个返回值也合理
        return -1
```

- 时间复杂度：`O(n * √n)`
  - 外层循环遍历从 `1` 到 `n` 的所有整数即 `O(n)`
  - 对于每个 `i`，内层循环最多检查 `√n` 个完全平方数，因此总时间复杂度为 `O(√n)`
- 空间复杂度：`O(n)`，需要一个大小为 `n + 1` 的数组 `dp` 来存储每个整数所需的最少完全平方数的数量