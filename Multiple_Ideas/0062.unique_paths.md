# 62.不同路径

题目链接：[62.不同路径](https://leetcode.cn/problems/unique-paths/)

## 题目大意

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 `“Start”`）

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 `“Finish”`）

问总共有多少条不同的路径？

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.361wyvuwbi.webp)

限制：
- 1 <= m, n <= 100

## 解题

### 思路 1: 动态规划

可以使用动态规划来解决这个问题

设定 `dp[i][j]` 为到达网格位置 `(i, j)` 的不同路径数。初始时，`dp[0][0] = 1`，表示起点只有一种路径

对于其他位置 `(i, j)`：
- 机器人只能从 `(i-1, j)` 或 `(i, j-1)` 位置到达 `(i, j)`
- 因此，状态转移方程为：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
  
可以从左上角开始填充 `dp` 数组，最终 `dp[m-1][n-1]` 即为到达右下角的不同路径数

注意：因为 `dp[i][j]` 的状态只依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`，而在进行遍历时的顺序刚好是从上至下、从左到右。所以可以使用长度为 `n` 的一维数组来保存状态，从而优化空间复杂度。在每次迭代中，仅用一个数组 `dp[j]` 来保存当前行的路径数，并不断更新它

```js
var uniquePaths = function(m, n) {
    // 初始化一维数组，长度为 n，所有元素初始化为 1
    const dp = new Array(n).fill(1);
    // 遍历每一行，从第二行开始
    for (let i = 1; i < m; i++) {
        // 从第二列开始更新 dp 数组
        for (let j = 1; j < n; j++) {
            // 更新当前 dp[j] 为 dp[j] + dp[j-1]
            dp[j] += dp[j - 1];
        }
    }

    return dp[n - 1];
};
```
```python
# 写法 1
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1] * n for _ in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        
        return dp[-1][-1]

# 空间优化
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 初始化一维数组，全部设置为 1，因为第一行和第一列的路径数都为 1
        # 由于在起始点 (0, 0) 处，机器人只能向下或向右移动
        # 因此，在网格的第一行和第一列，每个位置的路径数都只有 1 条（只能从左到右或从上到下直线到达），所以将所有值初始化为 1
        dp = [1] * n
        for i in range(1, m):
            for j in range(1, n):
                # 更新当前 dp[j] 为 dp[j] + dp[j-1]
                # dp[j]：表示的是到达 (i, j) 位置时的路径数（该值包含了从上方位置 (i-1, j) 来的路径数）
                # dp[j - 1]：表示从左边 (i, j-1) 到当前位置 (i, j) 的路径数
                dp[j] += dp[j - 1]
        
        # 返回一维数组中最后一个元素，即终点 (m-1,n-1) 的路径数
        return dp[-1]
```

- 时间复杂度：`O(m * n)`，遍历整个 `m x n` 的网格
- 空间复杂度：`O(n)`，只使用一维数组来保存路径数

### 思路 2: 组合数学

从左上角到右下角的过程中，需要移动 `m+n−2` 次，其中有 `m−1` 次向下移动，`n−1` 次向右移动

从这些步中选择哪 `(m - 1)` 步走“下”，其余的就是“右”。因此路径的总数，就等于从 `m+n−2` 次移动中选择 `m−1` 次向下移动的方案数，即组合数：

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2327o1mh7p.webp)

因此我们直接计算出这个组合数即可。计算的方法有很多种：
- 如果使用的语言有组合数计算的 `API`，可以调用 `API` 计算
- 如果没有相应的 `API`，可以使用以下方式进行计算

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9kgiuj561x.webp)

```js
var uniquePaths = function(m, n) {
    let ans = 1;
    for (let x = n, y = 1; y < m; ++x, ++y) {
        ans = Math.floor(ans * x / y);
    }
    return ans;
};
```
```python
# 手动实现
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 为了减少计算量，取 min(m-1, n-1) 作为第二个参数，利用组合数对称性：C(a, b) == C(a, a - b)
        return self.combination(m + n - 2, min(m - 1, n - 1))
    
    def combination(self, a: int, b: int) -> int:
        res = 1
        # 用乘除法迭代地计算组合数，避免中间出现大的阶乘
        # 这种实现不会使用 math.factorial()，效率更高，也不会溢出
        for i in range(1, b + 1):
            res = res * (a - i + 1) // i  
        return res

# 内置函数
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 使用 Python 内置的 math.comb 函数，直接计算组合数
        # 含义是：从 m + n - 2 步中选择 n - 1 步向右走（或者选择 m - 1 步向下，结果一样）
        # 这就是从起点到终点的所有合法路径数量
        return comb(m + n - 2, n - 1)

        # math.comb(a, b) 是 Python 3.8+ 新增函数，计算 “a 选 b” 的组合数
        # 自动避免浮点误差，不需要手动实现阶乘，效率更高
```

- 时间复杂度：`O(m)`，由于交换行列的值并不会对答案产生影响，因此总可以通过交换 `m` 和 `n` 使得 `m ≤ n`，这样时间复杂度降低至 O(`min(m,n)`)
- 空间复杂度：`O(1)`