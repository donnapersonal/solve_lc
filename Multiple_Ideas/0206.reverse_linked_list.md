# 206.反转链表

题目链接：[206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)

## 题目大意

给出单链表的头节点 `head`，请反转链表，并返回反转后的链表

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6bhfmd8wht.webp)

限制：
- The number of nodes in the list is the range [0, 5000].
- -5000 <= Node.val <= 5000

## 解题

### 思路 1: 递归

链表的本质是`「一个节点 + 后续子链表」`，很适合递归处理

**写法 1**

可以从头开始递归直到尾部，然后从尾部往回依次调整指针方向。这个递归方法逻辑清晰，代码简洁，也有助于锻炼思维

**写法 2**

递归天然适合处理链表（线性结构）

可以让递归先走到链表末尾，然后在**返回阶段（回溯）**逐个反转

代码简洁优雅，能考察候选人对指针/调用栈的理解

假设递归已经把 `head.next` 后面的链表反转完成，那么只需把 `head.next.next = head`，让当前节点变成反转后链表的最后一个，再断开 `head.next = None`，就完成了当前节点的反转

> 这就是后序递归反转的本质：利用系统调用栈完成链表反转过程的存储与回溯

```js
// 从前往后翻转指针指向
var reverseList = function(head) {
    return reverse(null, head);
};

var reverse = function(pre, cur) {
    if (!cur) return pre;
    const next = cur.next;
    cur.next = pre;
    return reverse(cur, next);
};

// 从后往前翻转指针指向
var reverseList = function(head) {
    if (head == null || head.next == null) return head;
    let last = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return last;
};
```
```python
# 从前往后翻转指针指向
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 调用一个辅助递归函数 reverse，传入两个参数：
        # pre：前一个节点，初始是 None，因为原链表的头在反转后要变成尾，它的 .next 应该指向 None
        # cur：当前节点，初始为 head，从这里开始反转
        return self.reverse(None, head)
    
    # 定义递归函数 reverse(pre, cur)，它的目标是反转从 cur 开始的链表，pre 是前一个节点，最终会把当前节点的 .next 指向 pre
    def reverse(self, pre, cur):
        # 递归终止条件：如果当前节点是空，说明链表已经遍历完，返回 pre（也就是新链表的头结点）
        if not cur:
            return pre
        
        # 保存当前节点的下一个节点 cur.next，因为稍后要修改 cur.next 指针，为了不丢失链表结构，先保存这个引用
        next = cur.next
        # 关键的一步：反转指针。让当前节点的 .next 指向 pre，这就完成了当前这一步的反转操作
        cur.next = pre
        # 递归下一步：把当前节点 cur 当作新的 pre，刚才保存的 next 作为新的 cur，继续反转下一个节点
        return self.reverse(cur, next)

# 从后往前翻转指针指向
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 递归终止条件：
        # head is None：空链表 head.next is None：只有一个节点，是反转后的新头结点
        # 直接返回 head，开始回溯
        if not head or not head.next:
            return head
        
        # 递归调用：
        # 递归反转 head 后面的子链表
        # 直到走到末尾（终止条件）
        # 返回值 last 是反转后的新头结点，最终会被返回回上一层
        last = self.reverseList(head.next)

        # 反转当前两个节点的指针方向：
        # 原本是 head → head.next
        # 反转后变成 head.next → head
        # 即：让 head.next 的 .next 指向当前的 head
        # 这是整个反转动作的关键！
        head.next.next = head
        # 断开原链：
        # 原本 head → head.next
        # 如果不手动断开，就会形成环
        # 所以这里设置 head.next = None，断掉原来的指向
        head.next = None

        # 始终返回反转后链表的头节点
        # 因为 last 是最深层（即原始尾部）返回的节点
        return last
```

- 时间复杂度: `O(n)`，递归处理链表的每个节点
- 空间复杂度: `O(n)`
  - 递归调用了 `n` 层栈空间，虽然没有显式使用额外的数据结构，递归栈的大小在这里与链表长度成正比
  - 每进行一次递归调用都会在调用栈上添加一个新的层级，直到达到链表的末尾
  - 因此，若链表有 `n` 个节点，最坏情况下调用栈的大小也会达到 `n`，这决定了空间复杂度

### 思路 2: 双指针

思路：迭代双指针法
- 使用 `pre` 和 `cur` 两个指针逐步向后遍历，并原地反转指针方向

先定义一个 `cur` 指针，指向头结点，再定义一个 `pre` 指针，初始化为 `null`

开始反转：首先要把 `cur->next` 节点用 `temp` 指针保存一下，即保存这个节点
> 要保存这个节点是因为接下来要改变 `cur->next` 的指向，将 `cur->next` 指向 `pre` ，此时已反转第一个节点

接着循环走代码逻辑，继续移动 `pre` 和 `cur` 指针

最后，`cur` 指针指向 `null`，循环结束，链表也反转完毕。 此时 `return temp`指针即可，`pre` 指针就指向了新的头结点

> 为什么采用这个迭代写法？
> - 这个写法逻辑非常直观，完全不依赖额外数据结构，也不使用递归栈，是真正的原地就地反转，非常适合对性能和空间要求高的场景

```js
var reverseList = function(head) {
    if(!head || !head.next) return head;
    let pre = null, cur = head, temp = null;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};
```
```python
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 处理特殊情况：
        # 空链表 head is None → 直接返回 None
        # 单节点链表 → 反转后还是自己，直接返回
        # 减少不必要处理，保证后续逻辑安全
        if not head or not head.next:
            return head
        
        # 初始化三个指针变量：
        # pre：表示当前节点反转后应该指向的“前一个节点”，初始为 None
        # cur：当前正在处理的节点，初始为链表头
        # temp：临时变量，用于保存 cur.next，防止反转后丢失原链结构
        pre, cur, temp = None, head, None

        # 主循环：只要当前节点 cur 不为空，就继续反转操作
        while cur:
            # 保存后续节点，防止修改 cur.next 后丢失链表的剩余部分
            temp = cur.next
            # 反转指针方向：
            # 原本：cur → temp（未反转）
            # 现在：cur → pre（指向前一个）
            # 这是实现反转的关键操作
            cur.next = pre
            # 更新 pre 指针，往前推进：当前节点变成下次循环中的 “前一节点”
            pre = cur
            # 继续处理下一节点：当前节点更新为原来的 cur.next
            cur = temp
        
        # 返回反转后的新链表头结点：最终循环结束时，cur 为 None，pre 指向原链表的最后一个节点，即新的头结点
        return pre
```

- 时间复杂度：`O(n)`，每个节点访问一次
- 空间复杂度：`O(1)`，仅用常数个指针，无额外数据结构