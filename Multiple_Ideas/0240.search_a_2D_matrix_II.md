# 240.搜索二维矩阵 II

题目链接：[240.搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

## 题目大意

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target`，该矩阵具有以下特性：
- 每行的元素从左到右升序排列
- 每列的元素从上到下升序排列

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8vna3nm82l.webp)

限制：
- m == matrix.length, n == matrix[i].length
- 1 <= n, m <= 300
- -10^9 <= matrix[i][j] <= 10^9
- All the integers in each row are sorted in ascending order.
- All the integers in each column are sorted in ascending order.
- -10^9 <= target <= 10^9

## 解题

### 思路 1: 双指针

这道题说 `matrix` 从上到下递增，从左到右递增 --> 左上角是最小元素，右下角是最大元素

若想高效在 `matrix` 中搜索一个元素，肯定需从某个角开始，如说从左上角开始，然后每次只能向右或向下移动，不要走回头路

注意，若向左移动，元素在减小；若向下移动，元素在增大，这样的话就可以根据当前位置的元素和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置

思路：从右上角开始搜索

为什么选择右上角？
- 从右上角出发，可以决定“往左”还是“往下”：
  - 当前元素 `> target` → 往左移（列减 `1`）
  - 当前元素 `< target` → 往下移（行加 `1`）
- 每一步都可以排除一整行或一整列，搜索路径单调，效率高

```js
var searchMatrix = function(matrix, target) {
    let m = matrix.length, n = matrix[0].length;
    let i = 0, j = n - 1;
    while (i < m && j >= 0) {
        if (matrix[i][j] == target) {
            return true;
        } else if (matrix[i][j] < target) {
            i++;
        } else {
            j--;
        }
    }
    return false;
};
```
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 获取矩阵的维度：m 行，n 列
        m, n = len(matrix), len(matrix[0])
        # 初始化起点为右上角 (0, n-1)，行号 i = 0，列号 j = n - 1
        i, j = 0, n - 1

        # 在矩阵范围内循环：
        # i < m 表示没超过底部
        # j >= 0 表示没超过左侧
        while i < m and j >= 0:
            # 如果当前位置等于目标值，直接返回 True
            if matrix[i][j] == target:
                return True
            # 当前元素比目标值小 → 说明目标可能在当前行下方，所以往下移一行
            elif matrix[i][j] < target:
                i += 1
            # 当前元素比目标值大 → 说明目标可能在当前列左边，所以往左移一列
            else:
                j -= 1
        
        # 搜索全部可能路径后未找到，返回 False
        return False
```

- 时间复杂度：`O(m + n)`，`m` 是矩阵的行数，`n` 是矩阵的列数
- 空间复杂度：`O(1)`

### 思路 2: 对角线 + 二分搜索

矩阵是有序的，可以考虑使用二分查找来实现
- 迭代对角线元素，假设对角线元素的坐标为 `(row, col)`，把数组元素按对角线分为右上角部分和左下角部分
- 对当前对角线元素右侧第 `row` 行、对角线元素下侧第 `col` 列分别进行二分查找
- 若找到目标，直接返回 `true`
- 若找不到目标，则缩小范围，继续查找
- 直到所有对角线元素都遍历完，依旧没找到，则返回 `false`

由于每一行和列都是升序，使用二分可以加快查找速度

```js
var searchMatrix = function(matrix, target) {
    let rows = matrix.length, cols = matrix[0].length;
    if (rows == 0 || cols == 0) return false;
    let minVal = Math.min(rows, cols);
    const index = diagonalBinarySearch(matrix, minVal - 1, target);
    if (matrix[index][index] == target) return true;
    for (let i = 0; i <= index; i++) {
        const rowSearch = rowBinarySearch(matrix, i, cols - 1, target);
        const colSearch = colBinarySearch(matrix, i, rows - 1, target);
        if (rowSearch || colSearch) return true;
    }
    return false;
};

var diagonalBinarySearch = function(matrix, diagonal, target) {
    let left = 0, right = diagonal;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (matrix[mid][mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
};

var rowBinarySearch = function(matrix, begin, cols, target) {
    let left = begin;
    let right = cols;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (matrix[begin][mid] < target) {
            left = mid + 1;
        } else if (matrix[begin][mid] > target) {
            right = mid - 1;
        } else {
            return true;
        }
    }
    return begin <= left && left <= cols && matrix[begin][left] === target;
};

var colBinarySearch = function(matrix, begin, rows, target) {
    let left = begin + 1;
    let right = rows;
    while (left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if (matrix[mid][begin] < target) {
            left = mid + 1;
        } else if (matrix[mid][begin] > target) {
            right = mid - 1;
        } else {
            return true;
        }
    }
    return begin <= left && left <= rows && matrix[left][begin] === target;
};
```
```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # 获取矩阵的行数和列数
        rows, cols = len(matrix), len(matrix[0])
        # 边界条件判断：空矩阵直接返回 False
        if rows == 0 or cols == 0:
            return False
        
        # 对角线的长度不超过行列最小值
        min_val = min(rows, cols)
        # 在对角线范围内查找一个可能包含 target 的位置，用于限定二分搜索的范围
        index = self.diagonalBinarySearch(matrix, min_val - 1, target)
        # 如果对角线上的某个点刚好等于 target，直接返回
        if matrix[index][index] == target:
            return True
        
        # 遍历从 (0,0) 到 (index,index) 的所有对角点
        # 分别在每一行（向右）和每一列（向下）使用二分搜索
        # 只要有一个找到目标，立即返回 True
        for i in range(index + 1):
            rowSearch = self.rowBinarySearch(matrix, i, cols - 1, target)
            colSearch = self.colBinarySearch(matrix, i, rows - 1, target)
            if rowSearch or colSearch:
                return True
        
        # 全部搜索完毕仍未找到，返回 False
        return False
    
    # 子函数：对角线二分查找
    # 对角线上的二分查找（找最小大于等于 target 的位置）
    # 返回的 index 用于后续 row/col 搜索的终止边界
    def diagonalBinarySearch(self, matrix, diagonal, target):
        left, right = 0, diagonal
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][mid] < target:
                left = mid + 1
            else:
                right = mid
        
        return left
    
    # 子函数：在第 i 行进行二分查找
    # 在第 begin 行中，从 begin 列开始向右进行二分
    # 注意要处理 left 最终落在 target 上的情况
    def rowBinarySearch(self, matrix, begin, cols, target):
        left, right = begin, cols
        while left < right:
            mid = left + (right - left) // 2
            if matrix[begin][mid] < target:
                left = mid + 1
            elif matrix[begin][mid] > target:
                right = mid - 1
            else:
                return True
        
        return begin <= left <= cols and matrix[begin][left] == target
    
    # 子函数：在第 i 列进行二分查找
    # 同样是二分查找，但作用在第 begin 列中，从 begin+1 行开始向下搜索
    def colBinarySearch(self, matrix, begin, rows, target):
        left, right = begin + 1, rows
        while left < right:
            mid = left + (right - left) // 2
            if matrix[mid][begin] < target:
                left = mid + 1
            elif matrix[mid][begin] > target:
                right = mid - 1
            else:
                return True
                
        return begin <= left <= rows and matrix[left][begin] == target
```

- 时间复杂度：`O(min(m, n)*(log m + log n))`, `m` 是矩阵的行数，`n` 是矩阵的列数
- 空间复杂度：`O(1)`
