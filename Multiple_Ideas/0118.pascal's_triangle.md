# 118.杨辉三角

题目链接：[118.杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

## 题目大意

给定一个非负整数 `numRows`，生成「杨辉三角」的前 `numRows` 行

在「杨辉三角」中，每个数是它左上方和右上方的数的和

```js
Example 1:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

Example 2:
Input: numRows = 1
Output: [[1]]
```

限制：
- 1 <= numRows <= 30

## 解题

### 思路 1: 动态规划 

观察结构
- 每一行元素个数为 `i+1`
- 每一行的第一个和最后一个元素是 `1`
- 中间元素满足公式：`row[j] = triangle[i-1][j-1] + triangle[i-1][j]`
- 这种结构化的递推方式更直观、可维护、可扩展

可以使用`动态规划`来逐行构建。对于每一行，除了两端的元素是 `1` 外，其他元素都是上一行中相邻两个元素之和

**写法 1**：
- 初始化一个空列表 `triangle` 用于存储结果
- 遍历从 `0` 到 `numRows - 1` 的每一行 `i`
  - 初始化当前行 `row`，设定长度为 `i + 1`，首尾元素为 `1`
  - 对于非首尾的元素，计算 `row[j] = triangle[i-1][j-1] + triangle[i-1][j]`
  - 将当前行 `row` 添加到 `triangle` 中
- 返回 `triangle`

**写法 2**：

在基本实现中，每行的计算都依赖上一行，所以需要保留整个三角形。而进一步观察发现，只要一个一维数组就可以表示当前行，在计算过程中从右往左更新，就不会覆盖还未使用的值

该方案使用一个一维数组 `dp` 存储每行的值，并利用从右向左的顺序更新，使得中间值不会被提前覆盖，同时不断 `append` 当前结果

```js
var generate = function(numRows) {
    const triangle = [];
    for (let i = 0; i < numRows; i++) {
        const row = new Array(i + 1).fill(1);  // 初始化当前行，长度为 i+1，首尾设为 1
        for (let j = 1; j < i; j++) {
            // 计算当前行的非首尾元素
            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
        }
        triangle.push(row);  // 将当前行加入到结果中
    }
    return triangle;
};
```
```python
# 写法 1
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # 初始化总的三角形列表，用于存放每一行的内容
        triangle = [] 
        # 外层循环，从第 0 行开始生成，总共生成 numRows 行
        for i in range(numRows):
            # 初始化当前行 row 为长度为 i+1 的列表，所有元素先填入 1
            # 因为每行的开头和结尾都是 1，所以先统一填 1，再修改中间部分
            row = [1] * (i + 1) 

            # 遍历当前行的中间部分（从索引 1 到 i-1），不包括首尾
            # 当 i < 2 时，range(1, i) 不会进入循环，因此只处理需要计算的中间部分
            for j in range(1, i):
                # 中间每个元素的值等于上一行的 j-1 与 j 位置的元素之和
                # triangle[i - 1] 表示上一行
                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]
            
            # 将当前行 row 添加到总的三角形列表 triangle 中
            triangle.append(row)
        
        # 最后返回整个杨辉三角的二维数组
        return triangle

# 写法 2：动态规划 + 滚动数组
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        # 初始化一个一维数组 dp，长度为 numRows + 1
        # 所有元素初始为 1，因为杨辉三角每一行的边界值都是 1
        # 它将用于构造每一行的数据，随着 i 的变化逐步更新
        # 长度设为 numRows + 1 是为了避免边界越界
        dp = [1 for _ in range(numRows + 1)]
        # 初始化结果数组 res，用于保存最终的每一行。每次构建完一行后，就把对应的 dp[:i+1] 添加进去
        res = []

        # 主循环，i 表示当前是第几行（从 0 开始，第 0 行为 [1]）
        for i in range(numRows):
            # 从当前行的倒数第二个元素开始往前遍历（也就是从中间往左边走）
            # 这是关键点：从右往左更新 dp[j]，可以避免覆盖 dp[j - 1] 这个还没用的值
            for j in range(i - 1, -1, -1):
                # 只有在当前行不为第 0 行，且列索引不为最左边（j != 0）时才进行更新
                # 两边的元素永远为 1，不需要参与计算
                if i != 0 and j != 0:
                    # 更新当前位置的值为上一次的 dp[j-1] + dp[j]，这正是杨辉三角的计算规则：res[i][j] = res[i-1][j-1] + res[i-1][j]
                    dp[j] = dp[j - 1] + dp[j]
            
            # 将当前行的前 i + 1 项加入结果数组中。dp 是公共数组，但我们只取有效部分（深拷贝），避免后续修改影响已保存的行
            res.append(dp[:i + 1])
        
        # 返回构建好的杨辉三角
        return res
```

- 时间复杂度：`O(n^2)`
  - 需逐行构建杨辉三角，每行最多有 `i+1` 个元素
  - 总共需要计算的元素个数：`1 + 2 + 3 + ... + n = n(n+1)/2`
  - 因此时间复杂度是 `O(n^2)`
- 空间复杂度：`O(1)`，不考虑返回值的空间占用

### 思路 2: 迭代

为了让主逻辑更简洁，这里采用了辅助函数 `generateNextRow()` 来构造当前行：
- 每一行仅依赖前一行
- 每行从 `[1]` 开始，最后也以 `1` 结束，中间的值通过前一行两两相加生成

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:  
        # 初始化结果列表 res，用于保存整个杨辉三角
        res = []
        # 边界情况处理：如果 numRows < 1，直接返回空列表
        if numRows < 1:
            return res
        
        # 第 1 行恒为 [1]，先加入到结果中
        firstRow = [1]
        res.append(firstRow)

        # 从第 2 行开始，遍历直到第 numRows 行
        for i in range(2, numRows + 1):
            # 获取上一行 prevRow，用于生成当前行
            prevRow = res[-1]
            # 调用辅助函数 generateNextRow() 生成当前行，并加入到结果中
            res.append(self.generateNextRow(prevRow))
        
        # 返回最终结果 res
        return res
    
    # 定义辅助函数，输入为上一行 prevRow，输出为当前行 curRow
    def generateNextRow(self, prevRow: List[int]) -> List[int]:
        # 当前行的第一个元素是 1
        curRow = [1]
        # 遍历 prevRow 中的每对相邻元素，相加后加入当前行
        # 如：上一行为 [1, 2, 1]，则 1+2=3，2+1=3，当前行中间为 [3, 3]
        for i in range(len(prevRow) - 1):
            curRow.append(prevRow[i] + prevRow[i + 1])
        
        # 当前行最后一个元素为 1
        curRow.append(1)
        # 返回构造好的当前行
        return curRow
```

- 时间复杂度：`O(n^2)`
- 空间复杂度：如果考虑返回结果 `res` 的空间占用，则为 `(n^2)`；如果不考虑返回结果 `res` 的空间占用，则为 `O(n)`

### 思路 3: 递归

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:    
        # 递归的 base case
        if numRows == 1:
            triangle = []
            # 先把第一层装进去作为 base case
            firstRow = [1]
            triangle.append(firstRow)
            return triangle
        
        # 先递归生成高度为 numRows - 1 的杨辉三角
        triangle = self.generate(numRows - 1)
        # 根据最底层元素生成一行新元素
        bottomRow = triangle[-1]
        newRow = [1]
        for i in range(len(bottomRow) - 1):
            newRow.append(bottomRow[i] + bottomRow[i + 1])

        newRow.append(1)
        # 把新的一行放到杨辉三角底部
        triangle.append(newRow)

        return triangle
```

- 时间复杂度：`O(n^2)`
- 空间复杂度：如果考虑返回结果的空间为 `O(n^2)`；不考虑返回结果时为 `O(n)`