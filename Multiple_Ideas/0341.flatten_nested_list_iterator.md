# 341.扁平化嵌套列表迭代器

题目链接：[341.扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/)

## 题目大意

给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数

实现扁平迭代器类 NestedIterator ：
- NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器
- int next() 返回嵌套列表的下一个整数
- boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 
  
你的代码将会用下述伪代码检测：
```js
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
```

如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确

```js
Example 1:
Input: nestedList = [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Input: nestedList = [1,[4,[6]]]
Output: [1,4,6]
Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].
```

限制:
- 1 <= nestedList.length <= 500
- The values of the integers in the nested list is in the range [-10^6, 10^6].

## 解题

### 思路 1: DFS

核心思路：
- 构造函数中一次性 DFS 扁平化
- 将整数存入 self.vals
- next()、hasNext() 直接访问列表

优点：
- next() O(1)
- hasNext() O(1)

缺点：
- 内存占用 O(n)，n = 整数总数
- 构造函数时间 O(n)

```js
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
    vals = [];
    const dfs = (nestedList) => {
        for (const nest of nestedList) {
            if (nest.isInteger()) {
                vals.push(nest.getInteger());
            } else {
                dfs(nest.getList());
            }
        }
    }
    dfs(nestedList);
};


/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
    return vals.length > 0;
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
    const val = vals[0];
    vals = vals.slice(1);
    return val;
};
```
```python
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        self.vals = deque()
        def dfs(nestedList):
            for nest in nestedList:
                if nest.isInteger():
                    self.vals.append(nest.getInteger())
                else:
                    dfs(nest.getList())
        dfs(nestedList)
    
    def next(self) -> int:
        return self.vals.popleft()  # O(1)，不会越界
    
    def hasNext(self) -> bool:
        return len(self.vals) > 0
```

- 时间复杂度：初始化为 `O(n)`，`next` 和 `hasNext` 为 `O(1)`，其中 `n` 是嵌套的整型列表中的元素个数
- 空间复杂度：`O(n)`，需要一个数组存储嵌套的整型列表中的所有元素

### 思路 2: Stack

优化思路：`懒展开（Lazy Flattening）`

观察：
- 并不是每次迭代都需要展开整个 `nestedList`
- 只需要在调用 `hasNext()` 时确保栈顶是整数

方法：
- 用 `栈` 保存当前还没访问的 `NestedInteger`
- `hasNext()` 遍历栈顶元素：
  - 如果是整数 → 可以直接返回
  - 如果是列表 → 弹出栈顶，将其内部列表元素“展开”到栈顶继续判断

优点：
- 空间优化到 O(d)（d = 最大嵌套深度），比暴力展开 O(n) 更省内存
- 可以处理非常大的嵌套结构

缺点：next() 和 hasNext() 可能需要在每次调用时展开嵌套列表，时间复杂度不是严格 O(1)，但平均情况依然高效

```js
/**
 * @constructor
 * @param {NestedInteger[]} nestedList
 */
var NestedIterator = function(nestedList) {
    this.stack = nestedList;
};


/**
 * @this NestedIterator
 * @returns {boolean}
 */
NestedIterator.prototype.hasNext = function() {
     while (this.stack.length !== 0) {
        if (this.stack[0].isInteger()) {
            return true;
        } else {
            let cur = this.stack[0].getList();
            this.stack.shift();
            this.stack.unshift(...cur);
        }
    }
};

/**
 * @this NestedIterator
 * @returns {integer}
 */
NestedIterator.prototype.next = function() {
    return this.stack.shift().getInteger();
};
```
```python
class NestedIterator:
    def __init__(self, nestedList: [NestedInteger]):
        """
        初始化 NestedIterator，使用栈保存待访问的元素。
        stack[0] 是下一个要访问的 NestedInteger。
        """
        self.stack = nestedList  # 栈（列表），存放未访问的 NestedInteger
    
    def next(self) -> int:
        """
        返回下一个整数。调用 hasNext() 确保栈顶一定是整数。
        """
        return self.stack.pop(0).getInteger()
    
    def hasNext(self) -> bool:
        """
        判断是否还有下一个整数。
        栈顶元素如果是整数直接返回 True，
        如果是列表，则将列表展开到栈顶，继续判断。
        """
        while self.stack:
            # 如果栈顶是整数，直接返回 True
            if self.stack[0].isInteger():
                return True
            # 栈顶是列表，需要展开
            top_list = self.stack[0].getList()  # 获取栈顶的 NestedInteger 内部列表
            self.stack.pop(0)                   # 弹出栈顶列表
            self.stack = top_list + self.stack  # 将列表元素插入到栈顶
        return False
```

- 时间复杂度：初始化和 `next` 为 `O(1)`，`hasNext` 为均摊 `O(1)`
- 空间复杂度：`O(n)`，最坏情况下嵌套的整型列表是一条链，我们需要一个 `O(n)` 大小的栈来存储链上的所有元素