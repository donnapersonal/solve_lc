# 2982.找出出现至少三次的最长特殊子字符串 II

题目链接：[2982.找出出现至少三次的最长特殊子字符串 II](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/)

## 题目大意

给你一个仅由小写英文字母组成的字符串 `s` 

如果一个字符串仅由单一字符组成，那么它被称为特殊字符串。例如，字符串 `"abc"` 不是特殊字符串，而字符串 `"ddd"`、`"zz"` 和 `"f"` 是特殊字符串

返回在 `s` 中出现至少三次的最长特殊子字符串的长度，如果不存在出现至少三次的特殊子字符串，则返回 `-1` 

子字符串 是字符串中的一个连续 非空 字符序列

```js
Example 1:
Input: s = "aaaa"
Output: 2
Explanation: The longest special substring which occurs thrice is "aa": substrings "aaaa", "aaaa", and "aaaa".
It can be shown that the maximum length achievable is 2.

Example 2:
Input: s = "abcdef"
Output: -1
Explanation: There exists no special substring which occurs at least thrice. Hence return -1.

Example 3:
Input: s = "abcaba"
Output: 1
Explanation: The longest special substring which occurs thrice is "a": substrings "abcaba", "abcaba", and "abcaba".
It can be shown that the maximum length achievable is 1.
```

限制：
- 3 <= s.length <= 5 * 10^5
- s consists of only lowercase English letters.

## 解题

暴力思路：
- 暴力尝试所有子串，统计每个子串在字符串中出现的次数
- 枚举所有子串 `s[i:j]`，然后在 `s` 里统计出现次数
- 但字符串长度为 `n` 时，子串数量 `O(n²)`，统计一次出现又是 `O(n)`，总复杂度 `O(n³)`，太大

### 思路 1: 二分答案

我们需要找到最大的 `k`，满足出现次数 `≥ 3`；如果从小到大枚举 `k`，每个 `k` 都要扫描统计，时间大，效率低

考虑：`二分答案`
- 对于某个字符，最小 `k = 1`，最大 `k = n`
- 用二分猜一个 `k（mid）`，然后统计所有段里长度 `≥ mid` 的贡献之和，看是否 `≥ 3`：
  - 如果 `≥ 3`，说明还能更大，尝试增大 `k（low = mid + 1）`
  - 否则减小 `k（high = mid - 1）`
- 好处：
  - 把求最大 `k` 的过程从 `O(n)` 降到 `O(logn)`
  - 总体复杂度 `O(C * N * log N)`，`C` 是字符种类（最多 `26`）

> 本题为什么可以用二分？- 因为随着长度 `k` 的增加，满足出现次数 `≥3` 的条件具有 单调性，无需对原数据排序

> 本题为什么满足单调性？
> - 对于固定的字符段，子串长度越大，可形成的子串数越少
> 所以：
> - 如果长度 `k` 已经出现次数 `≥ 3`，那更小的长度一定更容易出现次数 `≥3`
> -如果长度 `k` 出现次数 `< 3`，那更大的长度也不可能出现更多
> 👉 满足“可行性单调”

> 为什么不需要排序？
> - 我们不是在 `vec` 里用二分找某个元素，而是在“长度空间” `[1, n-2]` 上做二分：
>   - 每次尝试一个长度 `mid`
>   - 统计所有段里长度 `≥mid` 的子串数量
>   - 根据这个统计结果决定往哪一边搜索
> 长度空间本身是天然有序的整数范围 [1, n-2]，所以直接可以二分

```python
class Solution:
    def maximumLength(self, s: str) -> int:
        # n 是字符串的长度，用于后续边界
        n = len(s)
        # 用字典 count 存每种字符对应的连续段长度列表
        # 如："aaabbc" → count['a'] = [3], count['b'] = [2], count['c'] = [1]
        count = {}

        # 外层 i 从左到右扫描 s
        i = 0
        while i < n:
            # 内层 j 从 i 开始向右扩展，找到一段连续相同字符 s[i:j]
            j = i
            while j < n and s[j] == s[i]:
                j += 1
            
            # 如果这个字符第一次出现，初始化一个空列表
            if s[i] not in count:
                count[s[i]] = []
            
            # 把这一段连续相同字符的长度 j-i 存入对应字符的列表
            count[s[i]].append(j - i)

            # 移动 i 到 j，继续处理下一段
            i = j
        
        # 二分查找部分
        # 初始化答案，默认找不到返回 -1
        res = -1
        # 遍历每个字符的所有连续段长度列表 vec
        for vec in count.values():
            # 最短子串长度从 1 开始
            # 为什么 high = n-2？因为我们要至少出现 3 次，若子串长度等于 n 或 n-1，出现次数一定不足 3 次；取 n-2 足够
            low, high = 1, n - 2
            while low <= high:
                # 二分搜索长度 mid
                mid = (low + high) // 2
                # 对于每段长度 x：
                # - 如果这段足够长（x >= mid），它能贡献 x-mid+1 个长度为 mid 的子串
                # - 把所有段的贡献加起来
                count = 0
                for x in vec:
                    if x >= mid:
                        count += x - mid + 1

                # 如果出现次数 count ≥ 3：说明长度 mid 可行，尝试更长的子串，low = mid + 1
                # 更新答案 res
                if count >= 3:
                    res = max(res, mid)
                    low = mid + 1
                else:
                    # 否则说明 mid 太大，缩小范围
                    high = mid - 1
        return res
```

- 时间复杂度：`O(nlogn)`，其中 `n` 表示字符串的长度
  - 构造连续段：`O(n)`
  - 对每个字符二分查找：`O(logn)`，每次统计遍历该字符的段数，所有段加起来总长 `O(n)`
- 空间复杂度：`O(n)`，其中 `n` 表示字符串的长度。需存储每种字符字符串中连续相同字符的长度，存储空间最多为 `O(n)`
  
### 思路 2: Run-Length Decomposition（按字符分段统计） + Top‑K Run Analysis（取前三大段）

观察到子串必须是同一个字符连续重复组成的，所以：
- 我们只需考虑每个字符的连续段（`run`）
- 对于某个字符，想让 `"aaa"` 出现 `3` 次，至少要有一个段长度 `≥ 3`，或者多个段拼起来满足条件

仔细想条件：**如果某个段长度 L ≥ k**，那么这个段本身就能贡献 (`L-k+1`) 次出现（滑动窗口）。所以如果需要出现 `≥3` 次，有三种情况：
- 单个段内部贡献 `≥3` 次：只要 `L-2 ≥ k ⇒ k ≤ L-2`
- 两个段拼贡献 `≥3` 次：一个段贡献 `≥2` 次（`k ≤ L-1`）且另一个段贡献 `≥1` 次
- 三个独立段各贡献 `1` 次：只要有 `3` 个段长度 `≥ k` ⇒ 取最小段长度

优化的核心：
- 我们对每个字符，只需知道它的前三大段长度（最大段、第二大段、第三大段），就能通过上面三种组合算出最大的 `k`
- 不需要统计所有 `l`

思路：
- 扫描 `s`，按字符分组，记录每个字符出现的最长三段连续长度
- 然后枚举这三段长度，套用公式：
  - `vec[0] - 2` （一个段内部滑窗 `≥3`）
  - `min(vec[0]-1, vec[1])`（两个段组合）
  - `vec[2]`（三个段各贡献一次）
- 三者取最大值

```python
class Solution:
    def maximumLength(self, s: str) -> int:
        n = len(s)
        # count 是一个 26×3 的数组，用来记录每个字符的前三大段长度
        # 下标：0 表示最长段，1 表示第二长，2 表示第三长
        count = [[0] * 3 for _ in range(26)]
        
        # 扫描连续段
        i = 0
        # 外层 i 遍历字符串
        while i < n:
            # 内层 j 从 i 开始向右扩展，找到一段相同字符 s[i:j]
            j = i
            while j < n and s[j] == s[i]:
                j += 1
            
            # index：当前字符对应 count 中的下标（a→0，b→1…）
            index = ord(s[i]) - ord('a')
            # length：当前这段连续相同字符的长度
            length = j - i

            # 维护前三大段长度
            # 如果当前段长度大于当前记录的最大段 (count[index][0])
            if length > count[index][0]:
                # 更新：新的最大段长度放在 [0]；原来的最大段和次大段依次向后挪
                count[index][0], count[index][1], count[index][2] = length, count[index][0], count[index][1]
            elif length > count[index][1]:
                # 否则，如果比最大段小，但比次大段大
                # 更新：新的值放在 [1]，原次大段挪到 [2]
                count[index][1], count[index][2] = length, count[index][1]
            elif length > count[index][2]:
                # 否则，如果比前两个都小但比第三大段大
                # 更新：放入第三大段
                count[index][2] = length
            
            # 继续扫描下一段
            i = j
        
        res = 0
        # 对于每个字符的三个段长 vec = [max1, max2, max3]，取以下三种组合的最大值：
        # - vec[0] - 2：最长段内部滑窗出 3 个（L−k+1≥3 => k≤L−2）
        # - min(vec[0] - 1, vec[1])：一个段滑窗出 2 个，另一个段至少 1 个
        # vec[2]：三个段各至少 1 个
        # res：全局最大值
        for vec in count:
            res = max(res, vec[0] - 2, min(vec[0] - 1, vec[1]), vec[2])
        
        # 如果 res 还是 0，说明没找到满足条件的，返回 -1
        return res if res != 0 else -1
```

- 时间复杂度：`O(n)`，其中 `n` 表示字符串的长度，只需遍历一遍字符串即可
- 空间复杂度：`O(∣Σ∣)`，其中 `∣Σ∣` 表示字符集的大小，需维护的每种字符最大的三个长度