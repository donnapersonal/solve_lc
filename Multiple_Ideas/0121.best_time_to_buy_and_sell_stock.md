# 121.买卖股票的最佳时机

题目链接：[121.买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

## 题目大意

给定一个数组 `prices`，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格，只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票

计算出能获取的最大利润，若不能获取任何利润，返回 `0`

```js
Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell

Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0
```

限制：
- 1 <= prices.length <= 10^5
- 0 <= prices[i] <= 10^4

## 解题

### 思路 1：递推 recursion

思路：维护历史最低价 + 实时更新最大利润

观察到我们只关心：`当前价格 - 历史最低价 = 当前可获得最大利润`


设置两个变量 `minprice`（用来记录买入的最小值）、`maxprofit`（用来记录可获取的最大利润）

所以只需要：
- 从左往右扫描 `prices`
- 维护目前为止遇到的最低价格 `minPrice`，若遇到当前价格比 `minprice` 还要小的，更新 `minprice`
- 若遇到当前价格大于或等于 `minprice`，则判断以当前价格卖出的利润，若比 `maxprofit` 大，就更新 `maxprofit`
- 最后输出 `maxprofit`

```js
var maxProfit = function(prices) {
    let minPrice = 10010, maxProfit = 0;
    for (let price of prices) {
        if (price < minPrice) {
            minPrice = price;
        } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
        }
    }
    return maxProfit;
};
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 初始化一个极大值 minPrice，用于记录遍历到当前位置为止的历史最低股价
        # 为什么是 10010？题目约定 prices[i] 最大是 10⁴，写一个稍大的数作为初始值
        minPrice = 10010
        # 初始化最大利润为 0，表示当前尚未获得任何利润
        maxProfit = 0

        # 开始遍历 prices 中的每个股价（每天的价格）
        for price in prices:
            # 如果今天的价格更低，就更新历史最低价
            if price < minPrice:
                minPrice = price
            # 如果当前价格减去历史最低价（即如果我今天卖出，在最低价买入）获得的利润更高，就更新最大利润
            elif price - minPrice > maxProfit:
                maxProfit = price - minPrice
        
        # 最后返回最大利润
        return maxProfit
```

- 时间复杂度：`O(n)`，`n` 是数组 `prices` 的长度，该算法只需遍历 `prices` 一次
- 空间复杂度：`O(1)`，该算法只使用常量级别的额外空间（`minPrice` 和 `maxProfit` 两个变量），没有使用其他额外的辅助数据结构

### 思路 2: 动态规划

使用 `dp[i][0]` 和 `dp[i][1]` 来表示第 `i` 天两种状态下的最大利润：
- `dp[i][0]`：第 `i` 天不持有股票时的最大利润（卖出或从未买入）
- `dp[i][1]`：第 `i` 天持有一股股票时的最大利润（买入或继续持有）


状态转移方程
- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])` ➤ 昨天不持有，或者昨天持有今天卖出
- `dp[i][1] = max(dp[i-1][1], -prices[i])` ➤ 昨天持有，或今天买入（只能买一次，所以买入就是 `-prices[i]`）

```js
var maxProfit = function(prices) {
    let n = prices.length;
    let dp = Array.from({length: n}, () => Array(2).fill(0));
    for (let i = 0; i < n; i++) {
        if (i-1 == -1) {
            dp[i][0] = 0;
            dp[i][1] = -prices[i];
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }

    return dp[n-1][0];
};
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 记录天数 n，用于后续循环和动态规划表构建
        n = len(prices)
        # 构建二维数组 dp[n][2]，其中：
        # dp[i][0] 表示第 i 天不持股的最大利润
        # dp[i][1] 表示第 i 天持股的最大利润
        # 初始值都是 0
        dp = [[0] * 2 for _ in range(n)]

        # 开始遍历每天的价格，准备填 dp[i][0] 和 dp[i][1]
        for i in range(n):
            # 处理第一天的边界情况。因为 dp[-1] 是非法访问，所以我们单独写出 i = 0 的情况
            if i - 1 == -1:
                # 第一天不持股的最大利润一定是 0（什么都不做）
                dp[i][0] = 0
                # 第一天持股，只可能是今天买入，因此利润为 -prices[i]（花钱买入）。=
                dp[i][1] = -prices[i]
                # 第一天已初始化完，跳过后续转移逻辑
                continue
            
            # 第 i 天不持股，有两种可能：
            # 昨天就不持股，今天继续不动；
            # 昨天持股，今天卖出（利润 = 昨天持有的利润 + 今天价格）
            # 取两者最大值
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])

            # 第 i 天持股，有两种可能：
            # 昨天就持股，今天继续持有；
            # 今天刚买入。因为只允许买一次，前面不能买，所以买入成本就是 -prices[i]
            dp[i][1] = max(dp[i-1][1], - prices[i])
        
        # 最终返回 最后一天不持股 的最大利润
        # 因为只能完成一次交易，所以最后状态必须是不持股才算完整交易
        return dp[n-1][0]
```

- 时间复杂度：`O(n)`，代码中只包含一次对 `prices` 数组的遍历，每个状态更新的时间复杂度为 `O(1)`，整体时间复杂度为 `O(n)`
- 空间复杂度：`O(n)`，使用了一个大小为 `n * 2` 的二维数组 `dp` 来存储状态，空间复杂度为 `O(n)`

**空间优化**

观察发现：`dp[i]` 只依赖于 `dp[i-1]`，可以用两个变量来代替整个数组：
- `dp_i_0` 代表前一天不持股的最大利润
- `dp_i_1` 代表前一天持股的最大利润

空间从 `O(n)` 降到 `O(1)`

```js
var maxProfit = function(prices) {
    let n = prices.length;
    let dp_i_0 = 0, dp_i_1 = -Infinity;
    for (let i = 0; i < n; i++) {
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
};
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 记录天数 n，虽然本题后续没直接使用 n，但用于说明和理解
        n = len(prices)
        # dp_i_0 表示第 i 天不持有股票时的最大利润（相当于 dp[i][0]）
        # dp_i_1 表示第 i 天持有股票时的最大利润（相当于 dp[i][1]）
        dp_i_0, dp_i_1 = 0, float("-inf")

        # 遍历每天的股价 prices[i]，从第 0 天到第 n-1 天
        for i in range(n):
            # 状态转移：今天不持股 的最大利润：
            # 昨天就不持股 → 今天继续保持不动（当天不持有股票的最大利润）
            # 或昨天持股，今天卖出 → 收益是 dp_i_1 + prices[i]
            # 取两者较大值更新 dp_i_0
            dp_i_0 = max(dp_i_0, dp_i_1 + prices[i])
            # 状态转移：今天持股 的最大利润：
            # 昨天已经持股 → 今天继续持有
            # 或今天刚买入（因为只允许一次交易，所以只能在最低点买）→ 买入成本是 -prices[i]
            # 取两者较大值更新 dp_i_1
            dp_i_1 = max(dp_i_1, -prices[i])
        
        # 最终返回不持股状态下的最大利润
        # 因为我们最终必须卖出才能“实现利润”
        return dp_i_0
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`