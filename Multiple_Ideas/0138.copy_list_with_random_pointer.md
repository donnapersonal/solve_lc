# 138.随机链表的复制

题目链接：[138.随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

## 题目大意

给一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点

构造这个链表的`深拷贝`。深拷贝应该正好由 `n` 个`全新`节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态，复制链表中的指针都不应指向原链表中的节点

例如，若原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y`，则在复制链表中对应的两个节点 `x` 和 `y`，同样有 `x.random --> y` 

返回复制链表的头节点

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表，每个节点用一个 `[val, random_index]` 表示：
- `val`：一个表示 `Node.val` 的整数
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；若不指向任何节点，则为 `null` 

代码只接受原链表的头节点 `head` 作为传入参数

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.86u0ce6sq8.webp)

限制：
- 0 <= n <= 1000
- -10^4 <= Node.val <= 10^4
- Node.random is null or is pointing to some node in the linked list.

## 解题

题目理解：给定一个复杂链表，每个节点除了常规的 `val` 和 `next` 指针，还有一个 `random` 指针，可能指向链表中的任意节点或 `None`

- 需要深拷贝这条链表，返回新链表的头节点
- 关键点：
  - 不能只是复制节点值，还要复制结构（`next` 和 `random` 的指向关系）
  - 新链表中的每个节点必须是 新创建 的，不能和原链表节点混用

初始思路：`逐节点复制 + 查找 random`
- 遍历原链表，复制每个节点的值
- 再遍历一次，通过对比找出对应的 `random` 节点地址

问题： 查找 `random` 指针对应的新节点时需要再次遍历 → 会导致时间复杂度 `O(n²)`，效率太低

### 思路 1: 哈希辅助法

思路：使用哈希表记录旧节点 → 新节点的映射

核心思想：
- 创建一个映射表 `originToCopy` 来记录：`origin_node → copied_node`
  - 第一次遍历：创建所有新节点，并存入字典
  - 第二次遍历：处理 `next` 和 `random` 的指针指向，利用字典查找目标节点

优点：
- 时间复杂度 `O(n)`
- 结构清晰，易于理解和维护

```js
var copyRandomList = function(head) {
    let originToCopy = new Map();
    for (let p = head; p != null; p = p.next) {
        if (!originToCopy.has(p)) {
            originToCopy.set(p, new Node(p.val));
        }
    }

    for (let p = head; p != null; p = p.next) {
        if (p.next != null) originToCopy.get(p).next = originToCopy.get(p.next);
        if (p.random != null) originToCopy.get(p).random = originToCopy.get(p.random);
    }

    return originToCopy.get(head);
};
```
```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        # 初始化一个哈希表（字典）originToCopy，用于记录 原节点 → 拷贝节点 的映射
        # 这个映射关系是后续设置 next 和 random 指针的关键
        originToCopy = {}
        # 初始化指针 p 指向链表头部，准备进行第一次遍历（创建所有新节点）
        p = head
        # 遍历链表
        while p:
            # 如果当前节点还没有被复制过，就：
            if p not in originToCopy:
                # 创建一个新节点 Node(p.val)
                # 把它存入 originToCopy，关联原节点 → 新节点
                originToCopy[p] = Node(p.val)
            
            # 移动到下一个原节点，继续第一轮遍历
            p = p.next
        
        # 重置指针 p，准备进行第二轮遍历：设置新节点的 next 和 random 指针
        p = head
        while p:
            # 如果当前原节点 p 有 next 指针，就将其拷贝节点的 next 指向对应的新节点
            if p.next:
                # 原链表：p → p.next
                # 新链表：originToCopy[p] → originToCopy[p.next]
                originToCopy[p].next = originToCopy[p.next]
            
            # 如果当前原节点 p 有 random 指针，同理设置拷贝节点的 random
            if p.random: 
                originToCopy[p].random = originToCopy[p.random]
            
            # 继续第二轮遍历的下一步
            p = p.next
        
        # 返回新链表的头节点，即 head 对应的新节点
        # 如果原链表为空，返回 None
        return originToCopy.get(head)
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

### 思路 2: 递归 + 哈希缓存 + DFS

思路：
- 将链表看作一张图（每个节点有两个“边”：`next` 和 `random`）
- 对链表进行 `DFS` 遍历（递归），同时拷贝节点
- 使用 `dict` 记录原节点 → 新节点的映射
- 使用 `set` 避免重复遍历节点（防止陷入循环）

```js
var copyRandomList = function(head) {
    // 记录 DFS 遍历过的节点，防止走回头路
    let visited = new Set();
    // 记录原节点到克隆节点的映射
    let originToCopy = new Map();
    const traverse = function(node) {
        if (node == null) return;
        if (visited.has(node)) return;

        visited.add(node);

        if (!originToCopy.has(node)) originToCopy.set(node, new Node(node.val));
        let cloneNode = originToCopy.get(node);
        if (node.next) {
            traverse(node.next);
            cloneNode.next = originToCopy.get(node.next);
        }

        if (node.random) {
            traverse(node.random)
            cloneNode.random = originToCopy.get(node.random);
        }
    };

    traverse(head);
    return originToCopy.get(head);
};
```
```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        # 使用 set 记录已经访问过的原节点
        # 防止重复递归，尤其在 random 构成回环时避免无限递归
        self.visited = set()
        # dict：哈希表，记录原节点和其拷贝节点之间的映射
        # 键：原节点，值：对应的新节点
        self.originToCopy = {}
        # 开始从原链表头节点进行递归复制
        # traverse() 方法用于执行 DFS 拷贝逻辑
        self.traverse(head)

        # 拷贝工作完成后，返回原链表头节点对应的新节点
        # 如果原链表为空，则返回 None
        return self.originToCopy.get(head)
    
    # 定义辅助函数 traverse：用于从当前 node 出发递归复制整张链表图结构
    def traverse(self, node):
        # 边界条件：空节点直接返回，不做任何处理
        if node == None: 
            return
        
        # 如果当前节点已经处理过（即已经递归访问过），直接返回
        # 这是防止 random 或 next 出现环而陷入死递归的关键步骤
        if node in self.visited:
            return
        
        # 标记当前节点为已访问
        self.visited.add(node)
        # 如果当前节点还未被复制过，就创建一个新节点
        # 复制的是值（node.val），还未设置 next 与 random
        # 并将其记录到哈希映射表中
        if node not in self.originToCopy:
            self.originToCopy[node] = Node(node.val)
        
        # 拿到当前原节点对应的新节点（clone）
        cloneNode = self.originToCopy[node]
        # 对当前节点的 next 指针递归处理
        # 会确保 node.next 对应的新节点已创建并加入映射表
        self.traverse(node.next)
        # 设置新节点的 next 指针；利用哈希表中查到 node.next 的拷贝节点
        cloneNode.next = self.originToCopy.get(node.next)
        # 同理，递归复制 random 指针所指向的节点
        self.traverse(node.random)
        # 设置新节点的 random 指针；利用哈希表设置对应关系
        cloneNode.random = self.originToCopy.get(node.random)
```

- 时间复杂度：`O(n)`，其中 `n` 是链表中节点的总数
  - 每个节点最多遍历两次（一次是为了创建节点映射，一次是赋值 `next` 和 `random` 指针）
  - 通过哈希表保证每个节点只被克隆一次，并能在 `O(1)` 时间内找到克隆节点
- 空间复杂度：`O(n)`
  - 需要额外的哈希表 `originToCopy` 保存 `n` 个节点的映射关系
  - 递归调用栈的深度最多为 `n`

### 思路 3: 原地交叉插入 + 拆分链表

核心思想：
- 第一轮：在原节点之后插入对应的复制节点 → 原1 → 新1 → 原2 → 新2...
- 第二轮：利用相邻结构设置 `random`
- 第三轮：将原链表与复制链表拆开，得到新的复制链表

优势：
- 无需额外空间
- 时间复杂度 `O(n)`
- 思路巧妙，适合展示高级链表技巧

```js
var copyRandomList = function(head) {
    if (!head) return null;
    // 1: 在每个节点后插入一个克隆节点
    let cur = head;
    while (cur) {
        const clone = new Node(cur.val); // 创建克隆节点
        clone.next = cur.next;
        cur.next = clone;
        cur = clone.next; // 移动到下一个原节点
    }

    // 2: 设置克隆节点的 random 指针
    cur = head;
    while (cur) {
        if (cur.random) {
            cur.next.random = cur.random.next; // 克隆节点的 random 指向原 random 的 next
        }
        cur = cur.next.next; // 跳过克隆节点，移动到下一个原节点
    }

    // 3: 拆分链表
    cur = head;
    const cloneHead = head.next; // 克隆链表的头节点
    while (cur) {
        const clone = cur.next;
        cur.next = clone.next; // 恢复原链表的 next
        cur = cur.next;
        if (cur) clone.next = cur.next; // 设置克隆链表的 next
    }

    return cloneHead;
};
```
```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        # 边界处理：空链表直接返回 None
        if not head:
            return None
        
        # 1: 在每个节点后插入一个克隆节点
        cur = head
        # 遍历原链表 cur
        while cur:
            # 创建一个新节点 clone = Node(cur.val)
            # 插入到原节点 cur 之后，即:
            # 原链表: A → B → C
            # 插入后: A → A' → B → B' → C → C'
            clone = Node(cur.val)  
            # 让新节点连接到原节点的下一个节点
            clone.next = cur.next
            # 原节点连接到新节点
            cur.next = clone
            # 跳过新节点，移动到下一个原节点
            cur = clone.next  
        
        # 2: 设置克隆节点的 random 指针
        cur = head
        # 遍历链表，每次跳过一个新节点，处理原节点
        while cur:
            # 如果原节点有 random 指针
            if cur.random:
                # 新节点的 random 指向原节点的 random 的下一节点（即对应的复制节点）
                # 克隆节点的 random 指向原 random 的 next
                cur.next.random = cur.random.next  
            
            # 跳过克隆节点，移动到下一个原节点
            cur = cur.next.next
        
        # 3: 拆分出复制链表
        # 准备拆分链表，同时保存复制链表的头 clone_head 作为返回值
        cur = head
        clone_head = head.next 
        while cur:
            # 对于当前原节点 cur，其复制节点是 cur.next
            clone = cur.next
            # 断开原节点与复制节点之间的连接
            # 原节点重新指向原链表的下一个原节点
            cur.next = clone.next 
            # 继续前进 
            cur = cur.next
            # 如果新的 cur 不为空（还有下一个复制节点）
            if cur:
                # 设置 clone.next = cur.next → 复制节点连接下一个复制节点
                clone.next = cur.next 
        
        # 最后返回新链表头节点
        return clone_head 
```

- 时间复杂度：`O(n)`，三轮遍历，每次 `O(n)`
- 空间复杂度：`O(1)`，无额外结构（除了返回链表本身）