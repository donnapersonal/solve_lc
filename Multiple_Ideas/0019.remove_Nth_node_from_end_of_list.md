# 19.删除链表的倒数第 N 个结点

题目链接：[19.删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

## 题目大意

给一个链表，删除链表的倒数第 `n` 个结点，且返回链表的头结点

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9rjr94btrn.webp)

限制：
- The number of nodes in the list is sz.
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz

## 解题

### 思路 1: 递归

用递归逆序访问链表，每次回溯时计数，如果当前是倒数第 `n + 1` 个节点，就执行删除操作

创建一个虚拟节点 `dummy`，并将它指向链表的头节点 `head`。这样做的好处是可以避免删除头节点时特殊处理的麻烦，因为虚拟头节点确保了即使要删除头节点，也能通过 `dummy` 正常处理

```js
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(-1);
    dummy.next = head;
    let cur = 0;

    const recur = function(node) {
        if (!node) return;
        recur(node.next);
        cur++;
        if (cur == n + 1) node.next = node.next.next;
    };

    recur(dummy);
    return dummy.next;
};
```
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # 创建一个虚拟头节点 dummy，它的 .next 指向原链表的头
        # 为什么要加 dummy？为了方便处理删除的是头节点的情况，避免对 head 特判
        dummy = ListNode(-1)
        dummy.next = head

        # cur 是一个列表：这是一个长度为 1 的列表，用于在递归过程中跟踪当前遍历的节点的位置
        # 由于 Python 中嵌套函数中不能直接修改外部函数中的局部变量，使用列表来间接实现计数器的可变性
        # cur[0] 用于记录递归中已经遍历了多少个节点
        cur = [0]

        # 递归地遍历链表直到链表末尾，然后在回溯的过程中根据计数器的位置删除倒数第 n 个节点
        def recur(node):
            # 当 node 为 None（即到达链表的末尾）时，终止递归
            if not node:
                return
            
            # 递归地遍历链表的下一个节点 node.next，直到到达链表的末尾
            recur(node.next)
            # 当递归回溯时，每返回一个节点，计数器 cur[0] 增加 1
            # 这样，回溯到每个节点时，可通过 cur[0] 知道当前节点是从链表尾部倒数第几个节点
            cur[0] += 1

            # 当回溯到第 n+1 个节点时（即从倒数第 n 个节点的前一个节点），将它的 next 指针跳过目标节点，指向目标节点的下一个节点，从而完成删除操作
            if cur[0] == n + 1:
                node.next = node.next.next
                
        recur(dummy)
        return dummy.next
```

- 时间复杂度：`O(n)`，递归遍历了链表的每个节点一次，其中 `n` 是链表的节点数
- 空间复杂度：`O(n)`，由于使用递归，递归的栈深度等于链表的节点数

### 思路 2: 双指针

双指针的经典应用，若要删除倒数第 `n` 个节点，让 `fast` 移动 `n` 步，然后让 `fast` 和 `slow` 同时移动，直到 `fast` 指向链表末尾，删掉 `slow` 所指向的节点即可

- 定义 `fast` 和 `slow` 指针，初始值为 `dummy`  
- `fast` 首先走 `n + 1` 步，因为只有这样同时移动时 `slow` 才能指向删除节点的上一个节点（方便做删除操作）  
- `fast` 和 `slow` 同时移动，直到 `fast` 指向末尾  
- 删除 `slow` 指向的下一个节点

优点：
- 只遍历一次链表，效率更高
- 使用哑节点处理删除头节点的特殊情况，逻辑更清晰
- 空间复杂度 `O(1)`，不使用额外空间

```js
var removeNthFromEnd = function(head, n) {
    let dummy = new ListNode(-1);
    dummy.next = head;
    let slow = fast = dummy;
    for (let i = 0; i < n + 1; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    slow.next = slow.next.next;
    return dummy.next;
};
```
```python
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # 创建一个哑节点 dummy，指向原始头节点
        # 为什么要用 dummy？为了处理删除的是头节点的特殊情况，无需额外判断
        dummy = ListNode(-1)
        dummy.next = head
        # 初始化两个指针：slow 和 fast，都从 dummy 开始
        # 目的：通过让 fast 提前走 n+1 步，实现两指针间距
        slow, fast = dummy, dummy

        # 让 fast 指针先向前移动 n + 1 步
        # 为什么是 n + 1？为了让 slow 恰好停在要删除节点的“前一个”节点（即倒数第 n + 1 个）
        # 如：链表为 1→2→3→4→5，n = 2，要删除的是 4，就需要 slow 最后指向 3，以便执行 slow.next = slow.next.next
        for i in range(n+1):
            fast = fast.next
        
        # 同步移动 fast 和 slow 指针，每次一步，直到 fast 到达链表末尾（None）
        # 保持两指针之间固定间距 n + 1，所以当 fast 为 None 时，slow 正好在目标节点前一位
        while fast != None:
            slow = slow.next
            fast = fast.next
        
        # 删除目标节点：slow.next 是要删除的节点，跳过它即可
        # 修改链表连接关系：跳过中间的节点
        slow.next = slow.next.next

        # 返回新的链表头
        # 注意：不能直接返回 head，因为有可能头节点被删除，必须从 dummy.next 返回
        return dummy.next
```

- 时间复杂度：`O(n)`，仅遍历一次链表
- 空间复杂度：`O(1)`，没有使用额外的数据结构，指针操作原地完成