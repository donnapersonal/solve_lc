# 398.随机数索引

题目链接：[398.随机数索引](https://leetcode.cn/problems/random-pick-index/)

## 题目大意

给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组

实现 Solution 类：
- Solution(int[] nums) 用数组 nums 初始化对象
- int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等

```js
Example 1:
Input
["Solution", "pick", "pick", "pick"]
[[[1, 2, 3, 3, 3]], [3], [1], [3]]
Output
[null, 4, 0, 2]

Explanation
Solution solution = new Solution([1, 2, 3, 3, 3]);
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
```

限制:
- 1 <= nums.length <= 2 * 10^4
- -2^31 <= nums[i] <= 2^31 - 1
- target is an integer from nums.
- At most 10^4 calls will be made to pick.

## 解题

### 思路 1: 哈希表

如果不考虑数组的大小，我们可以在构造函数中用一个哈希表 `pos` 记录 `nums` 中相同元素的下标

对于 `pick` 操作，可以从 `pos` 中取出 `target` 对应的下标列表，然后随机选择其中一个下标并返回

```js
/**
 * @param {number[]} nums
 */
var Solution = function(nums) {
    this.pos = new Map();
    for (let i = 0; i < nums.length; ++i) {
        if (!this.pos.has(nums[i])) {
            this.pos.set(nums[i], []);
        }
        
        this.pos.get(nums[i]).push(i);
    }
};

/** 
 * @param {number} target
 * @return {number}
 */
Solution.prototype.pick = function(target) {
    const indices = this.pos.get(target);
    return indices[Math.floor(Math.random() * indices.length)];
};
```
```python
class Solution:

    def __init__(self, nums: List[int]):
        self.pos = defaultdict(list)
        for i, num in enumerate(nums):
            self.pos[num].append(i)

    def pick(self, target: int) -> int:
        return choice(self.pos[target])
```

- 时间复杂度：初始化为 `O(n)`，`pick` 为 `O(1)`，其中 `n` 是 `nums` 的长度
- 空间复杂度：`O(n)`，需要 `O(n)` 的空间存储 `n` 个下标

### 思路 2: Math - 蓄水池抽样（Reservoir Sampling）

> 该方法时间复杂度较高，无法通过测试用例，在这里是为了介绍一下使用时间换取空间的方法

如果数组以文件形式存储（读者可假设构造函数传入的是个文件路径），且文件大小远超内存大小，我们是无法通过读文件的方式，将所有下标保存在内存中的，因此需要找到一种空间复杂度更低的算法

`pick` 操作：遍历 `nums`，当第 `i` 次遇到值为 `target` 的元素时，以概率 `1/count` 替换之前选择的索引，实现蓄水池抽样

```python
class Solution:

    def __init__(self, nums: List[int]):
        self.nums = nums  # 保存原数组

    def pick(self, target: int) -> int:
        res = -1     # 用于保存当前选择的索引
        count = 0       # 统计遇到 target 的次数
        for i, num in enumerate(self.nums):
            if num == target:
                count += 1
                # 以 1/count 的概率选择当前索引
                if random.randint(1, count) == 1:
                    res = i
        return res
```

- 时间复杂度：初始化为 `O(1)`，`pick` 为 `O(n)`，其中 `n` 是 `nums` 的长度
- 空间复杂度：`O(1)`，只需要常数的空间保存若干变量