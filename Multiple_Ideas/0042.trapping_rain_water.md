# 42.接雨水

题目链接：[42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

## 题目大意

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨后能接多少雨水

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m49o95qb3.webp)

限制:
- n == height.length
- 1 <= n <= 2 * 10^4
- 0 <= height[i] <= 10^5

## 解题

暴力做法是：对每个柱子 `i`，向左找左侧最高柱子 `left_max`，向右找右侧最高柱子 `right_max`，然后能接水量是：`water[i] = min(left_max, right_max) - height[i]`

整体时间复杂度是 `O(n²)`，因为对每个位置都要向两边扫

### 思路 1：单调栈

从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序，一旦发现添加的柱子高度大于栈头元素，就出现凹槽，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子

遇到相同的元素，更新栈内下标，即将栈里元素（旧下标）弹出，将新元素（新下标）加入栈；因为要求宽度时，若遇到相同高度的柱子，需使用最右边的柱子来计算宽度

核心思想
- 维护一个递减的单调栈（栈中存的是柱子下标）
- 当遇到比栈顶高的柱子时，意味着可能可以形成「凹槽」，计算中间能接多少水
- 每次弹出中间的柱子 `mid_height`，并用左右两侧的柱子计算面积

```js
var trap = function(height) {
    const n = height.length;
    if (n < 0) return 0;
    // 存着下标，计算时用下标对应的柱子高度
    const stack = [];
    stack.push(0);
    let sum = 0;
    for (let i = 1; i < n; i++) {
        while (stack.length && height[i] > height[stack[stack.length - 1]]) {
            let mid = stack[stack.length - 1];
            stack.pop();
            if (stack.length) {
                let h = Math.min(height[stack[stack.length - 1]], height[i]) - height[mid];
                // 注意减一，只求中间宽度
                let w = i - stack[stack.length - 1] - 1; 
                sum += h * w;
            }
        }
        stack.push(i);
    }
    return sum;
};
```
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 获取柱子数量
        n = len(height)
        # 判断是否为非法输入
        if n == 0:
            return 0
        
        # 初始化总雨水量 total
        total = 0
        # 初始化一个单调栈 stack，存放下标
        stack = []
        # 一开始先将第 0 根柱子压入栈
        stack.append(0)

        # 从第 1 根柱子开始遍历
        for i in range(1, n):
            # 当当前柱子比栈顶柱子高时，说明可以形成一个“凹槽”，进入接水逻辑
            while stack and height[i] > height[stack[-1]]:
                # 弹出栈顶，作为中间的矮柱子
                mid_height = stack.pop()

                # 如果栈不为空（表示左侧还有一根柱子）：
                # h 是形成凹槽两边的短边高度 - 中间矮柱的高度
                # w 是左右柱子之间的宽度
                # 面积 h * w 就是当前能接的水量，加到 total 上
                if stack:
                    h = min(height[i], height[stack[-1]]) - height[mid_height]
                    w = w = i - stack[-1] - 1
                    total += h * w
            
            # 将当前柱子的下标压入栈。保持栈为递减单调栈（从栈底到栈顶）
            stack.append(i)
        
        # 返回总的接水量
        return total
```

- 时间复杂度：`O(n)`，每根柱子最多被压入和弹出一次
- 空间复杂度：`O(n)`，使用了一个栈存下标

### 思路 2：双指针

从数组的两端向中间移动，计算每个位置上能够存储的雨水量。通过比较左边和右边的最大高度值，可以确定哪个方向需移动，从而避免重复计算和不必要的遍历
- 不预处理，而是双指针从两端向中间靠拢
- 用两个变量 `l_max` 和 `r_max` 实时维护左右最大高度
- 每一步根据 `l_max` 和 `r_max` 的大小决定移动哪边的指针，计算雨水

利用了贪心思想：当前位置所能接的水只依赖于较小的一边的最大值

```js
var trap = function(height) {
    let left = 0, right = height.length - 1;
    let l_max = 0, r_max = 0;
    let res = 0;
    while (left < right) {
        l_max = Math.max(l_max, height[left]);
        r_max = Math.max(r_max, height[right]);
        if (l_max < r_max) {
            res += l_max - height[left];
            left++;
        } else {
            res += r_max - height[right];
            right--;
        }
    }
    return res;
};
```
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # 定义两个指针：
        # left：从左向右扫描
        # right：从右向左扫描
        left, right = 0, len(height) - 1
        # 初始化当前左边和右边的最大高度：
        # l_max：height[0..left] 区间的最大值
        # r_max：height[right..end] 区间的最大值
        l_max, r_max = 0, 0
        # 总接水量累加器
        res = 0
        # 只要左右指针没有相遇，就继续计算
        while left < right:
            # 更新当前区间内的左右最大值：
            # 左边的最大值是 l_max 与 height[left] 中较大者
            # 右边的最大值是 r_max 与 height[right] 中较大者
            l_max = max(l_max, height[left])
            r_max = max(r_max, height[right])

            # 如果左边最大值更小，说明 height[left] 的接水量只取决于 l_max
            # 因为右边比左边更高，右边可以当作“墙”
            if l_max < r_max:
                # 累加当前位置可接的水：l_max - height[left]（若为负则说明此处不能接水）
                # 然后左指针右移一格
                res += l_max - height[left]
                left += 1
            else:
                # 否则，右边较小，此时 height[right] 能接的水由 r_max 决定
                # 累加之后右指针左移一格
                res += r_max - height[right]
                right -= 1
        
        # 返回总接水量
        return res
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`