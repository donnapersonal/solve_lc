# 226.翻转二叉树

题目链接：[226.翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

## 题目大意

给一棵二叉树的根节点 `root`，翻转这棵二叉树，并返回其根节点

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8z6v80lcg5.webp)

限制：
- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

## 解题

### 思路 1: 迭代

为了避免递归栈限制，可以改写成显式的栈操作（迭代版的 DFS）：
- 使用一个 `stack` 存储待处理节点
- 每次从栈中弹出一个节点，将其左右子树交换
- 再把左右子节点（如果存在）压入栈，等待下一轮处理

本质上和递归是等价的，但更安全，更可控。

```js
var invertTree = function(root) {
    if (root == null) return null;
    let stack = [root]  
    while (stack.length) {
        let cur = stack.pop()  
        let temp = cur.left;
        cur.left = cur.right;
        cur.right = temp;
        if (cur.left) stack.push(cur.left);
        if (cur.right) stack.push(cur.right);
    }
    return root;
};
```
```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 边界处理：如果树为空，直接返回 None
        # 空树反转后还是空树
        if not root:
            return None
        
        # 初始化一个栈 stack，将根节点放入栈中，准备开始迭代处理
        # 栈用于模拟递归，控制节点访问顺序（后进先出，类似 DFS）
        stack = [root]   

        # 主循环：当栈不为空时持续处理
        while stack:
            # 从栈中弹出当前节点 cur
            cur = stack.pop()   
            # 核心逻辑：交换当前节点的左右子树
            # Python 支持同时赋值，简洁高效
            cur.left, cur.right = cur.right, cur.left   
            # 如果当前节点新的左子树存在，就把它压入栈中，等待后续处理     
            if cur.left:
                stack.append(cur.left)

            # 同理，如果右子树存在，也压入栈中
            if cur.right:
                stack.append(cur.right)  

        # 所有节点处理完毕，返回原始根节点（已经被修改为反转结构）
        return root  
```

- 时间复杂度：`O(n)`
- 空间复杂度：
  - `O(n)` (最坏情况下，不平衡树)
  - `O(logn)` (最好情况下，平衡树)

### 思路 2: 层次遍历

思路：
- 使用队列做 层序遍历（一层一层来）
- 每访问一个节点就交换左右子节点，并将其左右子节点入队
- 对于很多真实业务系统，这种“逐层处理”的方式更具可控性和扩展性

```js
var invertTree = function(root) {
    if (root == null) return null;
    let que = [root];
    while (que.length) {
        let size = que.length;
        while (size -- > 0) {
            let cur = que.shift();
            let temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;
            if (cur.left) que.push(cur.left);
            if (cur.right) que.push(cur.right);
        }
    }
    return root;
};
```
```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 处理边界条件：如果是空树，直接返回 None
        # 防止后续代码访问 root.left/right 导致空指针异常
        if not root:
            return None
        
        # 初始化一个双端队列 que，并把 root 放进去
        # 使用 collections.deque 是因为它支持高效的 popleft() 操作
        # 这是 BFS 的典型写法
        que = collections.deque([root]) 

        # 只要队列非空，就一直执行循环
        # 每轮处理一层节点
        while que:
            # 当前队列的长度就是本层的节点数
            # 虽然不是必须要按层处理，但这样便于可读性和层级调试
            size = len(que)

            # 遍历本层的每个节点
            for _ in range(size):
                # 每次从队列左端取出当前节点 cur
                cur = que.popleft()
                # 核心操作：交换当前节点的左右子树
                # Python 语法允许用 tuple unpacking 同时赋值，非常简洁
                cur.left, cur.right = cur.right, cur.left

                # 如果当前节点的左子节点存在（交换后），就加入队列，等待后续处理
                if cur.left:
                    que.append(cur.left)
                
                # 同理，右子节点存在就加入队列
                if cur.right:
                    que.append(cur.right)   

        # 最终返回反转后的整棵树（根节点指针仍然不变）          
        return root
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(W)`，`w` 是最大层的宽度
  - `O(n)` (最坏情况下，完全二叉树最后一层最多节点为 n/2)

### 思路 3: DFS

翻转一棵树，可以类比为：“翻转整棵树 = 翻转左子树 + 翻转右子树 + 交换左右子树”

这正是 后序遍历的模式（先处理子问题，再处理当前节点）

为何递归非常适合？二叉树本质是递归结构：
- 每个节点的子树本身也是一棵二叉树
- 每个节点的操作：交换左右子树，其左右子树也需要翻转

递归的潜在问题：
- 若树非常深（如一条链表），可能导致递归栈溢出
- 但对于大多数树结构，递归清晰、代码简洁，是默认首选

```js
// 写法 1
var invertTree = function(root) {
    if (root == null) return null;
    let left = invertTree(root.left);
    let right = invertTree(root.right);
    root.left = right;
    root.right = left;
    return root;
};

// 写法 2
var invertTree = function(root) {
    traverse(root);
    return root;
};

var traverse = function(root) {
    if (root == null) return;
    let cur = root.left;
    root.left = root.right;
    root.right = cur;

    traverse(root.left);
    traverse(root.right);
};
```
```python
# 写法 1: 后序
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # 递归终止条件：如果当前节点为空，直接返回
        # 空树不需要翻转
        if not root:
            return None
        
        # 递归翻转左子树，结果赋值为 left
        # 此时你把原左子树翻转完毕，准备后续使用
        left = self.invertTree(root.left)
        # 同理，翻转右子树，结果赋值为 right
        right = self.invertTree(root.right)

        # 核心操作：交换左右子树
        # 原左子树经过翻转后变成了 left，要放到右边
        # 原右子树翻转后变成了 right，要放到左边
        root.left = right
        root.right = left

        # 返回当前已翻转的子树（即以 root 为根的整棵树）
        return root

# 写法 2: 前序
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        self.traverse(root)
        return root
    
    def traverse(self, root):
        if not root:
            return None
        
        cur = root.left
        root.left = root.right
        root.right = cur
        self.traverse(root.left)
        self.traverse(root.right)
```

- 时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数目。
- 空间复杂度：`O(h)`，递归函数需要用到栈空间，栈空间取决于递归深度
  - `h` 为树高，最坏 `O(n)`，平均 `O(logn)`