# 236.二叉树的最近公共祖先

题目链接：[236.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 题目大意

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

百度百科中最近公共祖先的定义为：“对于有根树 `T` 的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `x`，满足 `x` 是 `p`、`q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）”

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8l0fiwua5p.webp)

限制：
- The number of nodes in the tree is in the range [2, 10^5].
- -10^9 <= Node.val <= 10^9
- All Node.val are unique.
- p != q
- p and q will exist in the tree.

## 解题

情况 1：若 `p` 和 `q` 都在以 `root` 为根的树中，则 `left` 和 `right` 一定分别是 `p` 和 `q`

情况 2：若 `p` 和 `q` 都不在以 `root` 为根的树中，直接返回 `null`

情况 3：若 `p` 和 `q` 只有一个存在于 `root` 为根的树中，函数返回该节点

### 思路 1: 递归

递归回溯 - 核心思想：从根节点开始递归查找：
- 如果当前节点是 `None`，说明没有找到
- 如果当前节点是 `p` 或 `q`，直接返回当前节点
- 分别在左右子树中递归查找 `p` 和 `q`
- 如果左子树和右子树都找到了目标节点，说明当前节点就是最近公共祖先
- 如果只在一侧找到了，说明最近公共祖先在那一侧，返回那一侧的结果

```js
var lowestCommonAncestor = function(root, p, q) {
    if (root == null) return null;
    if (root == p || root == q) return root;
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) return root;
    if (left == null && right == null) return null;
    return left == null ? right : left;
};
```
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 递归终止条件之一：当前节点为空，说明走到底了，没有找到，返回 None
        if root is None:
            return None
        
        # 递归终止条件之二：当前节点就是 p 或 q，说明找到了目标节点之一，直接返回它
        if root == p or root == q:
            return root

        # 递归地在左子树、右子树中查找 p 和 q。最终会返回：
        # - None：表示该子树中没有找到 p 或 q
        # - 节点对象（p 或 q 或它们的最近公共祖先）
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        # 如果在左右子树都找到了（说明 p 和 q 分别位于两边），那当前节点 root 就是最近公共祖先
        if left and right:
            return root
        
        # 如果左右都没找到，返回 None
        if left is None and right is None:
            return None
        
        # 只有一边返回了节点（另一个是 None），说明 p 和 q 都在同一侧。返回这一侧的结果即可
        return left if right is None else right
```

- 时间复杂度：`O(n)`，每个节点最多被访问一次，其中 `n` 是树中节点的总数
- 空间复杂度：`O(h)`，空间复杂度主要取决于递归栈的深度，递归的最大深度等于树的高度 `h`
  - 在最坏的情况下（例如链状树），空间复杂度为 `O(n)`
  - 对于平衡二叉树，空间复杂度是 `O(log n)`

### 思路 2: 非递归

**写法 1**
构建父指针映射 + 回溯找交点（本题代码）
- 先用 DFS 或 BFS 遍历整棵树，记录每个节点的父节点（parent）
- 然后从 p 向上回溯，记录所有祖先节点
- 再从 q 向上回溯，遇到的第一个在 p 的祖先集合中的节点，就是最近公共祖先

该方法无需递归，逻辑清晰，效率稳定，是面试中推荐的非递归实现方式

**写法 2**
非递归 + 栈模拟后序遍历 + 标记机制，这段代码并非标准解法，而是通过：
- 使用栈手动模拟后序遍历（左→右→根）
- 借助数值标记（max_val）来标记已经访问过的目标节点
- 从叶子向上传播标记，寻找 LCA
- 虽然思路巧妙，但不建议作为主流写法（因不具备通用性）

```js
var lowestCommonAncestor = function(root, p, q) {
    let max = Number.MAX_VALUE;  // 设置一个标记值
    let stack = [];  // 用数组模拟栈
    let pre = null;  // 记录上一个遍历的节点
    while (root !== null || stack.length > 0) {
        // 不断深入左子树，直到找到最左节点
        while (root !== null) {
            stack.push(root);
            root = root.left;
        }
        let cur = stack.pop();  // 弹出栈顶节点
        if (cur.right === null || cur.right === pre) {  // 右子树为空或已访问过
            // 检查当前节点是否是 p 或 q
            if (cur === p || cur === q) {
                // 如果当前节点的左右子节点中有一个是目标节点（已标记 max），返回当前节点
                if ((cur.left !== null && cur.left.val === max) || (cur.right !== null && cur.right.val === max)) {
                    return cur;
                }
                cur.val = max;  // 标记当前节点已找到
            }

            // 如果当前节点的左右子节点都已标记，则当前节点是 LCA
            if (cur.left !== null && cur.left.val === max && cur.right !== null && cur.right.val === max) {
                return cur;
            }

            // 如果当前节点有一个子节点被标记为 max，则继续向上传递标记
            if ((cur.left !== null && cur.left.val === max) || (cur.right !== null && cur.right.val === max)) {
                cur.val = max;
            }

            pre = cur;  // 更新 pre 为当前节点
            cur = null;  // 设置 cur 为 null，避免重复访问
        } else {
            stack.push(cur);  // 如果右子树未访问过，将当前节点重新压栈
            root = cur.right;  // 访问右子树
        }
    }
    return null;  // 未找到 LCA 返回 null
};
```
```python
# 写法 1
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 初始化一个字典 parent：存储每个节点的父节点，根节点的父为 None
        parent = {root: None}
        # 使用 stack 栈进行 DFS 遍历
        stack = [root]

        # 当 parent 字典中还没有记录 p 或 q 的父节点时，持续遍历
        while p not in parent or q not in parent:
            # 弹出当前要处理的节点 node
            node = stack.pop()

            # # 这部分完成的是标准的 DFS 栈式遍历，并构建出从每个子节点回溯到其父节点的映射
            # 如果左子节点存在，则记录其父节点，并压入栈中继续遍历
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            
            # 同理，处理右子节点
            if node.right:
                parent[node.right] = node
                stack.append(node.right)
        
        # 回溯 p 的所有祖先
        # 从 p 开始，向上查找其祖先节点，直到根节点（即 None）
        # 每个祖先节点加入集合 ancestors 中，用于快速查找
        ancestors = set()
        while p:
            ancestors.add(p)
            p = parent[p]
        
        # 回溯 q 的路径，找到交点
        # 从 q 开始向上回溯
        # 第一个出现在 p 的祖先集合中的节点，即为它们的最近公共祖先
        while q not in ancestors:
            q = parent[q]
        
        # 返回找到的最近公共祖先
        return q

# 写法 2
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 用 float('inf')（即 Python 中的无穷大）作为一个特殊标记，来标记当前节点是 p、q，或其祖先
        max_val = float('inf')
        # stack: 用来模拟递归的栈，手动执行后序遍历
        stack = []
        # pre: 记录上一次处理完成的节点，用于判断右子树是否处理过
        pre = None 

        # 循环条件：只要当前节点不空或栈不空，就继续遍历
        while root or stack:
            # 先访问左子树，不断入栈 —— 这是后序遍历的第一步
            while root is not None:
                stack.append(root)
                root = root.left
            
            # 弹出栈顶节点（当前要处理的节点）
            cur = stack.pop() 

            # 进入判断条件：若当前节点没有右子树，或右子树已经访问过（pre标记），说明此时可以处理当前节点
            if cur.right is None or cur.right == pre:
                # 如果当前节点是目标节点之一：
                if cur == p or cur == q:
                    # 如果左子树或右子树已经是 max_val（表示另一个目标已找到），那么当前就是最近公共祖先，立即返回
                    if (cur.left and cur.left.val == max_val) or (cur.right and cur.right.val == max_val):
                        return cur
                    
                    # 否则，将当前节点标记为 max_val，表示找到了一个目标节点
                    cur.val = max_val
                
                # 如果左右子树都已经是标记状态，说明当前节点是 p 和 q 的公共祖先
                if cur.left and cur.left.val == max_val and cur.right and cur.right.val == max_val:
                    return cur
                
                # 如果某一边是标记状态，表示找到了子节点的标记，继续向上传播
                if (cur.left and cur.left.val == max_val) or (cur.right and cur.right.val == max_val):
                    cur.val = max_val
                
                # 当前节点处理完毕，将其设置为 pre，用于下一轮判断
                pre = cur 
                cur = None
            else:
                # 如果右子树存在且尚未访问，则将当前节点重新入栈，转而先访问右子树（模拟后序遍历）
                stack.append(cur)  
                root = cur.right  
        
        # 遍历完成没有找到公共祖先（理论上不会发生，因为 LeetCode 236 保证节点存在）
        return None 
```

- 时间复杂度：`O(n)`，因为每个节点最多被访问两次
- 空间复杂度：`O(h)`，其中 `h` 是树的高度
  - 最坏情况下为 `O(n)`
  - 最优情况下为 `O(logn)`