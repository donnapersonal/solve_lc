# 199.二叉树的右视图

题目链接：[199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

## 题目大意

给定一个二叉树的根节点 `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2ks9b7h5d5.webp)

限制：
- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

## 解题

### 思路 1: DFS + 先右后左遍历

核心思想：
- 使用 深度优先遍历（DFS），优先访问右子树
- 每当我们首次到达某一层，就记录该层的第一个节点（由于先访问右边，该节点就是该层“最右边的节点”）

```js
var rightSideView = function(root) {
    let res = [];
    const traverse = function(root, depth) {
        if (root == null) return;
        if (res.length == depth) res.push(root.val);
        traverse(root.right, depth+1);
        traverse(root.left, depth+1);
    };

    traverse(root, 0);
    return res;
};
```
```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        # 初始化结果列表，用于存储每一层“最右侧看到的节点值”
        self.res = []
        # 调用辅助递归函数 traverse，从根节点开始，深度设为 0
        self.traverse(root, 0)
        # 返回最终结果
        return self.res
    
    # depth 表示当前节点所处的深度（从0开始）
    def traverse(self, root, depth):
        # 递归终止条件：空节点直接返回
        if not root:
            return
        
        # 如果当前深度还没被访问过（即结果列表长度等于当前深度），说明当前节点是该层“最先访问到的节点”
        # 因为优先访问右子树，因此这个“第一个访问到的节点”就是该层最右边的节点
        # 将其加入结果列表中
        if len(self.res) == depth:
            self.res.append(root.val)
        
        # 递归访问右子树 → 再访问左子树
        # 保证右边优先，从而确保“每层最右侧节点”优先被访问并记录
        self.traverse(root.right, depth + 1)
        self.traverse(root.left, depth + 1)
```

- 时间复杂度：`O(n)`，每个节点在遍历时都被访问一次，其中 `n` 是树中节点的数量
- 空间复杂度：`O(h)`
  - 递归调用栈的最大深度取决于二叉树的高度 `h`
  - 最坏情况下（即树是链状结构），递归深度为 `n`，即 `O(n)`
  - 最佳情况下（即树是平衡二叉树），递归深度为 `O(logn)`

### 思路 2: BFS

BFS + 每层记录第一个节点（从右往左入队）
- 从右往左入队，然后在每一层只记录 队首元素即可
- 空间上仍使用队列，但逻辑更直观，执行效率也非常好

```js
var rightSideView = function(root) {
    let res = [];
    if (root == null) return res;
    let que = [];
    que.push(root);
    while (que.length > 0) {
        let levelSize = que.length;
        let last = que[0];
        for (let i = 0; i < levelSize; i++) {
            let cur = que.shift();
            if (cur.right != null) que.push(cur.right);
            if (cur.left != null) que.push(cur.left);
        }

        res.push(last.val);
    }
    return res;
};
```
```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        # 初始化结果数组 res，用于收集右视图节点
        res = []
        # 特判：如果根节点为空，说明整棵树是空的，直接返回空列表
        if not root:
            return res

        # 初始化一个双端队列 que，并将根节点加入，用于层序遍历
        que = collections.deque([root])
        # 当队列不为空时，说明还有节点待处理
        while que:
            # 当前层的节点数量，用于控制内层 for 循环的遍历范围
            levelSize = len(que)
            # 队首节点即当前层最右边的节点（因为我们是从右往左入队），待会要将它的值加入结果
            last = que[0]

            # 遍历当前层的所有节点，一个个出队并处理
            for i in range(levelSize):
                cur = que.popleft()

                # 关键点：先加入右子节点，再加入左子节点，确保下一层时“最右边的”节点先入队，保持处理顺序正确
                if cur.right:
                    que.append(cur.right)

                if cur.left:
                    que.append(cur.left)
            
            # 把当前层最右边节点的值加入结果数组
            res.append(last.val)
        
        # 返回结果数组，即整棵树的右视图
        return res
```

- 时间复杂度：`O(n)`
  - 在 `while` 循环中，`BFS` 逐层遍历每个节点，每个节点仅被访问一次，假设二叉树有 `n` 个节点，遍历这些节点的时间复杂度为 `O(n)`
  - 每次遍历层级时，队列长度即为当前层的节点数。对于每个节点，将其左右子节点（若存在）加入队列，这些操作也是 `O(1)`
- 空间复杂度：`O(n)`
  - 队列在最坏情况下会存储最多一层的节点数，在一棵完全二叉树中，最底层的节点数接近于总节点数的一半，所以队列的空间复杂度是 `O(n)`
  - `res` 最多存储每层的一个节点值，因此对于高度为 `h` 的树，结果列表的空间复杂度为 `O(h)`，而在最坏情况下（如完全不平衡树），树的高度可能接近 `n`