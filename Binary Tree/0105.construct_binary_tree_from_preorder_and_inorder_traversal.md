# 105.从前序与中序遍历序列构造二叉树

题目链接：[105.从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## 题目大意

给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的先序遍历，`inorder` 是同一棵树的中序遍历，请构造二叉树并返回其根节点

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73u99v185b.webp)

限制：
- 1 <= preorder.length <= 3000
- inorder.length == preorder.length
- -3000 <= preorder[i], inorder[i] <= 3000
- preorder and inorder consist of unique values.
- Each value of inorder also appears in preorder.
- preorder is guaranteed to be the preorder traversal of the tree.
- inorder is guaranteed to be the inorder traversal of the tree.

## 解题

我们知道：
- 前序遍历第一个节点就是根节点
- 在中序遍历中，根节点左边是左子树，右边是右子树

### 思路 1: 递归

所以可以递归构建：
- 取 `preorder[0]` 作为根节点
- 在 `inorder` 中找到它的位置，切分为左子树和右子树
- 对左右子树递归重复此过程
- 问题：每次都要在中序遍历中查找根节点的位置，时间复杂度为 `O(n²)`，在大输入下会超时


最优解思路：`用哈希表加速索引 + 避免切片`，为了优化：
- 用一个 `hashmap` 存储中序遍历每个值的索引，加速查找位置为 `O(1)`
- 使用“索引”而不是数组切片，避免创建新数组

```js
var buildTree = function(preorder, inorder) {
    let valToIndex = new Map();
    for (let i = 0; i < inorder.length; i++) {
        valToIndex.set(inorder[i], i);
    }
    const build = function(preorder, preStart, preEnd, inorder, inStart, inEnd) {
        if (preStart > preEnd || inStart > inEnd) return null;
        let rootVal = preorder[preStart];
        let index = valToIndex.get(rootVal);
        let leftSize = index - inStart;
        let root = new TreeNode(rootVal);
        root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1);
        root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd);
        return root;
    };
    return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
};
```
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # 构建一个哈希表 valToIndex，用于记录中序遍历中每个节点值对应的索引位置，加速查找
        self.valToIndex = {}
        for i in range(len(inorder)):
            self.valToIndex[inorder[i]] = i
        
        # 开始递归构建，传入前序和中序遍历的起止索引
        return self.build(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1)
    
    # 递归函数：构建子树的根节点，参数是当前处理的区间范围
    def build(self, preorder, preStart, preEnd, inorder, inStart, inEnd):
        # 递归终止条件：当前区间已经无效，说明没有子树可建，返回空节点
        if preStart > preEnd or inStart > inEnd:
            return None
        
        # 前序遍历的第一个元素就是当前子树的根节点值
        rootVal = preorder[preStart]
        # 在中序遍历中查找根节点的位置（用哈希表加速）
        index = self.valToIndex[rootVal]
        # 左子树的大小 = 中序遍历中左子树部分的长度
        leftSize = index - inStart
        # 创建当前子树的根节点
        root = TreeNode(rootVal)
        # 递归构建左子树：
        # - 前序范围：[根节点之后的第一个元素 → 左子树最后一个元素]
        # - 中序范围：[inStart → 根节点前一位]
        root.left = self.build(preorder, preStart+1, preStart+leftSize, inorder, inStart, index - 1)
        # 递归构建右子树：
        # - 前序范围：[左子树之后的第一个元素 → preEnd]
        # - 中序范围：[根节点后一位 → inEnd]
        root.right = self.build(preorder, preStart+leftSize+1, preEnd, inorder, index+1, preEnd)
        # 返回当前构建好的根节点
        return root
```

- 时间复杂度：`O(n)`，因为每个节点只会被访问一次，且哈希查找操作是 `O(1)` 
- 空间复杂度：`O(n)`，包括哈希表存储和递归栈空间
  - `O(n)`：用于存储哈希表 `valToIndex`
  - `O(h)`：递归栈空间，最坏情况 `O(n)`，平均为 `O(log n)`

### 思路 2: 迭代

为何考虑迭代？
- 面试中展示不同解法能力
- 避免递归栈溢出问题
- 更贴近“模拟构造”过程，有利于拓展思想

思路：`用栈模拟构造过程（迭代）`

核心观察
- 前序遍历是“先根，后左，再右”
- 中序遍历是“先左，再根，后右”

可以用一个`栈`保存构造路径，维护当前节点
- 不断插入前序节点作为当前栈顶的左孩子
- 一旦发现当前栈顶等于中序中的值，说明左子树走完了，要回退栈，接着构建右子树

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        # 处理边界情况：空输入直接返回 None
        if not preorder:
            return None
        
        # 前序遍历第一个值就是根节点，我们先构造它
        root = TreeNode(preorder[0])
        # 初始化一个栈，存放当前正在处理的路径节点，用于构造子树
        stack = [root]
        # 记录当前中序遍历的位置，表示下一个“已构造的节点”在中序中的索引
        inorderIndex = 0
        # 从前序数组第二个值开始遍历，依次处理每个节点
        for i in range(1, len(preorder)):
            # 取当前要构造的节点值
            preorderVal = preorder[i]
            # 取栈顶元素，表示当前正在处理的父节点
            node = stack[-1]
            # 如果当前节点值 ≠ 中序中下一个节点值，说明还在处理左子树，继续向左
            if node.val != inorder[inorderIndex]:
                # 构造左孩子，并加入栈，继续处理它的左子树
                node.left = TreeNode(preorderVal)
                stack.append(node.left)
            else:
                # 否则，说明左子树已构造完毕，需要回退栈构建右子树
                # 回退栈中所有已匹配的节点（即这些节点的左子树都构造完了），直到找到第一个右孩子应连接的位置
                while stack and stack[-1].val == inorder[inorderIndex]:
                    node = stack.pop()
                    inorderIndex += 1
                
                # 构造右孩子，并将其加入栈，准备继续处理右子树或其左孩子
                node.right = TreeNode(preorderVal)
                stack.append(node.right)
        
        # 循环完成，返回最初构造的根节点
        return root
```

- 时间复杂度：`O(n)`，每个节点最多被访问两次（一次入栈，一次出栈）
- 空间复杂度：`O(n)`，最坏情况下栈存储 `n` 个节点

