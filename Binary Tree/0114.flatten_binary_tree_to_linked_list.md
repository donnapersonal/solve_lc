# 114.二叉树展开为链表

题目链接：[114.二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

## 题目大意

给你二叉树的根结点 `root`，请将它展开为一个单链表：
- 展开后的单链表应该同样使用 `TreeNode`，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 
- 展开后的单链表应该与二叉树 先序遍历 顺序相同

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2yyp1wyczc.webp)

限制：
- The number of nodes in the tree is in the range [0, 2000].
- -100 <= Node.val <= 100

## 解题

### 思路 1: 递归 + 分治处理左右子树（原地修改结构）

考虑从底向上处理，把每棵子树变成“拉平的链表”，然后接到当前节点的右边。做法如下：
- 递归地把左子树 `flatten`
- 再递归地把右子树 `flatten`
- 然后把左子树接到当前节点的右边，原来的右子树接到左子树 `flatten` 后的末尾
- 最后把 `left` 置为 `None`

这样保证：
- 整棵树会按前序遍历顺序拉平成链表
- 修改过程是“原地”进行的，不需要额外空间
- 时间复杂度为 `O(n)`

```js
var flatten = function(root) {
    // 定义：将以 root 为根的树拉平为链表
    const flattenTree = function(root) {
        if (root == null) return;
        // 先递归拉平左右子树
        flattenTree(root.left);
        flattenTree(root.right);

        // 左右子树已经被拉平成一条链表
        let left = root.left, right = root.right;

        // 将左子树作为右子树
        root.left = null;
        root.right = left;

        // 将原先的右子树接到当前右子树的末端
        let p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    };

    flattenTree(root);
};
```
```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        # 递归终止条件：如果当前节点为空，直接返回
        # 空节点没有展开的必要
        if root is None:
            return
        
        # 先递归展开左子树
        # 再递归展开右子树
        # 注意这里相当于后序遍历（先处理子问题，再处理当前节点）
        self.flatten(root.left)
        self.flatten(root.right)

        # 保存当前节点的左、右子树引用
        # 因为等会要改变 root.left 和 root.right 的指向，所以提前保存以免丢失
        left = root.left
        right = root.right

        # 将左子树移到右子树位置；同时将左指针清空
        # 这一步是核心操作：把左子树 flatten 后的链表拼接到右边
        root.left = None
        root.right = left

        # 找到原左子树 flatten 后链表的最末尾节点（即当前右子链表的末尾）
        # 为的是将原先的右子树接到这个末尾后面
        p = root
        while p.right is not None:
            p = p.right
        
        # 把保存下来的原右子树，拼接到刚才 flatten 的左子树链表的最后；从而完成 flatten 当前子树的完整拼接
        p.right = right
```

- 时间复杂度：`O(n)`，因为每个节点被访问一次
  - 递归部分：对于每个节点，递归调用会访问它的左右子树各一次，因此每个节点被访问一次。由于树有 `n` 个节点，所以递归遍历的时间复杂度是 `O(n)`
  - 找到右子树末端的操作：
    - 在将左子树移到右边之后，用 `p = root` 找到当前右子树的末端并接上原来的右子树
    - 虽然这个操作在代码中使用了一个 while 循环来寻找末端，但在每个节点上，这个操作总共不会重复访问所有节点多次。实际上，由于每个节点在最终的展开结构中只有一个右节点连接，因此所有这些“找到末端”的操作加在一起仍然是 `O(n)` 级别
- 空间复杂度：`O(h)`，其中 `h` 是树的高度，因为递归调用会占用栈空间，栈的深度取决于树的高度
  - 对于平衡树，空间复杂度为 `O(logn)`
  - 而对于退化为链表的树，空间复杂度为 `O(n)`

### 思路 2: 迭代前序遍历 + 指针重接（模拟栈）

思路：
- 每次从栈中弹出当前节点，先压右子树、再压左子树（保证前序顺序）
- 将当前节点的 `right` 指向栈顶（即下一个遍历到的节点）
- 将当前节点的 `left` 指针置空
- 重复直到栈为空

这样能保证：
- 所有指针都在原地被重接
- 顺序符合前序遍历
- 无需递归，避免栈溢出

```python
class Solution:
    # 原地修改树结构，不返回任何值
    def flatten(self, root: TreeNode) -> None:
        # 边界处理：如果树为空，直接返回，无需处理；防止后续操作报错
        if not root:
            return

        # 初始化栈，并将根节点压入；栈用来模拟递归中的函数调用过程，实现前序遍历
        stack = [root]
        # 循环遍历：只要栈不为空，就一直进行
        while stack:
            # 每次从栈顶弹出一个节点进行处理（模拟前序：先处理当前节点）
            node = stack.pop()

            # 先压右子树：因为栈是“先进后出”，右子树要后处理，所以要先入栈；确保左子树先展开
            if node.right:
                stack.append(node.right)
            
            # 再压左子树：保证下一个弹出的就是当前节点的左子节点，符合前序遍历
            if node.left:
                stack.append(node.left)

            # 将当前节点的 right 指针指向栈顶元素（即下一个访问的节点）
            # 这是重构链表的关键一步
            if stack:
                node.right = stack[-1]
            
            # 将 left 指针清空，确保符合“单链表”的结构要求；所有节点只保留 right 指针
            node.left = None
```

- 时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数，因为每个节点只访问一次，用于调整指针
- 空间复杂度：`O(h)`，栈最大深度为树的高度，最坏 `O(n)`，平均 `O(log n)`