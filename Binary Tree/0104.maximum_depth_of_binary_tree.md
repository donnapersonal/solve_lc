# 104.二叉树的最大深度

题目链接：[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## 题目大意

给定一个二叉树 `root`，返回其最大深度

二叉树的`最大深度`是指从根节点到最远叶子节点的最长路径上的节点数

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1lc4si9lu6.webp)

限制：
- The number of nodes in the tree is in the range [0, 10^4].
- -100 <= Node.val <= 100

## 解题

### 思路 1: 层次遍历

使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合
- 可以用 `BFS（广度优先搜索）` 遍历整棵树，并在遍历的过程中统计层数，也就是最大深度
- 优势：
  - 不用递归，避免栈溢出
  - 自然按照“层”的方式处理，正好等于深度

```js
var maxDepth = function(root) {
    if (root == null) return 0;
    let que = [root];
    let depth = 0;
    while (que.length) {
        let size = que.length;
        while (size-- > 0) {
            let cur = que.shift();
            if (cur.left) que.push(cur.left);
            if (cur.right) que.push(cur.right);
        }
        depth++;
    }
    return depth;
};
```
```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        que = collections.deque([root])
        depth = 0
        while que:
            size = len(que)
            for _ in range(size):
                cur = que.popleft()
                if cur.left:
                    que.append(cur.left)

                if cur.right:
                    que.append(cur.right)
            
            depth += 1
        
        return depth
```

- 时间复杂度：`O(n)`，每个节点入队出队一次，访问一次，总共 `n` 个节点
- 空间复杂度：`O(n)`，最坏情况下，队列中会同时存在最多一层的所有节点（例如最后一层可能是 `n/2` 个节点）

### 思路 2: 递归

**写法 1:**

使用`“显式的回溯 + 深度记录”`，当前实现采用了另一种写法 —— “前序遍历 + 回溯法记录当前路径深度”
- 使用类变量 `self.depth` 表示当前路径的深度
- 使用 `self.res` 记录在遍历过程中遇到的最大深度
- 每次递归到一个节点，`depth +1`；递归返回后再 `depth -1`，实现回溯

这种方式是 `“自顶向下”` 地维护路径深度，并在遍历过程中更新最大值

**写法 2**

二叉树的天然结构是递归的：
- 每个节点的最大深度 = 左子树最大深度和右子树最大深度的较大者 + 1
- 所以我们自然地想到使用后序遍历，`自底向上`地求解

思路转化为代码逻辑
- 如果节点是空的（即 `None`），说明深度为 `0`；否则，递归地计算左右子树的最大深度
- 当前节点的最大深度 = `max(左子树深度, 右子树深度) + 1`

这也是一个标准的`“分解问题 + 合并结果”`的递归模式

```js
// 写法 1：回溯算法思路
var maxDepth = function(root) {
    let depth = 0;
    let res = 0;

    const traverse = function(root) {
        if (root == null) return;
        // 前序遍历位置
        depth++;
        // 遍历的过程中记录最大深度
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // 后序遍历位置
        depth--;
    };

    traverse(root);
    return res;
};

// 写法 2：动态规划思路
var maxDepth = function(root) {
    if (root == null) return 0;
    let leftMax = maxDepth(root.left);
    let rightMax = maxDepth(root.right);
    return Math.max(leftMax, rightMax) + 1;
};
```
```python
# 写法 1：回溯算法思路
class Solution:
    def __init__(self):
        self.depth = 0
        self.res = 0

    def maxDepth(self, root: Optional[TreeNode]) -> int:
        self.traverse(root)
        return self.res
    
    def traverse(self, root):
        # 若当前节点为空（叶子节点的孩子），直接返回
        if root is None:
            return

        # 前序遍历位置
        # 进入当前节点前，路径深度加 1
        # 这里是典型的“前序位置”：即进入节点前执行的操作
        self.depth += 1

        # 遍历的过程中记录最大深度
        self.res = max(self.res, self.depth)
        self.traverse(root.left)
        self.traverse(root.right)
        
        # 后序遍历位置
        # 离开当前节点后，路径深度减 1
        # 这就是经典的“回溯位置”：恢复上一层状态
        self.depth -= 1

# 写法 2：动态规划思路
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:  
        # 递归终止条件：如果当前节点是空的，返回深度 0，表示已经走到了叶子节点的下一层
        if root is None:
            return 0
        
        # 递归调用左子树，计算左子树的最大深度，并存储在 leftMax 中
        leftMax = self.maxDepth(root.left)
        # 递归调用右子树，计算右子树的最大深度，并存储在 rightMax 中
        rightMax = self.maxDepth(root.right)
        # 当前节点的最大深度 = 左/右子树最大深度中的较大者 + 1（加上当前这一层）
        # 这是典型的“后序遍历位置”，即先算左右子树，再返回结果
        return max(leftMax, rightMax) + 1
```

- 时间复杂度：`O(n)`，每个节点访问一次
- 空间复杂度：`O(h)`，最坏情况(链状树) `O(n)`，平均情况(平衡树) `O(logn)`