# 437.路径总和 III

题目链接：[437.路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

## 题目大意

给定一个二叉树的根节点 `root`，和一个整数 `targetSum`，求该二叉树里节点值之和等于 `targetSum` 的路径的数目

路径不需要从根节点开始，也不需要在叶子节点结束，但路径方向必须是向下的（只能从父节点到子节点）

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9kgixrlzmq.webp)

限制：
- The number of nodes in the tree is in the range [0, 1000].
- -10^9 <= Node.val <= 10^9
- -1000 <= targetSum <= 1000

## 解题

暴力 `DFS` 枚举每个起点的路径
- 遍历树上每个节点，把每个节点当成起点
- 从该节点出发，用 `DFS` 向下探索所有路径
- 统计路径和等于 `targetSum` 的数量
- 时间复杂度：对每个节点都执行一次 `DFS`，整体复杂度为 `O(n^2)`（最坏情况是链状树）

可以使用前缀和来优化这个问题
> 灵感来源于「连续子数组和等于 K」那道经典题

可以定义节点的前缀和来减少重复计算
- 节点的前缀和：从根节点到当前节点路径上所有节点的和，记录为 `prefixSum`
- 有了节点的前缀和，就可通过前缀和来计算两节点之间的路径和，即：`则两节点之间的路径和 = 两节点之间的前缀和之差`，即对于当前节点的路径和，检查在这条路径之前是否存在一段路径，使得它的路径和恰好为 `prefixSum - targetSum`

> 当前路径的前缀和为 `curSum`，要找是否有某段路径的和为 `targetSum`，等价于找：`prefixSum[j] - prefixSum[i] = targetSum ⟺ prefixSum[i] = prefixSum[j] - targetSum`
> 
> 换句话说，如果当前前缀和是 `curSum`，查找是否存在 `prefixSums[curSum - targetSum]`

具体思路 - `前缀和 + DFS + 回溯`：
- 使用`DFS`遍历每个节点
- 使用哈希表记录每个前缀和出现的次数：以「当前节点的前缀和」为键，以「该前缀和的节点数量」为值
- 对于当前节点，计算从当前节点往回是否存在一段路径的和等于 `targetSum`，如果存在，增加路径计数
- 递归处理左右子树
- 处理完当前节点后，将当前节点的前缀和从哈希表中移除，避免影响其他路径的计算


```js
var pathSum = function(root, targetSum) {
    const prefixSums = {0: 1};  // 初始化前缀和为 0 的情况
    const dfs = function(node, curSum) {
        if (!node) return 0;
        curSum += node.val;
        let count = prefixSums[curSum - targetSum] || 0;
        // 更新当前前缀和
        prefixSums[curSum] = (prefixSums[curSum] || 0) + 1;

        // 递归遍历左右子树
        count += dfs(node.left, curSum);
        count += dfs(node.right, curSum);
        
        // 递归完成后，减少当前前缀和的次数，避免影响其他路径
        prefixSums[curSum]--;
        
        return count;
    };
    return dfs(root, 0);
};
```
```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        # 哈希表 prefixSums 记录「前缀和 → 出现次数」
        # 初始设为 {0: 1} 表示：如果路径本身就等于 targetSum，也可以被统计
        prefixSums = {0: 1} 

        # 定义一个递归函数 dfs，接收当前节点和从根节点累加到当前的前缀和 curSum
        def dfs(node, curSum):
            # 如果节点为空，返回 0（路径终止）
            if not node:
                return 0
            
            # 当前路径的前缀和更新：将当前节点的值加入累计值
            curSum += node.val
            # 关键操作：查找是否存在前缀和 curSum - targetSum
            # 如果存在，说明从该前缀到当前节点构成一条合法路径，统计其出现次数
            count = prefixSums.get(curSum - targetSum, 0)
            # 把当前前缀和加入哈希表，表示从根节点到当前节点的路径已存在一次
            prefixSums[curSum] = prefixSums.get(curSum, 0) + 1

            # 递归遍历左右子树，将当前路径继续向下延伸
            # 将左右子树中符合条件的路径数加入当前计数
            count += dfs(node.left, curSum)
            count += dfs(node.right, curSum)

            # 回溯时将当前前缀和的计数减去 1
            # 避免该路径前缀影响到其他并行路径（核心的回溯操作）
            prefixSums[curSum] -= 1

            # 返回以当前节点为起点的合法路径数
            return count
        
        # 从根节点开始 DFS，初始前缀和为 0
        return dfs(root, 0)
```

- 时间复杂度：`O(n)`，`n` 是树中节点的数量。每个节点只被访问一次，且每个节点对哈希表的操作（更新和查询）是常数时间
- 空间复杂度：哈希表 `prefixSums` 在最坏情况下可能存储 `n` 个不同的前缀和，因此空间复杂度为 `O(n)`。此外，递归的深度是树的高度，最坏情况下为 `O(n)`，因此总的空间复杂度也是 `O(n)`