# 108.将有序数组转换为二叉搜索树

题目链接：[108.将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

## 题目大意

给一个整数数组 `nums`，其中元素已经按`升序`排列，请将其转换为一棵平衡二叉搜索树

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1e8y2cxsup.webp)

限制：
- 1 <= nums.length <= 10^4
- -10^4 <= nums[i] <= 10^4
- nums is sorted in a strictly increasing order.

## 解题

二叉搜索树（BST）特点：
- 左子树的所有节点都小于根节点
- 右子树的所有节点都大于根节点
  
平衡二叉树（height-balanced BST）定义：一个二叉树称为平衡的，当它的任意节点的左右子树的高度差不超过 `1`

初始思路：最简单的想法是从左到右依次把元素插入 BST 中

```python
root = TreeNode(nums[0])
for i in range(1, len(nums)):
    insert(root, nums[i])
```
问题：
- 会构造出严重偏斜的 BST，接近链表结构，失去了“平衡性”
- 高度可能为 `O(n)`，最差性能

> 二叉树的构建问题遵循固定的套路，构造整棵树可以分解成：先构造根节点，再构建左右子树
> 
> 一个有序数组对于 `BST` 来说就是`中序遍历`的结果，根节点在数组中心，数组左侧是左子树元素，右侧是右子树元素

### 思路 1: 分治 + 递归构造中间节点为根

核心思路：中间值为根节点，递归构建左右子树
- 递增数组中间的元素最适合作为根节点（左边比它小，右边比它大）
- 递归处理左半部分构成左子树，右半部分构成右子树

```js
var sortedArrayToBST = function(nums) {
    return build(nums, 0, nums.length - 1);
};

var build = function(nums, left, right) {
    if (left > right) return null;
    let mid = left + Math.floor((right - left) / 2);
    let root = new TreeNode(nums[mid]);
    root.left = build(nums, left, mid - 1);
    root.right = build(nums, mid + 1, right);
    return root;
};
```
```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        # 调用 self.build(nums, 0, len(nums) - 1) 表示对整个数组范围 [0, n-1] 进行递归建树
        return self.build(nums, 0, len(nums) - 1)
    
    # 递归地在 [left, right] 区间上构建 BST
    def build(self, nums, left, right):
        # 终止条件：当左边界超过右边界时（空区间），返回 None 表示叶子节点为空
        if left > right:
            return None
        
        # 选择当前区间的中间元素作为根节点（防止整数溢出用此写法）
        # 这样保证 BST 是平衡的（尽量左右对称）
        mid = left + (right - left) // 2
        # 创建当前子树的根节点，值为中间元素 nums[mid]
        root = TreeNode(nums[mid])
        # 递归构建左子树，对应区间 [left, mid - 1]
        root.left = self.build(nums, left, mid - 1)
        # 递归构建右子树，对应区间 [mid + 1, right]
        root.right = self.build(nums, mid + 1, right)
        
        # 返回当前构建好的 root 节点，供上一层连接左右子树
        return root
```

- 时间复杂度：`O(n)`，其中 `n` 是数组的长度，遍历了数组中的每个元素一次
- 空间复杂度：`O(logn)`，因为递归调用栈的深度是平衡二叉树的高度，每次平分数组

### 思路 2: 迭代

为了解决递归调用栈过深的问题，可以用迭代方式来模拟递归过程，借助 `BFS（队列）`方式进行分层构建

核心思想：
- 使用 `3` 个队列分别存储：当前节点指针、左边界、右边界
- 每次从队列中取出当前节点和它所代表的区间 `[left, right]`，取中间值作为该节点的值
- 然后将左右子区间继续压入队列，构建其左右子树
- 这样就能像递归一样完成树的构造，但使用的是迭代（BFS）方式，更适合面试中“要求不用递归”的 `follow-up`

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:

        # 边界处理：如果输入为空数组，直接返回 None，代表空树
        if len(nums) == 0:
            return None
        
        # 初始化根节点 root，暂时赋值为 0，之后会在构造过程中修改成真正的值
        root = TreeNode(0) 
        # 初始化三个队列：
        # - nodeQue：存放当前正在处理的节点
        # - leftQue 和 rightQue：分别存放对应节点的子数组的左边界和右边界
        nodeQue = deque()   
        leftQue = deque()   
        rightQue = deque() 

        # 把根节点和其对应的区间 [0, len(nums)-1] 加入队列，表示要从这个区间构造根节点
        nodeQue.append(root)             
        leftQue.append(0)                  
        rightQue.append(len(nums) - 1)   

        # 只要还有节点待处理，就继续循环（即还没构造完）
        while nodeQue:
            # 从队列中分别取出当前节点，以及它对应的数组范围 [left, right]
            cur = nodeQue.popleft()
            left = leftQue.popleft()
            right = rightQue.popleft()
            
            # 计算中点索引 mid，这是当前区间的“最佳根节点位置”
            # 这样保证了树的平衡性，因为总是选择中间值作为节点
            mid = left + (right - left) // 2

            # 将当前节点 cur 的值设置为中点值 nums[mid]，即构造当前根节点
            cur.val = nums[mid]

            # 如果左半区间还有元素，说明可以构造左子树
            if left <= mid - 1:
                # 创建左子节点（暂时赋值为0）
                # 把它和其对应区间 [left, mid-1] 加入队列，等待后续处理
                cur.left = TreeNode(0)
                nodeQue.append(cur.left)
                leftQue.append(left)
                rightQue.append(mid - 1)
            
            # 如果右半区间还有元素，说明可以构造右子树
            if right >= mid + 1:  
                # 创建右子节点（值暂时为 0）
                # 把它和其对应的区间 [mid+1, right] 加入队列，等待后续处理
                cur.right = TreeNode(0)
                nodeQue.append(cur.right)
                leftQue.append(mid + 1)
                rightQue.append(right)
        
        # 所有节点构造完毕后，返回整棵树的根节点
        return root
```

- 时间复杂度：`O(n)`，每个元素都只访问一次
- 空间复杂度：`O(n)`，队列和树节点的存储