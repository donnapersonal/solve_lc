# 543.二叉树的直径

题目链接：[543.二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

## 题目大意

给一棵二叉树的根节点，返回该树的`直径`

二叉树的`直径`是指树中任意两个节点之间最长路径的`长度`，这条路径可能经过也可能不经过根节点 `root` 

两节点之间路径的`长度`由它们之间边数表示

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.b98xv593k.webp)

限制：
- The number of nodes in the tree is in the range [1, 10^4].
- -100 <= Node.val <= 100

## 解题

关键洞察：
- 对于任意一个节点，以它为“路径中心”，它的最长路径 = 左子树深度 + 右子树深度
- 在递归中访问每个节点，计算其左/右子树深度，并更新最大直径
- 所以：本质是一个后序遍历，边遍历边维护最大值

递归思路：
- 后序遍历整棵树（先处理左右，再处理当前）
- 每个节点：
  - 计算左右子树最大深度：`leftMax`, `rightMax`
  - 直径更新为 `leftMax + rightMax`
- 向上传回当前子树的最大深度：`max(leftMax, rightMax) + 1`

```js
var diameterOfBinaryTree = function(root) {
    let maxDiameter = 0;

    const getMaxDiameter = function(root) {
        if (root == null) return 0;
        let leftMax = getMaxDiameter(root.left);
        let rightMax = getMaxDiameter(root.right);

        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);
        
        return Math.max(leftMax, rightMax) + 1;
    };

    getMaxDiameter(root);
    return maxDiameter;
};
```
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # 初始化类变量，用于记录目前找到的最大直径
        self.maxDiameter = 0
        # 调用辅助递归函数，开始深度优先遍历整个树
        self.getDiameter(root)
        # 遍历结束后返回记录的最大直径
        return self.maxDiameter

    def getDiameter(self, root):
        # 递归终止条件：空节点返回深度为 0
        if not root:
            return 0
        
        # 分别计算左右子树的最大深度
        # 这里递归深入，直到叶子节点再一层层向上返回
        leftMax = self.getDiameter(root.left)
        rightMax = self.getDiameter(root.right)

        # 更新最大直径：
        # 当前节点为“中心”时，穿过它的最长路径为：左深度 + 右深度，更新全局最大值
        # # 注意，这里不需要 +1，因为 leftMax 和 rightMax 已经包含了所有经过 root 的节点数总和，不需要再额外增加
        self.maxDiameter = max(self.maxDiameter, leftMax + rightMax)
        
        # leftMax 和 rightMax 分别表示当前 root 节点的左子树和右子树的最大深度
        # max(leftMax, rightMax) + 1 表示当前 root 节点到叶子节点的最长路径，即当前节点的深度
        # +1 的原因：在递归调用中，每次返回值表示当前节点到叶子节点的最大深度，所以需在子节点的深度 max(leftMax, rightMax) 基础上再加上当前节点自身的深度 1
        return max(leftMax, rightMax) + 1
```

- 时间复杂度：`O(n)`，其中 `n` 是二叉树的节点数目
- 空间复杂度：`O(n)`，递归函数需要用到栈空间，栈空间取决于递归深度，最坏情况下递归深度为 `n`