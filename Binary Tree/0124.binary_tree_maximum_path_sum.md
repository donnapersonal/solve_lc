# 124.二叉树中的最大路径和

题目链接：[124.二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

## 题目大意

二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中至多出现一次，该路径至少包含一个节点，且不一定经过根节点

路径和是路径中各节点值的总和

给你一个二叉树的根节点 `root`，返回其最大路径和 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.3d54kipkek.webp)

限制：
- The number of nodes in the tree is in the range [1, 3 * 10^4].
- -1000 <= Node.val <= 1000

## 解题

初始思路：暴力 DFS（错误/低效）
- 遍历二叉树的每一个节点
- 以该节点为根，分别求：
  - 左子树的路径和
  - 右子树的路径和
- 计算每个节点的 最大路径和
- 问题：
  - 会重复计算很多子树的路径和，效率低
  - 如果只求从根到叶子的路径和，是错误的，因为路径不一定经过根
- 复杂度：时间复杂度：O(n^2)（每个节点都重新遍历子树）

优化思路：`自底向上的递归`
- 对于任意一个节点 `node`，路径和有两种情况：
  - 从上到下的贡献：只能选择 一条分支，即左子树或右子树中更大的路径和
  - 经过当前节点的新路径：如果一条路径经过 node，则总路径和是：`price_newpath = node.val + left_sum + right_sum`
- 解决方案
  - 用 `DFS` 递归返回以当前节点为起点的最大单边路径和
  - 同时维护一个全局变量 `max_sum`，记录全局的最大路径和

最优解思路
- 递归定义 - `dfs(node)` 返回值：
  - 从当前 `node` 出发向下走的最大路径和（只能选择左或右一边）
  - 如果子路径是负数，则不取，即与 `0` 比较
- 更新全局最大值：每到一个节点时，假设把左子树和右子树都加进来，计算：
  ```python
  price_newpath = node.val + left_sum + right_sum
  max_sum = max(max_sum, price_newpath)
  ```
- 返回值与全局变量的区别
  - 返回值：贡献给父节点的最大单边路径
  - 全局变量：记录任何路径的最大值（可能是单边，也可能是跨过当前节点）

```js
var maxPathSum = function(root) {
    let maxSum = -Infinity;
    const dfs = function(node) {
        if (!node) return 0;
        // 计算左右子树的单边最大路径和
        const leftSum = Math.max(dfs(node.left), 0);
        const rightSum = Math.max(dfs(node.right), 0);
        // 计算通过当前节点的最大路径和
        const priceNewPath = node.val + leftSum + rightSum;
        // 更新最大路径和
        maxSum = Math.max(maxSum, priceNewPath);
        // 返回单边路径和给父节点使用
        return node.val + Math.max(leftSum, rightSum);
    };
    dfs(root);
    return maxSum;
};
```
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:   
        # 定义 max_sum 为全局最大路径和，初始值为负无穷
        # 为什么是负无穷？因为节点值可能是负数，不能初始化为 0，否则全负数树会出错
        max_sum = float('-inf')

        # 定义递归函数 dfs(node)，返回 从当前节点出发向下的最大单边路径和
        def dfs(node):
            # 使用 nonlocal max_sum，让递归函数可以修改外层变量
            nonlocal max_sum
            # 如果当前节点为空（即叶子节点的子节点），返回 0，表示该分支的路径和为零
            if not node:
                return 0
            
            # 计算左右子树的单边最大路径和
            # 使用 max(..., 0) 来忽略负数路径和，如果左子树或右子树的路径和为负数，将其视为 0，即不计入当前路径；这是因为负路径和会降低整体路径和
            left_sum = max(dfs(node.left), 0)
            right_sum = max(dfs(node.right), 0)
            # price_newpath 表示 以当前节点为最高点、同时经过左右子树的路径和
            # 计算通过当前节点的最大路径和
            # 这是一个完整路径，意味着可以选择左子树、右子树和当前节点一起形成一条路径
            price_newpath = node.val + left_sum + right_sum
  
            # 更新全局最大路径和 max_sum
            # 注意：max_sum 不一定等于返回值，因为最大路径可能跨越当前节点
            max_sum = max(max_sum, price_newpath)

            # 递归返回给父节点的值是：
            # 对于父节点而言，只能选择一条子树路径（左子树或右子树），而不能同时选择两条路径（因为路径不能分叉）
            # 当前节点值 + 左右子树中贡献更大的那一边
            # 父节点只能选择一条路径延伸下去，所以这里取 max(left_sum, right_sum)
            return node.val + max(left_sum, right_sum)
        
        # 从根节点开始 DFS
        dfs(root)
        # 遍历整棵树后，max_sum 中记录了全局最大路径和
        return max_sum
```

- 时间复杂度：`O(n)`，其中 `n` 是节点数。每个节点都被访问一次，因此时间复杂度是线性的
- 空间复杂度：`O(h)`，其中 `h` 是二叉树的高度。递归栈的最大深度等于树的高度
  - 在最坏情况下（如链式树），空间复杂度为 `O(n)`
  - 在平均情况下（平衡树），空间复杂度为 `O(logn)`