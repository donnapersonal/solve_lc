# 1123.最深叶节点的最近公共祖先

题目链接：[1123.最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/)

## 题目大意

给你一个有根节点 `root` 的二叉树，返回它 最深的叶节点的最近公共祖先 

回想一下：
- 叶节点 是二叉树中没有子节点的节点
- 树的根节点的 深度 为 `0`，如果某一节点的深度为 `d`，那它的子节点的深度就是 `d+1`
- 如果假定 `A` 是一组节点 `S` 的最近公共祖先，`S` 中的每个节点都在以 `A` 为根节点的子树中，且 `A` 的深度达到此条件下可能的最大值

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8adms5fee5.webp)

限制：
- The number of nodes in the tree will be in the range [1, 1000].
- 0 <= Node.val <= 1000
- The values of the nodes in the tree are unique.

## 解题

初始暴力想法
- 先找到树的最大深度 maxDepth
- 收集所有深度为 maxDepth 的叶子节点
- 从根节点开始查找这些节点的LCA（可以用标准LCA算法，两两合并）。
- 缺点：
  - 需要多次遍历：先找深度、再找节点、再求LCA
  - 实现麻烦，效率低
  
优解思路：`递归返回最大深度 + 全局记录结果`
- 定义 `dfs(node, depth)` 返回当前节点子树的最大深度
- 在遍历时不断更新全局最大深度 `max_depth`
- 当某个节点左右子树的最大深度都等于 `max_depth` 时，这个节点就是最深叶子节点的 `LCA`，记录在 `res` 中
- 优点：
  - 只遍历一遍树 → 时间复杂度 `O(N)`
  - 空间复杂度 `O(H)`（递归栈，H 为树高）
  - 代码简洁，逻辑清晰

```js
var lcaDeepestLeaves = function(root) {
    let res = null;
    let maxDepth = -1; 
    function dfs(node, depth) {
        if (node === null) {
            maxDepth = Math.max(maxDepth, depth); 
            return depth;
        }
        const leftMaxDepth = dfs(node.left, depth + 1); 
        const rightMaxDepth = dfs(node.right, depth + 1); 
        if (leftMaxDepth === rightMaxDepth && leftMaxDepth === maxDepth) { 
            res = node;
        }
        return Math.max(leftMaxDepth, rightMaxDepth);
    }
    dfs(root, 0);
    return res;
};
```
```python
class Solution:
    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        # res：全局变量，用来存放结果（LCA 节点）
        res = None
        # max_depth：全局变量，用来记录遍历过程中遇到的最大深度
        max_depth = -1

        # 定义一个内部函数 dfs(node, depth)：
        # node：当前遍历到的节点
        # depth：当前节点的深度（根节点深度为0）
        def dfs(node: Optional[TreeNode], depth: int) -> int:
            # nonlocal 声明：在内部函数中可以修改外部的 res 和 max_depth
            nonlocal res, max_depth

            # 递归出口：
            # 如果当前节点为空：
            # 更新全局最大深度 max_depth
            # 返回当前深度 depth
            # 这样在遍历过程中，能动态更新最大深度
            if node is None:
                max_depth = max(max_depth, depth)
                return depth
            
            # 递归遍历左右子树，并分别得到左右子树的最大深度：
            # 左子树深度 = left_max_depth
            # 右子树深度 = right_max_depth
            left_max_depth = dfs(node.left, depth + 1)
            right_max_depth = dfs(node.right, depth + 1)

            # 如果当前节点的左右子树最大深度都等于全局最大深度 max_depth：
            # 说明这个节点是最深叶子节点的最近公共祖先
            # 更新结果 res = node
            if left_max_depth == right_max_depth == max_depth:
                res = node
            
            # dfs 函数返回当前节点子树的最大深度（左右子树中更深的那一个）
            return max(left_max_depth, right_max_depth) 
        
        # 从根节点开始 DFS，初始深度为 0
        dfs(root, 0)
        # 返回记录好的 res 节点作为答案
        return res
```

- 时间复杂度：`O(n)`，每个节点都会恰好访问一次
- 空间复杂度：`O(n)`，最坏情况下，二叉树是一条链，递归需要 `O(n)` 的栈空间