# 230.二叉搜索树中第 K 小的元素

题目链接：[230.二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

## 题目大意

给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请设计一个算法查找其中第 `k` 小的元素（从 `1` 开始计数）

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8l0fh8m456.png)

限制：
- The number of nodes in the tree is n.
- 1 <= k <= n <= 10^4
- 0 <= Node.val <= 10^4

## 解题

在二叉搜索树中：中序遍历的结果是升序排序的节点值序列。

因此：
- 如果对 `BST` 进行「中序遍历」，只需数到第 `k` 个节点即可直接返回答案
- 无需额外排序，也无需完整记录所有值

### 思路 1: 迭代

相比递归中序遍历，迭代写法（用栈）具有以下优点：
- 更加节省空间（不依赖递归栈）
- 更容易控制节点访问个数（遇到第 `k` 个元素就返回）

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        # 初始化一个栈 stack，用于模拟中序遍历过程
        # 作用：用来存储还没处理的节点
        stack = []
        # 主循环条件：只要当前节点不为 None 或栈不为空，就继续遍历
        # 这是中序遍历的标准写法框架
        while root or stack:
            # 这段代码将当前节点和它的所有左子节点一路压入栈中
            # 中序遍历的“左根右”顺序 → 要先走到最左侧
            # 每次压入左子树，直到到底（root == None）
            while root:
                stack.append(root)
                root = root.left
            
            # 从栈顶弹出一个节点，代表当前应该访问的“中间节点”（即当前子树的根）
            # 这是中序遍历中的“访问根”阶段
            root = stack.pop()
            # 每访问一个节点，就说明我们遇到下一个最小的元素 → 将 k 减 1
            k -= 1

            # 如果已经访问了第 k 个节点，直接返回它的值即可
            # 无需继续遍历，节省时间
            if k == 0:
                return root.val
            
            # 转向当前节点的右子树，继续中序遍历
            # 顺序是：左 → 中 → 右
            root = root.right
```

- 时间复杂度：`O(n)`（最坏情况），`O(k)`（最好情况，找到第 `k` 小的元素后即会提前停止遍历）
- 空间复杂度：`O(n)`（最坏情况），`O(log n)`（最好情况，平衡树）


### 思路 2: 递归

中序遍历 + 计数
- 对树进行中序遍历，同时用变量记录已经访问的节点数
- 一旦访问到第 `k` 个节点，立即记录结果并返回

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        # 初始化两个全局变量（实例变量）：
        # self.rank：记录当前中序遍历已访问的节点数量
        # self.res：用于保存最终第 k 个节点的值
        self.res = self.rank = 0
        # 调用辅助函数 traverse 进行中序遍历
        self.traverse(root, k)
        # 遍历完成后，返回第 k 小的结果
        return self.res
    
    def traverse(self, root, k):
        # 递归终止条件：空节点不处理，直接返回
        if not root:
            return None
        
        # 先递归访问左子树（中序遍历的“左 → 根 → 右”顺序）
        self.traverse(root.left, k)
        # 访问当前节点：将访问计数器 rank 加 1
        self.rank += 1

        # 如果当前节点是第 k 个被访问的节点，则记录其值为结果并提前返回
        # 注意：这里没有立即 return 整个函数，因为右子树仍可能递归调用
        if self.rank == k:
            self.res = root.val
            return
        
        # 最后递归访问右子树
        self.traverse(root.right, k)
```

- 时间复杂度：`O(n)`（最坏情况），`O(k)`（最好情况，找到第 k 小的元素后即会提前停止遍历）
- 空间复杂度：`O(n)`（最坏情况），`O(log n)`（最好情况，平衡树）