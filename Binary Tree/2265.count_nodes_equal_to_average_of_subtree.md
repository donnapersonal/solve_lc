# 2265.统计值等于子树平均值的节点数

题目链接：[2265.统计值等于子树平均值的节点数](https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/)

## 题目大意

给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 

注意：
- n 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数
- root 的 子树 由 root 和它的所有后代组成

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddfe8vcem.webp)

限制:
- The number of nodes in the tree is in the range [1, 1000].
- 0 <= Node.val <= 1000

## 解题

暴力思路
- 对每个节点，遍历其整个子树，求子树和与节点数量
- 再判断节点值是否等于子树平均值
- 问题： 对每个节点都遍历整个子树 → 时间复杂度 O(n^2)，大树会超时

优化思路
- 递归自底向上计算每个节点子树的 sum 和 count
- 对每个节点：
  - 左子树返回 (sum_left, count_left)
  - 右子树返回 (sum_right, count_right)
  - 当前节点子树和 sum_val = node.val + sum_left + sum_right
  - 当前节点子树节点数 count = 1 + count_left + count_right
- 判断 node.val == sum_val // count → 满足条件的节点计数 +1


为什么是最优解?
- 每个节点只访问一次，左右子树的结果直接利用，不重复计算
- 不需要额外存储子树信息，空间仅递归栈
- 完全符合面试要求的 自底向上递归 + 子树信息传递 模板

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var averageOfSubtree = function(root) {
    let res = 0;

    function dfs(node) {
        if (!node) return [0, 0]; // [sum, count]
        
        let sum = node.val;
        let count = 1;

        if (node.left) {
            let [s, c] = dfs(node.left);
            sum += s;
            count += c;
        }

        if (node.right) {
            let [s, c] = dfs(node.right);
            sum += s;
            count += c;
        }

        if (node.val === Math.floor(sum / count)) {
            res++;
        }

        return [sum, count];
    }

    dfs(root);
    return res;
};
```
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def averageOfSubtree(self, root: TreeNode) -> int:
        # 全局计数器，记录满足条件的节点数量
        self.res = 0
        # 定义递归函数，返回 (子树和, 子树节点数)
        def dfs(node: TreeNode) -> tuple[int, int]:
            # return sum, count
            # 空节点直接返回 0 和 0
            if not node:
                return 0, 0
            
            # 当前节点初始和与节点数
            sum_val, count = node.val, 1
            
            # 左子树递归求和与计数
            if node.left:
                s, c = dfs(node.left)
                # 累加左子树结果
                sum_val += s
                count += c

            # 右子树递归求和与计数
            if node.right:
                s, c = dfs(node.right)
                # 累加右子树结果
                sum_val += s
                count += c
            
            # 当前节点值等于子树平均值 → 计数+1
            if node.val == sum_val // count:  # integer division
                self.res += 1
            
            # 返回当前节点子树信息给父节点
            return sum_val, count
        
        # 从根节点开始递归
        dfs(root)
        # 返回总计数
        return self.res
```

- 时间复杂度：`O(n)`，每个节点访问一次
- 空间复杂度：`O(h)`，递归栈高度为树的高度 `h`
