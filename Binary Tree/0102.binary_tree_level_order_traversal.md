# 102.二叉树的层序遍历

题目链接：[102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

## 题目大意

给你二叉树的根节点 `root`，返回其节点值的层序遍历（即逐层地，从左到右访问所有节点）

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2326gvt7c7.webp)

限制：
- The number of nodes in the tree is in the range [0, 2000].
- -1000 <= Node.val <= 1000

## 解题

天然适合使用 `BFS`

思路关键点：
- 层序遍历天然适合用`队列（queue）`结构实现 `BFS`
- 每次处理队列中的一个“层”的所有节点，同时把下一层的节点加入队列
- 每一层我们都单独开一个列表收集值，加入结果

```js
var levelOrder = function(root) {
    let res = [];
    if (root == null) return res;
    let que = [root];
    while (que.length) {
        let size = que.length;
        let nodeList = [];
         while (size-- > 0) {
            let cur = que.shift();
            nodeList.push(cur.val);
            if (cur.left != null) que.push(cur.left);
            if (cur.right != null) que.push(cur.right);
        }
        res.push(nodeList);
    }
    return res;
};
```
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        res = []
        if not root:
            return []
        
        que = collections.deque([root])

        while que:
            size = len(que)
            level_node = []
            for i in range(size):
                cur = que.popleft()
                level_node.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                
                if cur.right:
                    que.append(cur.right)
                

            res.append(level_node)
        
        return res
```

- 时间复杂度：`O(n)`，`n` 是二叉树的节点数目，每个节点访问一次，入队一次，出队一次
- 空间复杂度：`O(n)`，队列最多同时存储一个层级的所有节点，最坏情况是完全二叉树的最后一层，占用 `O(n)` 空间