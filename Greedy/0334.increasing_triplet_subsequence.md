# 334.递增的三元子序列

题目链接：[334.递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

## 题目大意

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

```js
Example 1:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.

Example 2:
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.

Example 3:
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: One of the valid triplet is (1, 4, 5), because nums[1] == 1 < nums[4] == 4 < nums[5] == 6.
```

限制：
- 1 <= nums.length <= 5 * 10^5
- -2^31 <= nums[i] <= 2^31 - 1
  
## 解题

**初始思路（暴力三重循环）**
- 枚举所有三元组 `(i, j, k)`，检查是否满足递增条件
- 时间复杂度：`O(n³)`，面试中肯定超时，不考虑

**改进思路：双重循环 + 贪心维护最小值**
- 枚举 `j`，找出左边的最小 `nums[i]` 和右边是否有大于 `nums[j]` 的 `nums[k]`
- 时间复杂度：`O(n²)`，仍然不够好

**最优思路（贪心 + 双变量）**
- 只需要找到两个递增的值 `first < second`，只要后面出现一个 `num > second`，就说明满足条件
- 如何实现：
  - 初始化两个变量 `first` 和 `second` 为无穷大
  - 遍历数组：
    - 如果 `num <= first`，说明找到了更小的起点，更新 `first`
    - 否则如果 `num <= second`，说明找到了一个比 `first` 大的数，更新 `second`
    - 否则说明存在 `num > second > first`，三元递增成立，直接返回 `True`

> 贪心思想：为了找到递增的三元子序列，first 和 second 应该尽可能地小，此时找到递增的三元子序列的可能性更大

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    let first = Infinity;  // 第一个最小值
    let second = Infinity; // 第二个最小值

    for (let num of nums) {
        if (num <= first) {
            first = num;      // 更新 first
        } else if (num <= second) {
            second = num;     // 更新 second
        } else {
            // 出现 num > second > first，说明存在递增三元组
            return true;
        }
    }

    return false;
};

// 写法 2
var increasingTriplet = function(nums) {
    const n = nums.length;
    if (n < 3) {
        return false;
    }
    let first = nums[0], second = Number.MAX_VALUE;
    for (let i = 1; i < n; i++) {
        const num = nums[i];
        if (num > second) {
            return true;
        } else if (num > first) {
            second = num;
        } else {
            first = num;
        }
    }
    return false;
};
```
```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        if len(nums) < 3:
            return False
        
        # first: 第一个最小值
        # second: 初始化第二个最小值（大于first）
        first, second = float('inf'), float('inf')

        for num in nums:
            if num <= first:
                first = num     # 更新第一个最小值 
            elif num <= second:
                second = num    # 更新第二个最小值
            else:
                # 找到比first和second都大的数，说明存在三元递增
                return True

        return False

# 写法 2
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        n = len(nums)
        if n < 3:
            return False
        first, second = nums[0], float('inf')
        for i in range(1, n):
            num = nums[i]
            if num > second:
                return True

            if num > first:
                second = num
            else:
                first = num
                
        return False
```

- 时间复杂度：`O(n)`，其中 `n` 是数组 `nums` 的长度。需要遍历数组一次
- 空间复杂度：`O(1)`