# 2160.拆分数位后四位数字的最小和

题目链接：[2160.拆分数位后四位数字的最小和](https://leetcode.cn/problems/minimum-sum-of-four-digit-number-after-splitting-digits/)

## 题目大意

给你一个四位正整数 `num`。请你使用 `num` 中的数位，将 `num` 拆成两个新的整数 `new1` 和 `new2`。`new1` 和 `new2` 中可以有前导 `0`，且 `num` 中所有数位都必须使用

比方说，给你 `num = 2932`，你拥有的数位包括：两个 `2` ，一个 `9` 和一个 `3`。一些可能的 `[new1, new2]` 数对为 `[22, 93]，[23, 92]，[223, 9] 和 [2, 329]`

请返回可以得到的 `new1` 和 `new2` 的最小和

```js
Example 1:
Input: num = 2932
Output: 52
Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc.
The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52.

Example 2:
Input: num = 4009
Output: 13
Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. 
The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13.
```

限制：
- 1000 <= num <= 9999

## 解题

思路：`贪心 + 排序`

关键观察：
- 数字越小，越应该出现在高位！
- 因此，我们应该让最小的数字出现在两个数的十位位，次小的排在个位位，形成的两个数最小

步骤：
- 拆出 `num` 中的四个数字，存入数组
- 排序（升序）
- 按位组装两个数字：
  - `new1 = d0 * 10 + d2`
  - `new2 = d1 * 10 + d3`
  
> 为什么这样安排？
> - 十位贡献更大，所以要把最小的两个数字分到不同的十位
> - 个位相对影响小，随便分剩下两个

这就是贪心策略，直接排序后按上述方式组合，`O(1)` 就能得到最优解

```js
var minimumSum = function(num) {
    const digits = Array.from(String(num), Number).sort((a, b) => a - b);
    const new1 = digits[0] * 10 + digits[2];
    const new2 = digits[1] * 10 + digits[3];
    return new1 + new2;
};
```
```python
# 写法 1
class Solution:
    def minimumSum(self, num: int) -> int:
        digits = sorted([int(d) for d in str(num)])
        new1 = digits[0] * 10 + digits[2]
        new2 = digits[1] * 10 + digits[3]
        return new1 + new2

# 写法 2
class Solution:
    def minimumSum(self, num: int) -> int:
        # 初始化一个空列表 digits，用于存放从 num 拆出来的每一位数字
        digits = []
        # 当 num 不为 0 时，循环执行以下操作来拆分数字
        while num:
            # 用 num % 10 取出当前的 个位数字，放入 digits 列表
            digits.append(num % 10)
            # 用整除 // 去掉 num 的个位，准备下一次循环取下一个数字
            num //= 10
        
        # 对 digits 列表中的 4 个数字 升序排序，保证 digits[0] 是最小，digits[3] 是最大
        digits.sort()
        # 根据前面分析的贪心构造：
        # - digits[0] 和 digits[1] 分别作为两个数的十位
        # - digits[2] 和 digits[3] 分别作为两个数的个位
        # 两个数之和 = (digits[0] + digits[1]) * 10 + (digits[2] + digits[3])
        # 返回最终的最小和
        return (digits[0] + digits[1]) * 10 + digits[2] + digits[3]
```

- 时间复杂度：`O(1)`
  - 拆分数字 `O(1)`
  - 排序 `O(4log4) -> O(1)` （`4`个数字固定）
  - 组装并求和 `O(1)`
- 空间复杂度：`O(1)`