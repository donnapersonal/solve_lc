# 670.最大交换

题目链接：[670.最大交换](https://leetcode.cn/problems/task-scheduler/)

## 题目大意

给定一个非负整数，你至多可以交换一次数字中的任意两，返回你能得到的最大值

```js
Example 1:
Input: num = 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.

Example 2:
Input: num = 9973
Output: 9973
Explanation: No swap.
```

限制：
- 0 <= num <= 10^8

## 解题

最初暴力思路
- 遍历所有的`「两两位置」(i, j)`，尝试交换它们，然后计算出新数字，找出最大值
- 复杂度分析：假设数字长度为 `n`，两两遍历是 `O(n^2)`，对于最多 `10` 位的整数问题也可以接受，但不够优雅

进一步优化思路
- 我们要做的就是找到一个位置 `i` 的数字，把它换成后面某个位置 `j` 的更大的数字，以便让数字尽量大
- 想要最大值，自然优先考虑左边高位，越靠前越影响整体数值

思考点：
- 如果从左到右扫描，我们希望：在位置 `i`，右边有一个更大的数字可以替换它
- 但是我们不知道右边最大的数字位置，需要预处理

我们可以反向遍历数字（从右到左），同时维护 `max_index` 表示目前最右边的`最大数字`的位置：
- 如果当前数字 `s[i]` 大于右边记录的最大值 `s[max_index]`，就更新 `max_index = i`
- 如果当前数字 `s[i]` 小于右边最大值 `s[max_index]`，说明：👉 右边存在更大的数字可以交换，记录下来
- 并且我们希望最终交换时，`s[i]` 尽量靠左（更高位），而右边选择的是最靠右的最大值，能获得最大提升

最终得到的就是最左侧需要换的位置 `index1` 和右侧最大数字的位置 `index2`，交换即可

```js
var maximumSwap = function(num) {
    const arr = [...'' + num];
    const n = arr.length;
    let maxIndex = n - 1;
    let index1 = -1, index2 = -1;
    for (let i = n - 1; i >= 0; i--) {
        if (arr[i] > arr[maxIndex]) {
            maxIndex = i;
        } else if (arr[i] < arr[maxIndex]) {
            index1 = i;
            index2 = maxIndex;
        }
    }
    if (index1 >= 0) {
        swap(arr, index1, index2);
        return parseInt(arr.join(''));
    } else {
        return num;
    }
};

const swap = (arr, i, j) => {
    const temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
};
```
```python
class Solution:
    def maximumSwap(self, num: int) -> int:
        # 将整数转成字符数组，方便按位交换
        # 如 num = 2736 -> s = ['2','7','3','6']
        s = list(str(num))
        n = len(s)
        # max_index 表示当前“右侧最大值”的位置，初始是最后一位
        max_index = n - 1
        # index1 和 index2 分别记录要交换的两个位置，默认没有找到
        index1 = index2 = -1
        # for i in range(n-2, -1, -1) 也行
        # 从右向左遍历所有位置
        for i in range(n-1, -1, -1):
            if s[i] > s[max_index]:
                # 如果当前数字比当前记录的最大数字还大
                # 那么更新 max_index，因为从这一位开始，右侧最大值就变了
                max_index = i
            elif s[i] < s[max_index]:
                # 如果当前数字比右侧最大值还小
                # 说明可以通过交换 s[i] 和右侧更大的那个数，得到更大的结果
                # 记录下来（不断更新，最后会得到最左边能换的位置和最右边最大值）
                index1, index2 = i, max_index
        
        # 如果 index1 依然是 -1，说明整个数字已经是降序排列，无需交换
        if index1 < 0:
            return num
        
        # 交换两个位置的数字
        s[index1], s[index2] = s[index2], s[index1]
        
        # 拼接成整数并返回
        return int(''.join(s))
```

- 时间复杂度：`O(lognum)`，其中整数 `num` 为给定的数字
  - `num` 转换为十进制数，有 `O(lognum)` 个数字，需遍历一次所有的数字即可
- 空间复杂度：`O(lognum)`，其中整数 `num` 为给定的数字
  - `num` 转换为十进制数，有 `O(lognum)` 个数字，需要保存 `num` 所有的数字
  
> 注意：可以写成 `O(n)`，其中 `n` 是数字 `num` 的十进制位数，但如果从 `num` 的数值大小来描述：
> - 一个整数 `num` 的 **十进制位数** 大约是 `log10(num)`（如 `num = 2736` 有 `4` 位，`log10(2736) ≈ 3.4`，取整后 `+1 ≈ 4`）
> - 所以 `O(n)` 也可以写作 `O(log10(num))`，即 `O(log num)`