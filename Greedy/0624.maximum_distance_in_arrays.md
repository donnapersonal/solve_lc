# 624.数组列表中的最大距离

题目链接：[624.数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)

## 题目大意

给定 `m` 个数组，每个数组都已按照升序排好序了

现在你需要从两个不同的数组中选择两个整数（每个数组选一个）且计算它们的距离。两个整数 `a` 和 `b` 之间的距离定义为它们差的绝对值 `|a-b|` 

返回最大距离

```js
Example 1:
Input: arrays = [[1,2,3],[4,5],[1,2,3]]
Output: 4
Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.

Example 2:
Input: arrays = [[1],[1]]
Output: 0
```

限制：
- m == arrays.length
- 2 <= m <= 10^5
- 1 <= arrays[i].length <= 500
- -10^4 <= arrays[i][j] <= 10^4
- arrays[i] is sorted in ascending order.
- There will be at most 105 integers in all the arrays.

## 解题

最初直观思路：暴力枚举
- 对每一对不同的数组 `(i, j)`，尝试从 `arrays[i]` 和 `arrays[j]` 各取一个元素，算出差值：
  - 最大差值一般来自于：一个数组的最小值 和 另一个数组的最大值
- 因为每个数组已经升序：只需要比较 `arrays[i][0]`（最小值）和 `arrays[j][-1]`（最大值）即可
- 复杂度：双重循环 `O(m²)`
- 最简单暴力的方法：可检查所有数组对
- 问题：当数组数量 `m` 很大时，`O(m²)` 会超时

观察发现：我们只关心`全局最小值`和`全局最大值`之间的组合，但要确保它们来自不同的数组

优化思路：
- 从左到右遍历每个数组，维护到目前为止：
  - `min_val`：之前所有数组中的最小值
  - `max_val`：之前所有数组中的最大值
- 对于当前数组 `arr`：
  - 当前数组最大值 `arr[-1]` 可以和之前的 `min_val` 组合 → `差值 = arr[-1] - min_val`
  - 当前数组最小值 `arr[0]` 可以和之前的 `max_val` 组合 → `差值 = max_val - arr[0]`
- 取最大差值，然后再更新 `min_val` 和 `max_val`，供后面的数组使用

为什么这样想：
- 要保证选择的元素来自不同数组，所以在遍历当前数组时，`min_val` 和 `max_val` 记录的都是`前面数组`的值，不会重复当前数组
- 这样只需一次遍历 `O(m)`，每个数组只看首尾两个数，速度大大提高

```js
var maxDistance = function(arrays) {
    let res = 0;
    let minVal = arrays[0][0];
    let maxVal = arrays[0][arrays[0].length - 1];

    for (let i = 1; i < arrays.length; i++) {
        let curr = arrays[i];
        let first = curr[0], last = curr[curr.length - 1];

        res = Math.max(res, Math.abs(last - minVal), Math.abs(maxVal - first));

        minVal = Math.min(minVal, first);
        maxVal = Math.max(maxVal, last);
    }

    return res;
};
```
```python
# 写法 1
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        res = 0
        min_val = arrays[0][0]
        max_val = arrays[0][-1]

        for i in range(1, len(arrays)):
            arr = arrays[i]
            res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))
            min_val = min(min_val, arr[0])
            max_val = max(max_val, arr[-1])
        
        return res

# 写法 2
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        # 初始化结果 res 为 0，用来存放当前找到的最大差值
        res = 0
        # min_val 初始化为正无穷，表示目前遇到的最小值
        # max_val 初始化为负无穷，表示目前遇到的最大值
        min_val, max_val = inf, -inf
        # 遍历 arrays 中的每一个升序数组 arr
        for arr in arrays:
            # 对当前数组 arr 计算差值：
            # - arr[-1] - min_val：当前数组最大值和前面记录的全局最小值之间的差
            # - max_val - arr[0]：当前数组最小值和前面记录的全局最大值之间的差
            # - 取这两个差值的最大值，与当前 res 比较更新
            # 注意：在第一次循环时，min_val 和 max_val 还是初始值，计算结果可能是负数或无效值。但这不会影响结果，因为之后会更新
            res = max(res, arr[-1] - min_val, max_val - arr[0])
            # 更新 min_val 和 max_val，将当前数组的首元素和尾元素纳入全局最小/最大值中，供下一轮数组使用
            min_val = min(min_val, arr[0])
            max_val = max(max_val, arr[-1])
        
        # 返回遍历后的最大差值 res
        return res
```

- 时间复杂度：`O(m)`，只遍历了一次长度为 `m` 的 `arrays`
- 空间复杂度：`O(1)`，只使用了常数级的额外空间