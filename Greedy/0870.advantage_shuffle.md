# 870.优势洗牌

题目链接：[870.优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

## 题目大意

给定两个长度相等的数组 `nums1` 和 `nums2`，`nums1` 相对于 `nums2` 的优势可以用满足 `nums1[i] > nums2[i]` 的索引 `i` 的数目来描述

返回 `nums1` 的任意排列，使其相对于 `nums2` 的优势最大化

```js
Example 1:
Input: nums1 = [2,7,11,15], nums2 = [1,10,4,11]
Output: [2,11,7,15]

Example 2:
Input: nums1 = [12,24,8,32], nums2 = [13,25,32,11]
Output: [24,32,8,12]
```

限制：
- 1 <= nums1.length <= 10^5
- nums2.length == nums1.length
- 0 <= nums1[i], nums2[i] <= 10^9

## 解题

朴素思路
- 暴力尝试：枚举 `nums1` 的所有排列，计算每个位置的对比结果，选出“优势最多”的排列
- 时间复杂度 `O(n!)`，完全不可行

改进的思路
- 想让 `res[i] > nums2[i]` 的位置尽可能多
- 如果 `nums1` 有一张“牌”刚好比 `nums2[i]` 大，就用它去“赢”这个位置
- 如果找不到比 `nums2[i]` 大的牌，就只能用最小的牌去“浪费掉”

这题就像田忌赛马的情景，`nums1` 就是田忌的马，`nums2` 就是齐王的马，数组中的元素就是马的战斗力，你就是谋士孙膑，请你帮田忌安排赛马顺序，使胜场最多

最优策略是将齐王和田忌的马按照战斗力排序，然后按照战斗力排名一一对比：若田忌的马能赢那就比赛，若赢不了那就换个垫底的来送人头，保存实力

### 思路 1：贪心 + 双指针

贪心策略 - 关键点：对于 `nums2` 中的每个数，优先用 `nums1` 中最小的、能刚好赢它的数；赢不了的就用 `nums1` 的最小牌

实现思路：
- 将 `nums1` 排序
- 将 `nums2` 按值从大到小排序，同时记录它们的原始下标
- 使用双指针：
  - `right` 指向 `nums1` 最大的数
  - `left` 指向 `nums1` 最小的数
- 从 `nums2` 最大的元素开始尝试：
  - 如果 `nums1[right] > 当前nums2元素` → `nums1[right]` 胜出，右指针左移
  - 否则 → 用 `nums1[left]`（最小的）去“送人头”，左指针右移
- 最终把结果按照 `nums2` 原下标放回

```js
var advantageCount = function(nums1, nums2) {
    const n1 = nums1.length;
    const maxArr = [];
    
    for (let i = 0; i < n1; i++) {
        maxArr.push([i, nums2[i]]);
    }
    
    maxArr.sort((a, b) => b[1] - a[1]);
    nums1.sort((a, b) => a - b);
    
    let left = 0;
    let right = n1 - 1;
    const res = new Array(n1).fill(0);
    
    for (let i = 0; i < n1; i++) {
        const [index, maxval] = maxArr[i];
        
        if (maxval < nums1[right]) {
            res[index] = nums1[right];
            right -= 1;
        } else {
            res[index] = nums1[left];
            left += 1;
        }
    }
    
    return res;
};
```
```python
class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # n1 是数组长度，用于后续循环、初始化结果
        n1 = len(nums1)
        # 先将 nums1 升序排列，从小到大，方便用双指针选择最小和最大的数
        nums1.sort()
        # 构建 maxArr：记录 nums2 每个元素的 原始下标 和 数值
        # 这样后面排序后还能知道放回的位置
        maxArr = []
        for i in range(n1):
            maxArr.append([i, nums2[i]])
        
        # 把 maxArr 按照 nums2 的值 从大到小 排序，并保留原索引
        # 因为要优先尝试击败最大的 nums2，尝试用 nums1 中当前最大值去“打败”它
        maxArr.sort(key=lambda x: -x[1])

        # 定义两个指针：
        # left：从 nums1 的最小数开始
        # right：从 nums1 的最大数开始
        left, right = 0, n1 - 1
        # 初始化结果数组 res，长度为 n1
        res = [0] * n1
        # 循环处理 maxArr 中每个元素（按 nums2 从大到小的顺序）
        while maxArr:
            # 取出 maxArr 中当前最大的 nums2 元素：
            # - i 是它的原始下标
            # - maxval 是它的值
            # 注意：这里用 pop(0) 会导致 O(n²)，更高效的写法应该用 pop() 从尾部或 collections.deque。逻辑上不影响理解
            pairs = maxArr.pop(0)
            i, maxval = pairs[0], pairs[1]

            # 如果当前 nums2 元素 maxval 能被 nums1[right]（最大牌）击败：
            # 把 nums1[right] 放在 res[i] 位置，然后 right 左移，表示这个牌已用
            if maxval < nums1[right]:
                res[i] = nums1[right]
                right -= 1
            else:
                # 否则（最大牌也赢不了它），用 nums1[left]（最小的牌）去“浪费”掉，放在 res[i]，然后 left 右移
                # 不浪费大牌，让它留给后面的更强敌
                res[i] = nums1[left]
                left += 1

        return res
```

- 时间复杂度: `O(nlogn)`
  - 排序 `nums1`: `O(n log n)`
  - 排序 `maxArr`: `O(n log n)`
  - 主循环: `O(n)`
- 空间复杂度: `O(n)`，主要用于 `maxArr` 和结果数组

### 思路 2

贪心策略
- 把 `nums2` 的位置按照大小排序（从小到大），就可以知道先处理最弱的对手牌，再到最强的
- `nums1` 先整体排序
- 使用两个指针：`left` 从最小开始，`right` 从最大开始

具体规则：
- 遍历 `nums1`（从小到大）：`
  - 如果当前 `x` 能打赢当前最小的 `nums2[idx[left]]`，那就派 `x` 去赢它（填入对应位置），`left` 往右移动
  - 否则 `x` 连最小的都赢不了，那就把它用来对付当前 `nums2` 最大的那张牌，`right` 往左移动（“用下等马对上等马”）
- 这样就实现了最大化优势匹配

```js
var advantageCount = function(nums1, nums2) {
    const n1 = nums1.length;
    const index1 = new Array(n1).fill(0);
    const index2 = new Array(n1).fill(0);
    for (let i = 0; i < n1; ++i) {
        index1[i] = i;
        index2[i] = i;
    }
    index1.sort((i, j) => nums1[i] - nums1[j]);
    index2.sort((i, j) => nums2[i] - nums2[j]);

    const res = new Array(n1).fill(0);
    let left = 0, right = n1 - 1;
    for (let i = 0; i < n1; ++i) {
        if (nums1[index1[i]] > nums2[index2[left]]) {
            res[index2[left]] = nums1[index1[i]];
            ++left;
        } else {
            res[index2[right]] = nums1[index1[i]];
            --right;
        }
    }
    return res;
};
```
```python
# 写法 1
class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n1 = len(nums1)
        index1, index2 = list(range(n1)), list(range(n1))
        index1.sort(key=lambda x: nums1[x])
        index2.sort(key=lambda x: nums2[x])

        res = [0] * n1
        left, right = 0, n1 - 1
        for i in range(n1):
            if nums1[index1[i]] > nums2[index2[left]]:
                res[index2[left]] = nums1[index1[i]]
                left += 1
            else:
                res[index2[right]] = nums1[index1[i]]
                right -= 1
        
        return res

### 写法 2
class Solution:
    def advantageCount(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # 把 nums1 排序，从小到大，方便后续用贪心挑选
        nums1.sort()

        n = len(nums1)
        # 对 nums2 的 索引 按 nums2 的值从小到大排序，得到 idx
        # 例如 nums2 = [1,10,4,11]，排序后：idx = [0, 2, 1, 3]
        # 表示 nums2[idx[0]] = 1 是最小的，nums2[idx[3]] = 11 是最大的
        idx = sorted(range(n), key=lambda i: nums2[i])
        # 初始化结果数组 res，等长，用于放最终的重排结果
        res = [0] * n
        # 定义两个指针：
        # - left 从最小位置开始（打最弱的对手牌）
        # - right 从最大位置开始（浪费给最强的对手牌）
        left, right = 0, n - 1
        # 遍历 nums1 的每一个元素 x，已经是升序
        for x in nums1:
            # 如果 x 可以打赢 nums2[idx[left]]：
            # - 在 res 对应 idx[left] 的位置放 x
            # - left 往右移，去处理下一个小的 nums2
            if x > nums2[idx[left]]:
                res[idx[left]] = x  # 用下等马比下等马
                left += 1
            else:
                # 否则，x 连最弱的牌都赢不了，那就把它用来填给 idx[right]（nums2 最大的那个位置）：
                # - 不会增加获胜数，但消耗掉这张牌
                # - right 往左移
                res[idx[right]] = x  # 用下等马比上等马
                right -= 1

        return res
```

- 时间复杂度：`O(nlogn)`，其中 `n` 是数组 `nums1` 和 `nums2` 的长度，即为排序需要的时间
- 空间复杂度：`O(n)`，即为排序时存储下标需要的空间