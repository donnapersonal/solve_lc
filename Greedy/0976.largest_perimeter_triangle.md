# 976.三角形的最大周长

题目链接：[976.三角形的最大周长](https://leetcode.cn/problems/largest-perimeter-triangle/)

## 题目大意

给定由一些正数（代表长度）组成的数组 `nums`，返回由其中三个长度组成的、面积不为零的三角形的最大周长。如果不能形成任何面积不为零的三角形，返回 `0`

```js
Example 1:
Input: nums = [2,1,2]
Output: 5
Explanation: You can form a triangle with three side lengths: 1, 2, and 2.

Example 2:
Input: nums = [1,2,1,10]
Output: 0
Explanation: 
You cannot use the side lengths 1, 1, and 2 to form a triangle.
You cannot use the side lengths 1, 1, and 10 to form a triangle.
You cannot use the side lengths 1, 2, and 10 to form a triangle.
As we cannot use any three side lengths to form a triangle of non-zero area, we return 0.
```

限制：
- 3 <= nums.length <= 10^4
- 1 <= nums[i] <= 10^6

## 解题

> 三角形成立条件：设三边为 `a ≤ b ≤ c`，成立三角形的条件是 `a + b > c`
> 
> 这就是「三角形不等式」：`任意两边之和 > 第三边`

最初暴力思路
- 想法：穷举数组中任意三条边 `(a,b,c)`，检查是否满足三角形不等式，如果满足就记录周长，最后取最大值
- 检查条件：
  ```python
  a + b > c
  a + c > b
  b + c > a
  ```
- 不满足则跳过
- 复杂度：三层循环枚举所有三元组 → `O(n³)`，当 `n` 很大时效率低

优化思路的发现
- 排序后，如果 `a ≤ b ≤ c`，只需要检查 `a + b > c` 即可（因为 `b + c > a` 和 `a + c > b` 在正数条件下必然成立）
- 要找`最大周长`，应当优先考虑`较大的边`，因为边越大，周长可能越大

如何用排序来优化
- 将数组从小到大排序，得到 `nums[0] ≤ nums[1] ≤ ... ≤ nums[n-1]`
- 从右往左扫描：
  - 每次拿三个连续的边 `(nums[i-2], nums[i-1], nums[i])`，因为连续的三个最大边才有可能组成最大周长
  - 检查 `nums[i-2] + nums[i-1] > nums[i]`：
    - 如果满足，立刻返回三者之和 → 这是能得到的最大周长
    - 如果不满足，继续往左看更小的边

```js
var largestPerimeter = function(nums) {
    nums.sort((a, b) => a - b);
    for (let i = nums.length - 1; i >= 2; i--) {
        if (nums[i - 2] + nums[i - 1] > nums[i]) {
            return nums[i - 2] + nums[i - 1] + nums[i];
        }
    }
    return 0;
};
```
```python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        # 对 nums 排序，从小到大排列
        # 这样可以直接从右往左检查，保证首先遇到的有效三角形就是周长最大的
        nums.sort()
        # 从倒数第 1 个元素（索引 len(nums)-1）开始，向左遍历到索引 2
        # 每次循环，考虑的三条边是 nums[i-2], nums[i-1], nums[i]
        for i in range(len(nums) - 1, 1, -1):
            # 检查三角形不等式：前两条较小的边之和要大于最大边
            # 因为排序后 nums[i-2] ≤ nums[i-1] ≤ nums[i]，其他两个条件一定成立
            if nums[i - 2] + nums[i - 1] > nums[i]:
                # 一旦找到符合条件的三条边，立刻返回它们的和
                # 因为从右向左检查，第一次找到的就是周长最大的三角形
                return nums[i - 2] + nums[i - 1] + nums[i]

        # 如果循环结束都没有找到符合条件的三条边，说明无法组成三角形，返回 0 
        return 0
```

- 时间复杂度：`O(nlogn)`，其中 `n` 是数组 `nums` 的长度。
- 空间复杂度：`Ω(logn)`