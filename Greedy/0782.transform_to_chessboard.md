# 782.变为棋盘

题目链接：[782.变为棋盘](https://leetcode.cn/problems/transform-to-chessboard/)

## 题目大意

一个 `n x n` 的二维网络 `board` 仅由 `0` 和 `1` 组成 。每次移动，你能交换任意两列或是两行的位置

返回将这个矩阵变为 “棋盘” 所需的最小移动次数。如果不存在可行的变换，输出 `-1`

“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.4g4otpjp5r.webp)

限制：
- n == board.length
- n == board[i].length
- 2 <= n <= 30
- board[i][j] is either 0 or 1.

## 解题

最初思路：暴力尝试所有行列交换
- 理论上可以枚举所有行的排列，再枚举所有列的排列，检查是否形成棋盘
- 但是 `n` 可达 `30`，行列排列是 `n!`，不可行
- 暴力法复杂度太高

要形成棋盘，矩阵必须满足：
- 行和列只有两种模式
  - 棋盘的任意两行要么完全相同，要么完全相反
  - 同理，任意两列也是如此
- 两种模式互为反码
  - 如果行有两种类型 `row1` 和 `row2`，则必须 `row1[i] ^ row2[i] == 1` 对于每个 `i`
- 行数 / 列数分布必须合理
  - 对于 `n×n`，`row1` 出现次数与 `row2` 出现次数之差不能大于 `1`（因为要交错分布） 
- 在这些条件成立后，求最少交换数
  - 在行方向和列方向分别计算：要让行顺序像 `0101…` 或 `1010…`，需要多少次交换？
  - 最后相加

> 这属于`构造类 + 位运算技巧 + 贪心最小交换次数`的典型组合题

变成一个合法的棋盘格子，满足：
- `board[i][j] != board[i+1][j]`（上下不同）
- `board[i][j] != board[i][j+1]`（左右不同）

要想转换为棋盘，有两个必要条件：
- 所有行只能是两种互为反转的模式，如：
  - [0,1,0,1]
  - [1,0,1,0] ← 这是它的反转
  但若出现第三种模式，就无法通过行/列互换变成棋盘
- 所有列也只能是两种互为反转的模式

如何最少操作变成棋盘？我们不关心具体行/列顺序，只关心排列中：
- 有多少行需交换才能变成合法排列
- 有多少列需交换才能变成合法排列

我们目标是最小的`行交换次数 + 列交换次数`

技巧：只需检查首行、首列即可
- 棋盘的每一行都应和首行一样或互为反转
- 棋盘的每一列都应和首列一样或互为反转

最终最优解思路：
- 用 `Counter` 统计行模式，检查行的条件
- 用 `Counter` 统计列模式，检查列的条件
- 若条件不满足 → 返回 `-1`
- 否则，调用一个 `min_swaps` 辅助函数分别计算行与列的最少交换次数，然后相加

### 写法 1

```js
var movesToChessboard = function(board) {
    const n = board.length;

    const encode = (arr) => arr.join('');
    const countMap = new Map();

    for (let row of board) {
        const str = encode(row);
        countMap.set(str, (countMap.get(str) || 0) + 1);
    }

    const rowKeys = [...countMap.keys()];
    if (rowKeys.length !== 2) return -1;

    const [r1, r2] = rowKeys.map(str => str.split('').map(Number));
    for (let i = 0; i < n; i++) {
        if ((r1[i] ^ r2[i]) !== 1) return -1;
    }

    const r1Count = countMap.get(rowKeys[0]);
    const r2Count = countMap.get(rowKeys[1]);
    if (Math.abs(r1Count - r2Count) > 1) return -1;

    // Check columns
    const colMap = new Map();
    for (let j = 0; j < n; j++) {
        let col = [];
        for (let i = 0; i < n; i++) col.push(board[i][j]);
        const colStr = encode(col);
        colMap.set(colStr, (colMap.get(colStr) || 0) + 1);
    }

    const colKeys = [...colMap.keys()];
    if (colKeys.length !== 2) return -1;

    const [c1, c2] = colKeys.map(str => str.split('').map(Number));
    for (let i = 0; i < n; i++) {
        if ((c1[i] ^ c2[i]) !== 1) return -1;
    }

    const c1Count = colMap.get(colKeys[0]);
    const c2Count = colMap.get(colKeys[1]);
    if (Math.abs(c1Count - c2Count) > 1) return -1;

    const minSwaps = (line) => {
        let even = 0, odd = 0;
        for (let i = 0; i < n; i++) {
            if (line[i] !== i % 2) even++;
            if (line[i] !== (i + 1) % 2) odd++;
        }
        return n % 2 === 0 ? Math.min(even, odd) / 2 : ((line.filter(x => x === 1).length * 2 < n) ? even : odd) / 2;
    };

    return minSwaps(r1) + minSwaps(c1);
};
```
```python
class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        # 把每一行转为元组，方便后续作为字典键计数（因为 list 不能作为字典/Counter 的 key）
        # rows 是一个行模式列表
        rows = [tuple(row) for row in board]
        # 统计每种行模式出现次数，得到一个 Counter
        row_count = Counter(rows)
        # 检查是否存在两个合法互反行，合法的棋盘只能有两种行结构（如 [0,1,0,1] 和 [1,0,1,0]）
        # 如果不止 2 种行结构，就不可能转为合法棋盘 → return -1
        if len(row_count) != 2:
            return -1
        
        # 取出两种行模式
        # 检查 row1 和 row2 是否互为反转
        row1, row2 = row_count.keys()
        # 原理：x ^ y == 1 表示二进制位不同（0 和 1）
        # 利用 x ^ y == 1 来验证每个位置是否不同（异或为1 ⇨ 0和1不同）
        if not all(x ^ y == 1 for x, y in zip(row1, row2)):
            return -1
        
        # 两种行的数量差不能超过 1，否则无法交错排布（0101 或 1010）
        if abs(row_count[row1] - row_count[row2]) > 1:
            return -1
        
        # 对列做同样的检查
        # 遍历每一列 j，取出每行的 board[i][j] 拼成列元组
        cols = [tuple(board[i][j] for i in range(n)) for j in range(n)]
        # 统计列模式出现次数
        col_count = Counter(cols)
        
        # 列的逻辑与行完全相同：必须有且只有两种互反模式，且数量相差不超过 1
        if len(col_count) != 2:
            return -1
        
        col1, col2 = col_count.keys()
        # 检查两列模式是否互补，如果不是 → 返回 -1。
        if not all(x ^ y == 1 for x, y in zip(col1, col2)):
            return -1
            
        if abs(col_count[col1] - col_count[col2]) > 1:
            return -1

        # 最小交换次数计算函数
        # line 是当前待转换的行（或列）
        def min_swaps(line, n):
            # line 是某一模式（行或列）
            # 统计 line 中 1 的个数 ones，用来判断是否需要从 0 开始或 1 开始
            ones = sum(line)
            # 偶数长度：尝试两种排列起点，可以 0101… 或 1010… 开头，都可能
            # 需要尝试两种，取较小的
            if n % 2 == 0:
                # line[i] != i % 2 统计与理想模式（0,1,0,1…）不匹配的数量
                # line[i] != (i+1)%2 统计与另一个模式（1,0,1,0…）不匹配的数量
                # 取较小值后除以 2（因为一次交换修正两个位置）
                return min(
                    sum(line[i] != i % 2 for i in range(n)),    # 假设从 0 开始：010101
                    sum(line[i] != (i + 1) % 2 for i in range(n)) # 假设从 1 开始：101010
                ) // 2  
            else:
                # 奇数长度：起点唯一确定：如果 ones * 2 < n → 0 开始；否则 1 开始
                # 奇数长度棋盘中，多的那种数必须在偶数下标
                # target = 0 or 1 取决于哪种 bit 更多数，如果 1 比较多，目标就以 1 开始（10101...）；否则以 0 开始
                # 只尝试该一种排列，并数差异位 /2 得到交换次数
                target = 0 if ones * 2 < n else 1
                # 根据 target 统计与理想模式不匹配的数量，除以 2 得到最少交换次数
                return sum(line[i] != (i + target) % 2 for i in range(n)) // 2
        
        # 行方向：用 row1 模式计算需要的交换数
        # 列方向：用 col1 模式计算需要的交换数
        # 总操作次数 = 行方向最少交换数 + 列方向最少交换数
        return min_swaps(list(row1), n) + min_swaps(list(col1), n)
```

- 时间复杂度：`O(n²)`，遍历所有行列、每行列比对
- 空间复杂度：`O(n)`，用于存储每行、每列、`Counter`

### 写法 2

上一种解法用 `tuple + Counter` 检查行和列。但我们可以把行和列的 `0/1` 模式看作一个二进制数，用整数的位来表示：
- `rowMask`：第一行的模式作为基准（`bit0` 对应第 `0` 列，`bit1` 对应第 `1` 列…）
- `colMask`：第一列的模式作为基准
- 反码 `reverseRowMask`、`reverseColMask` 也容易通过按位取反得到

这样能在一次扫描里快速验证每行/每列是否匹配其中之一，且可直接用位运算统计模式里 `1` 的个数和错位数，效率更高

> 用整数掩码（`bitmask`）表示行和列模式，通过位运算判断结构合法性，并在合法的基础上贪心计算最少交换次数

最终思路：
- 首先将行列模式用位掩码编码，这样能快速判断模式合法性
- 预计算反码
- 遍历每行/每列，检查是否匹配两种模式之一，同时统计符合 `rowMask` 的行数、符合 `colMask` 的列数
- 根据奇偶性和位模式计算出最少交换次数
- 最后返回行和列交换次数之和，若非法则返回 `-1`

```python
class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        n = len(board)
        # 构建 rowMask 和 colMask
        rowMask = colMask = 0
        # 遍历第一行、第一列
        # 效果：用整数的二进制位存储第一行和第一列的模式
        for i in range(n):
            # board[0][i] << i：第0行的第 i 列放到第 i 位
            # |= 把对应位合并到 rowMask
            rowMask |= board[0][i] << i
            # board[i][0] << i：第 i 行的第0列放到第 i 位
            # 合并到 colMask
            colMask |= board[i][0] << i
        
        # 计算它们的反转掩码（即合法棋盘应有的互补行/列），通过按位异或取反
        # (1 << n) - 1：n 位全是 1 的掩码
        # ^ rowMask：按位异或得到反码（0→1, 1→0）
        # 这样方便后续快速比较
        reverseRowMask = ((1 << n) - 1) ^ rowMask
        reverseColMask = ((1 << n) - 1) ^ colMask

        # 统计每行每列的模式
        rowCnt = colCnt = 0
        # 外层 i 遍历行/列索引
        # 检查每一行和列是否只包含这两种掩码
        for i in range(n):
            currRowMask = currColMask = 0
            # 内层 j 把每一行、每一列转换为位掩码
            # - currRowMask：第 i 行的模式
            # - currColMask：第 i 列的模式
            for j in range(n):
                currRowMask |= board[i][j] << j
                currColMask |= board[j][i] << j
            
            # 每行必须是 rowMask 或 reverseRowMask 之一，否则不能构成棋盘 → return -1
            # 每列必须是 colMask 或 reverseColMask 之一，否则 return -1
            if currRowMask != rowMask and currRowMask != reverseRowMask or \
               currColMask != colMask and currColMask != reverseColMask:
                return -1
            
            # 记录与第一行/列相同的行数、列数（后续用来判断分布是否平衡，判断奇偶/交换用）
            rowCnt += currRowMask == rowMask  # 记录与第一行相同的行数
            colCnt += currColMask == colMask  # 记录与第一列相同的列数
        
        # 计算最少交换次数
        def getMoves(mask: int, count: int) -> int:
            # mask.bit_count()：统计 mask 里有多少个 1
            ones = mask.bit_count()
            # n 是奇数
            if n & 1:
                # 检查奇数棋盘的合法性：
                # - ones（模式中1的数量）必须满足：|n - 2*ones| == 1
                # - count（基准模式数量）也要满足：|n - 2*count| == 1
                # 若行/列中 1 和 0 的个数差值不是 1，或同类掩码的数量不平衡 → 不合法
                if abs(n - 2 * ones) != 1 or abs(n - 2 * count) != 1:
                    return -1
                
                # 使用位掩码 0xAAAAAAAA（奇偶位掩码）来判断哪个排列更少错位：
                # - 0xAAAAAAAA：101010...
                # - 0x55555555：010101...
                # 计算当前掩码与理想棋盘交错的匹配情况，差值除以 2 即为交换次数
                if ones == n // 2:
                    # 偶数位变为 1 的最小交换次数
                    # 算出与理想交替模式差异的位数，再除 2 得到最小交换次数
                    return n // 2 - (mask & 0xAAAAAAAA).bit_count()
                else:
                    # 奇数位应为 1 时：用 mask & 0x55555555
                    # 奇数位变为 1 的最小交换次数
                    return (n + 1) // 2 - (mask & 0x55555555).bit_count()
            else:
                # 如果 n 为偶数，则每一行中 1 与 0 的数目相等，且满足相邻行交替
                # 两种模式必须各出现一半（否则无法交错）
                if ones != n // 2 or count != n // 2:
                    return -1
                
                # 尝试从 0 开始 和 从 1 开始 两种交错排列
                # 选出错位最少的，除以 2 即为交换次数
                # 偶数位变为 1 的最小交换次数
                count0 = n // 2 - (mask & 0xAAAAAAAA).bit_count()
                # 奇数位变为 1 的最小交换次数
                count1 = n // 2 - (mask & 0x55555555).bit_count()

                # 取差异最少的方式作为最优交换策略
                return min(count0, count1)
        
        # 分别计算 行 和 列 所需的最小交换次数
        # 若任一部分不合法，直接返回 -1；否则返回总交换次数
        rowMoves = getMoves(rowMask, rowCnt)
        colMoves = getMoves(colMask, colCnt)
        return -1 if rowMoves == -1 or colMoves == -1 else rowMoves + colMoves
```

- 时间复杂度：`O(n²)`，其中 `n` 为矩阵的行数。只需要遍历矩阵一遍即可
- 空间复杂度：`O(1)`