# 56.合并区间

题目链接：[56.合并区间](https://leetcode.cn/problems/merge-intervals/)

## 题目大意

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start_i, end_i]`。请合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 

```js
Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].

Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

限制：
- 1 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti <= endi <= 10^4

## 解题

最直观的方法是：
- 不停地遍历所有区间，两两检查是否重叠
- 如果重叠就合并，继续重复直到没有新的合并产生
- 问题：这种方法可能要多次扫描，时间复杂度接近 `O(n²)`，当区间很多时效率太低

关键洞察 - 如果先把区间按照 `start` 升序排序，那合并就可以在`一次扫描`中完成：
- 排序后，前面的区间的 `start` 肯定 `≤` 后面的区间 `start`
- 扫描过程中，只要判断当前区间 `cur` 的 `start` 是否在上一个合并区间 `last` 的范围内（`cur[0] <= last[1]`）：
  - 如果是 → 合并：`last[1] = max(last[1], cur[1])`
  - 如果不是 → 没有重叠，直接把 `cur` 加入结果
- 这样只需`排序 + 一次线性扫描`

最优解
- 对 `intervals` 按 `start` 排序
- 新建结果列表 `res`，先放入排序后的第一个区间
- 从第二个区间开始扫描：
  - 与 `res[-1]`（上一个合并后的区间）比较：
    - 如果有重叠，更新结束位置
    - 如果没有重叠，直接加入结果
- 返回 `res`

```js
var merge = function(intervals) {
    let res = [];
    // 按区间的 start 升序排列
    intervals.sort((a, b) => a[0] - b[0]);
    res.push(intervals[0]);

    for (let i = 1; i < intervals.length; i++) {
        let cur = intervals[i];
        let last = res[res.length - 1];
        if (cur[0] <= last[1]) {
            last[1] = Math.max(last[1], cur[1]);
        } else {
            // 处理下一个待合并区间
            res.push(cur);
        }
    }
    return res;
};
```
```python
# 写法 1
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 初始化结果列表 res，用来保存合并后的区间
        res = []
        # 按照区间的起点 start 升序排序，确保后面的区间起点一定不小于前面的区间起点
        intervals.sort(key=lambda x: x[0])
        # 把排序后的第一个区间加入结果列表 res 作为起始基准
        res.append(intervals[0])
        # 从第二个区间开始（索引 1）依次扫描
        for i in range(1, len(intervals)):  
            # cur: 当前要处理的区间
            cur = intervals[i]
            # last: 当前结果列表中最后一个区间（最近合并出的区间）
            last = res[-1]

            # 如果 cur 的起点 cur[0] ≤ last 的终点 last[1]，说明有重叠：更新 last[1] 为 last[1] 和 cur[1] 中的较大值，合并区间
            if cur[0] <= last[1]:
                last[1] = max(last[1], cur[1])
            else:
                # 否则，说明没有重叠：直接把当前区间 cur 加入 res
                res.append(cur)
        
        # 返回合并后的区间列表 res
        return res

# 写法 2
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 按照每个区间的起点 x[0] 进行升序排序
        # 确保扫描时，重叠区间必然相邻
        intervals.sort(key=lambda x: x[0])
        # 初始化结果列表 res，用于存放合并后的区间
        res = []
        # 遍历排序后的每个区间 interval
        for interval in intervals:
            # 条件1：not res - 说明 res 还没有任何区间 → 直接加入当前区间
            # 条件2：res[-1][1] < interval[0] - 当前区间的起点在上一个合并区间的终点之后 → 没有重叠 → 直接加入
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            else:
                # 否则，说明当前区间 interval 和 res[-1] 有重叠 → 合并：更新 res[-1][1] 为两个区间结束值的最大值
                res[-1][1] = max(res[-1][1], interval[1])
        
        return res
```

- 时间复杂度：`O(nlogn)`
  - `n` 是输入区间的数量
  - 主导项是排序操作的时间复杂度 `O(nlogn)`
- 空间复杂度：`O(n)`，最坏情况下需存储所有的区间以及排序过程中的额外空间