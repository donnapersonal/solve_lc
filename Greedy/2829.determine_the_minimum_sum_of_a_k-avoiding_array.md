# 2829.k-avoiding 数组的最小总和

题目链接：[2829.k-avoiding 数组的最小总和](https://leetcode.cn/problems/determine-the-minimum-sum-of-a-k-avoiding-array/)

## 题目大意

给你两个整数 `n` 和 `k`

对于一个由不同正整数组成的数组，如果其中不存在任何求和等于 `k` 的不同元素对，则称其为 `k-avoiding` 数组

返回长度为 `n` 的 `k-avoiding` 数组的可能的最小总和

```js
Example 1:
Input: n = 5, k = 4
Output: 18
Explanation: Consider the k-avoiding array [1,2,4,5,6], which has a sum of 18.
It can be proven that there is no k-avoiding array with a sum less than 18.

Example 2:
Input: n = 2, k = 6
Output: 3
Explanation: We can construct the array [1,2], which has a sum of 3.
It can be proven that there is no k-avoiding array with a sum less than 3.
```

限制：
- 1 <= n, k <= 50

## 解题

题目简述
- 给定两个整数 `n` 和 `k`，要从正整数集合里选出 `n` 个不同的正整数，使得任意两个被选出的数之和 `≠ k`，且这 `n` 个数的总和最小
- 返回最小总和

### 思路 1：贪心 + 排除冲突对

观察条件：
- 不能存在 `a + b = k`
- 如果选择了某个数 `a`，则 `k - a` 就不能选
- 如若 `k = 7`，选了 `3`，那就不能再选 `4`，因为 `3 + 4 = 7`

贪心地从 `1` 开始选最小的正整数，如果遇到 `cur` 和之前选的某个 `a` 满足 `a + cur = k`，那就跳过，否则选入
因为我们是按递增顺序选，一定能保证总和最小

更进一步的简化 - 不需要每次 `O(n)` 遍历去检查，只要记录一个集合 `used` 存放已经选入的数，然后对于当前尝试的 `cur`： - 如果 `k - cur` 在 `used` 里，说明选它会和 `k - cur` 配对成 `k` → 跳过
- 否则，直接选它
- 这样就可以用 `O(1)` 判断，继续贪心往后

思路：
- 从 `1` 开始枚举
- 对于每个数字 `x`：
  - 如果 `k - x` 不在 `used` 中（即不会与 `x` 配对成和为 `k`），就可以加入
  - 否则跳过
- 重复直到找到 `n` 个数字
- 返回这些数字的总和

```js
var minimumSum = function(n, k) {
    const used = new Set();
    let res = 0, cur = 1;

    while (used.size < n) {
        if (!used.has(k - cur)) {
            used.add(cur);
            res += cur;
        }
        cur++;
    }

    return res;
};
```
```python
class Solution:
    def minimumSum(self, n: int, k: int) -> int:
        # used 是一个集合，用来存放 已经选入的数
        # 因为集合查找是 O(1)，方便后续快速判断
        used = set()
        # res 用来累加记录当前已经选入的数的总和，最终要返回它
        res = 0
        # cur 表示当前尝试选入的数，从最小的 1 开始
        cur = 1
        # 只要当前已经选入的数量还没达到 n，就继续尝试选新的数
        while len(used) < n:
            # 判断：如果 k - cur 不在 已经选入的 used 里，说明选入 cur 是安全的（不会和之前某个数凑成 k）
            if k - cur not in used:
                # 把 cur 选入集合 used，表示它是我们选中的一个合法数
                used.add(cur)
                # 把 cur 累加到 res，因为我们要最小总和，这里直接把每个选中的数相加
                res += cur
            
            # 无论是否选入，都要把 cur 往后递增，继续尝试下一个更大的数
            cur += 1
        
        # 当已经选入的数数量达到了 n，返回累加的最小总和
        return res
```

- 时间复杂度：`O(n)`，尽管循环可能稍多，但至多从 `1` 到 `2n` 枚举，仍是线性
- 空间复杂度：`O(n)` 用于记录已选元素

### 思路 2：贪心 + 等差数列求和

仔细分析条件： 如果 `a` 被选了，则 `k - a` 就不能选

关键观察：
- 在 `1` 到 `k-1` 之间，可能会出现互斥对：`(1, k-1)`、`(2, k-2)`、`(3, k-3)`…
- 只要我们在每一对中选择其中一个，限制条件就满足

且我们想要`最小总和`，那么：
- 在这些互斥对中，永远选择较小的那个数字（如选 `1` 而不是 `k-1`，选 `2` 而不是 `k-2`）
- 直到选满 `n` 个或这些较小数用完

把情况分两段讨论
- 情况 A：`n ≤ k/2`
  - 直接从 `1` 开始连续取 `n` 个，根本用不完 `k/2` 以内的数，不会冲突
  - → 直接用`等差数列求和公式`，快速算出 `1 + 2 + … + n`
- 情况 B：`n > k/2`
  - 那么我们会先取完 `1 ~ k/2` 这 `k/2` 个最小数，然后还要再选 `n - k/2` 个数
  - 接着选哪里？从 `k` 开始往后取，因为 `k` 和之前的任何小数相加都 `> k`，不会冲突
  - → 用`等差数列公式`求出从 `k` 开始的 `(n - k/2)` 个数之和

通过公式直接计算，不再一边循环一边累加，时间复杂度降为 `O(1)`

```js
var minimumSum = function(n, k) {
    if (n <= Math.floor(k / 2)) {
        return arithmeticSeriesSum(1, 1, n);
    } else {
        return arithmeticSeriesSum(1, 1, Math.floor(k / 2)) + arithmeticSeriesSum(k, 1, n - Math.floor(k / 2));
    }
};

var arithmeticSeriesSum = function(a1, d, n) {
    return (a1 + a1 + (n - 1) * d) * n / 2;
};
```
```python
class Solution:
    # 若只需前 n 个正整数（从 1 开始），且不会包含任何两个数之和为 k
    # 为什么这样可以？-> 若所有数 ≤ k // 2，任意两个数 a + b 都 < k，自然不会等于 k
    # 只需要从 1 到 n 这些最小的数就够了，不会产生互斥对
    # 所以直接从 1 开始选 n 个数即可，直接用公式算和
    def minimumSum(self, n: int, k: int) -> int:
        if n <= k // 2:
            # 首项 a1 = 1
            # 公差 d = 1（连续整数）
            # 项数 n
            # 等差数列求和公式：(首项 + 末项) * 项数 / 2
            return self.arithmeticSeriesSum(1, 1, n)
        else:
            # 否则，即 n > k/2：说明前 k/2 个最小的数字不够，需要再多取一些
            # 不能用超过 k // 2 的数对，否则可能出现冲突（两个数之和为 k）
            # 所以前 k // 2 个用 [1, 2, ..., k//2]（安全）
            # 剩下的跳过 k//2 + 1 ~ k - 1 这部分危险区域，从 k 开始继续选
            # 所以：
            # - 用等差数列求和选 [1, 2, ..., k//2] → 总共 k//2 项
            # - 然后从 k 开始往上选 n - k//2 项
            return self.arithmeticSeriesSum(1, 1, k // 2) + self.arithmeticSeriesSum(k, 1, n - k // 2)
    
    # 定义一个通用函数，用来计算任意等差数列的前 n 项和
    def arithmeticSeriesSum(self, a1: int, d: int, n: int) -> int:
        # 这是标准的等差数列求和公式：sum = n/2 × (2a+(n−1)d)
        # 其中：
        # - a 是首项
        # - d 是公差（本题中始终为 1）
        # - n 是项数
        # (a1 + a1 + (n - 1) * d) 就是 (首项 + 末项)
        # 再乘 n 除以 2 得到和
        # 因为 a1, d, n 都是整数，用 // 2 整除保证结果是整数
        return (a1 + a1 + (n - 1) * d) * n // 2
```

- 时间复杂度：`O(1)`，只计算数学公式
- 空间复杂度：`O(1)`