# 621.任务调度器

题目链接：[621.任务调度器](https://leetcode.cn/problems/task-scheduler/)

## 题目大意

给一个用字符数组 `tasks` 表示的 `CPU` 需执行的任务列表，用字母 `A` 到 `Z` 表示，以及一个冷却时间 `n`。每个周期或时间间隔允许完成一项任务。任务可按任何顺序完成，但有一个限制：两个`相同种类`的任务之间必须有长度为 `n` 的冷却时间

返回完成所有任务所需要的最短时间间隔 

```js
Example 1:
Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.

After completing task A, you must wait two intervals before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th interval, you can do A again as 2 intervals have passed.

Example 2:
Input: tasks = ["A","C","A","B","D","B"], n = 1
Output: 6
Explanation: A possible sequence is: A -> B -> C -> D -> A -> B.

With a cooling interval of 1, you can repeat a task after just one other task.

Example 3:
Input: tasks = ["A","A","A", "B","B","B"], n = 3
Output: 10
Explanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.

There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.
```

限制：
- 1 <= tasks.length <= 10^4
- tasks[i] is an uppercase English letter.
- 0 <= n <= 100

## 解题

最初暴力思路
- 想法：按照频率排序，每次挑出最多的任务先执行，然后隔 `n` 单位再执行相同任务
- 可以用`优先队列（大根堆）`模拟，逐轮取出任务执行、间隔、重新放回
- 复杂度：`O(Tlogk)`，`T` 是总任务数，`k` 是种类数，可以通过但不够简洁
- 缺点：要真实模拟调度，代码复杂

关键在于`决定整体调度长度的瓶颈`：
- 出现次数最多的任务决定了最小时间框架
- 假设频率最高的任务出现 `max_count` 次，那么至少需把它们均匀排开，中间用别的任务或空闲补足

推导：
- 最大频率 `max_count` 的任务之间必须有间隔 `n` → 至少 `(max_count-1)` 个间隔块，每块长度 `n+1`（包括一个高频任务和 `n` 个空位），最后再加上最后一批最大频率的任务数 `max_count_tasks` -> `(max_count−1)×(n+1)+max_count_tasks`
- 但是，如果任务总数比这个公式大（说明其他任务填满了空闲位），那么结果就是任务总数
- 最终时间：`min_time = max(公式时间,任务总数)`

最优解思路：
- 用`哈希表`统计每种任务的出现次数
- 找到最大出现次数 `max_count`，以及出现次数等于 `max_count` 的任务数 `max_count_tasks`
- 套用公式 `(max_count-1)*(n+1)+max_count_tasks` 与总任务数取最大值

```js
var leastInterval = function(tasks, n) {
    // 1. 统计每个任务的频率
    const taskCounts = new Map();
    
    for (const task of tasks) {
        taskCounts.set(task, (taskCounts.get(task) || 0) + 1);
    }

    // 2. 找到任务的最大频率
    const maxCount = Math.max(...taskCounts.values());

    // 3. 计算出现次数为最大频率的任务数
    let maxCountTasks = 0;
    for (const count of taskCounts.values()) {
        if (count === maxCount) maxCountTasks++;
    }

    // 4. 计算最短时间
    const minTime = (maxCount - 1) * (n + 1) + maxCountTasks;

    // 5. 返回两者中的最大值：要么是所有任务的数量，要么是计算出的最短时间
    return Math.max(minTime, tasks.length);
};
```
```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        # 使用 collections.Counter 统计每个任务的频率。得到一个字典：任务 → 出现次数
        task_counts = Counter(tasks)
        # 找到任务的最大频率
        # 最大频率的任务决定了任务调度的最短时间框架，因为这些任务之间需插入冷却时间
        max_count = max(task_counts.values())
        # 统计有多少个任务的频率等于 max_count，记作 max_count_tasks
        # 如 A 出现 3 次，B 也出现 3 次 → max_count_tasks = 2
        # 具有最大频率的任务可能会占用冷却时间的最后一列
        max_count_tasks = sum(1 for count in task_counts.values() if count == max_count)

        # 4. 计算最短时间
        # (max_count - 1) * (n + 1)：
        # - (max_count - 1)：最大频率任务可以分为 max_count - 1 个间隔(除了最后一组之外的组数)，每个间隔需要冷却时间。为什么只考虑 (max_count−1)？--> 因为最后一次出现的 A 不需要后续的冷却时间，冷却时间只需要出现在前 (max_count−1) 次任务之间，如：A ___ A ___ A…
        # - (n + 1)：每个间隔长度是 n（冷却时间）加上执行一个任务的时间
        # (max_count - 1) * (n + 1) 表示将所有高频任务分组放置，留出冷却时间
        # 再加上出现次数为 max_count(表示最后一组的任务数) 的任务数


        # 最大化利用冷却时间：
        # - 该公式中的 max_count - 1 个完整区间，每个区间之间要有足够的冷却时间 n
        # - 这些区间之间要么填入其他任务，要么填入 idle（如果任务种类不足以填满空位，则会有 idle），保证最大频率任务的间隔不小于 n
        # max_count_tasks 的意义：
        # - 处理最后一组最高频任务，最高频任务可能有多个（如 A 和 B 的频率相同）
        # - 为什么要加上这部分？因为这些任务会占据框架的最后一部分
        min_time = (max_count - 1) * (n + 1) + max_count_tasks
        # 如果 min_time 比任务总数 len(tasks) 小，说明其他任务已经填满了空闲时间，实际时间就是 len(tasks)
        # 返回两者中的较大值，保证结果正确
        return max(min_time, len(tasks))
```

- 时间复杂度：`O(n)`，`n` 是任务列表 `tasks` 的长度
  - 统计任务频率 `O(n)`
  - 计算 `max_count` 和 `max_count_tasks` 也需要 `O(n)` 时间
  - 整个算法在任务总数 `n` 下能够在 `O(n)` 时间内完成
- 空间复杂度：`O(1)`，因为最多只有 `26` 个大写英文字母，因此哈希表 `task_counts` 的空间复杂度是常数级别的 `O(26)`，可以近似认为是 `O(1)`