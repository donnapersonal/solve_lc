# 3191.使二进制数组全部等于 1 的最少操作次数 I

题目链接：[3191.使二进制数组全部等于 1 的最少操作次数 I](https://leetcode.cn/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/)

## 题目大意

给定一个字符串 `s`，检查是否能重新排布其中的字母，使得两相邻的字符不同

返回 `s` 的任意可能的重新排列；若不可行，返回空字符串 `""`

```js
Example 1:
Input: nums = [0,1,1,1,0,0]
Output: 3
Explanation:
We can do the following operations:
Choose the elements at indices 0, 1 and 2. The resulting array is nums = [1,0,0,1,0,0].
Choose the elements at indices 1, 2 and 3. The resulting array is nums = [1,1,1,0,0,0].
Choose the elements at indices 3, 4 and 5. The resulting array is nums = [1,1,1,1,1,1].

Example 2:
Input: nums = [0,1,1,1]
Output: -1
Explanation:
It is impossible to make all elements equal to 1.
```

限制：
- 3 <= nums.length <= 10^5
- 0 <= nums[i] <= 1

## 解题

最初思路（暴力/回溯）
- 从左到右尝试翻转或不翻转，每个位置都有两种决策，复杂度爆炸
- 每次翻转要更新接下来三个元素，状态传递困难
- 缺点：时间复杂度太高（高达 O(2^n)），回溯搜索会超时

贪心启发
- 从左往右扫描：
  - 当走到位置 `i` 时，前面已经处理过，无法再改变
  - 如果当前 `nums[i]`（在所有已执行翻转操作的影响下）是 `0`，须从 `i` 开始翻转一个长度为 `3` 的区间，才能把这个位置变成 `1`
  - 否则不用翻转
- 这样一旦决定了在 `i` 翻转或不翻转，就不需要回头，确保最少翻转

贪心成立，因为：
- 我们只能用长度为 `3` 的窗口翻转，位置 `i` 一旦不对，只能在 `i` 开头的翻转来修正
- 不延后操作，否则就无法再修改 `i`
  
### 思路 1: 贪心 + 滑动窗口

翻转影响的记录
- 翻转的影响会持续 `3` 个位置，之后就过期了
- 需要高效记录：
  - 当前 `i` 位置被多少次翻转影响（奇偶），计算当前位置实际的 `0/1`
  - 过去超过 `3` 个位置的翻转已过期，需移除它们的影响
- 可以用：
  - 一个 `flip` 状态是当前滑动窗口中“还在影响范围内”的翻转次数的奇偶性（`0=未翻转`，`1=已翻转奇数次`）
  - 一个队列 `que` 存放每次翻转的起始位置，当 `i` 前面的翻转过期，就从队列中弹出并更新 `flip`
  
最终贪心 + 滑动窗口实现
- 从 `i=0` 到 `n-1`：
  - 如果有过期的翻转操作，移出队列并更新 `flip`
  - 如果当前位置经过 `flip` 后还是 `0`，必须翻转：
    - 检查能否从 `i` 翻转 `3` 个元素，否则返回 `-1`
    - 翻转数 `+1`，记录位置 `i` 入队，`flip` 状态取反
- 最后返回总翻转次数


```js
var minOperations = function(nums) {
    const n = nums.length;
    let flips = 0, flip = 0;
    const que = [];

    for (let i = 0; i < n; i++) {
        if (que.length && que[0] + 3 <= i) {
            que.shift();
            flip ^= 1;
        }

        if ((nums[i] ^ flip) === 0) {
            if (i + 2 >= n) return -1;
            flips++;
            que.push(i);
            flip ^= 1;
        }
    }

    return flips;
};
```
```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        # flips：记录当前已经执行的翻转次数
        flips = 0
        # flip：当前索引位置的累积翻转状态（0=没被翻转奇数次，1=被翻转了奇数次）
        # 用于计算当前位置实际是 0 还是 1
        flip = 0
        # que：队列，用来存储每一次翻转操作的起始位置
        # 这样我们可以知道某个翻转是否已经过了 3 个位置，影响过期后就要移除
        que = deque()
        # 从左到右遍历每一个位置 i
        for i in range(n):
            # 检查队首的翻转是否已过期：若队首的翻转起点 que[0] 距离当前 i 已 >= 3，就说明它的影响不再作用于当前位置
            if que and que[0] + 3 <= i:
                # 将过期的翻转从队列中弹出，同时更新 flip：之前的翻转贡献不再有效，所以 flip 状态要取反（移除它的影响）
                que.popleft()
                flip ^= 1
            
            # nums[i] ^ flip 计算当前位置经过翻转后真实的值：如果结果是 0，说明当前是 0，需要翻转
            if nums[i] ^ flip == 0:
                # 在 i 位置翻转会影响 i, i+1, i+2，所以须确保 i+2 < n
                # 如果不够 3 个元素，说明无法完成操作，直接返回 -1
                if i + 2 >= n:
                    return -1
                
                # 执行翻转，计数 +1
                flips += 1
                # 记录这次翻转操作起始位置到队列中
                que.append(i)
                # 同时 flip 状态取反（因为从这里开始的后续位置都会受到新翻转的影响）
                flip ^= 1
        
        # 循环结束，返回总翻转次数 flips
        return flips
```

- 时间复杂度：`O(n)，每个位置处理一次，队列操作均摊 `O(1)`
- 空间复杂度：`O(n)`，因为需记录每个翻转的起点，最多队列存储 `O(n/3)` 个翻转起点，整体仍是线性

### 思路 2: 贪心算法 + 原地模拟翻转

观察翻转的特点：
- 翻转操作只能影响连续的 `3` 个位置
- 当扫描到位置 `i` 时，如果 `nums[i]` 仍是 `0`，就须从 `i` 开始翻转，否则以后就无法再改变它（因为翻转的起点都在后面，无法再影响 `i`）

贪心结论：
- 从左到右扫描：
  - 遇到 `0` → 立即从这里翻转 `3` 个元素
  - 遇到 `1` → 不用操作，继续
- 这种方法保证最少操作：因为每个位置只在第一次遇到 `0` 时才翻转一次，后面不再重复操作

验证边界
- 当位置 `i` 是 `0` 时，需翻转 `i`, `i+1`, `i+2`，须保证 `i+2 < n`，否则无法翻转
- 如果不满足，直接返回 `-1`

模拟：直接修改原数组 `nums[i] ^= 1`，不用额外记录 `flip` 队列

实际操作过程如下：
- 依次遍历数组 `nums` 中的每个元素 `nums[i]`，如果 `nums[i]=1`，则跳过；如果 `nums[i]=0`，则将连续的 `3` 个元素 `nums[i]`, `nums[i+1]`, `nums[i+2]` 进行反转，同时反转统计次数加 `1`
- 直到当前元素后续的元素不足 `3` 个，此时无法进行反转，如果此时仍然存在 `nums[i]=0 `的情形，则返回 `−1`，最终返回总反转次数

```js
var minOperations = function(nums) {
    let n = nums.length;
    let res = 0;
    for (let i = 0; i < n; i++) {
        if (nums[i] === 0) {
            if (i > n - 3) return -1;
            nums[i] ^= 1;
            nums[i + 1] ^= 1;
            nums[i + 2] ^= 1;
            res++;
        }
    }
    return res;
};
```
```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        # 从左到右遍历数组中每个位置 i
        for i in range(n):
            # 判断当前位置的值：
            # - 如果是 1，说明不需要翻转，继续下一个位置
            # - 如果是 0，需翻转来修正
            if nums[i] == 0:
                # 边界检查：
                # 从 i 开始需要翻转 i, i+1, i+2，因此必须保证 i <= n-3，即后面至少有 2 个元素
                # 如果不够，直接返回 -1，表示无解
                if i > n - 3:
                    return -1
                
                # 翻转连续的 3 个位置：
                # - ^= 1 表示按位异或，0→1，1→0
                # - 直接在原数组上修改，避免额外空间开销
                nums[i] ^= 1
                nums[i+1] ^= 1
                nums[i+2] ^= 1
                # 成功执行了一次翻转操作，操作数加 1
                res += 1
        
        # 完成遍历后，返回累计的最少操作次数
        return res
```

- 时间复杂度：`O(n)`，其中 `n` 表示给定的数组 `nums` 的长度，只需遍历一遍数组即可
- 空间复杂度：`O(1)`