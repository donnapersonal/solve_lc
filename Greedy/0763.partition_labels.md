# 763.划分字母区间

题目链接：[763.划分字母区间](https://leetcode.cn/problems/partition-labels/)

## 题目大意

给你一个字符串 `s`，要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 

返回一个表示每个字符串片段的长度的列表

```js
Example 1:
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits s into less parts.

Example 2:
Input: s = "eccbbbbdec"
Output: [10]
```

限制：
- 1 <= s.length <= 500
- s consists of lowercase English letters.

## 解题

最初的朴素思路 - 我们想要的分割满足：同一个字母不能跨越不同的分段。最直接的方式是：
- 从左到右遍历，尝试分割
- 但每遇到一个字母时，必须确认它的最后一次出现位置，否则贸然分割就可能把同一个字母分到两个段
- 如果只依赖当前字符的第一次出现，很容易提前切分，导致后面同样的字符跑到下一个段里，违反要求
- 问题：如果在遍历时不知道每个字符的最后出现位置，就没法知道什么时候可以“安全地切割”

这里可以使用`贪心算法`
- 为什么是贪心算法？-- 贪心算法的核心思想是在每一步都选择当前最优解，希望通过局部最优解的选择能够得到全局最优解
- 在这道题中，每个字符只能在一个片段中出现一次，因此每个片段的分割点可以通过每个字符的最后出现位置来确定

贪心策略：对于每个字符，将片段的结束位置扩展到该字符的最后出现位置，这样可以确保该片段中包含该字符的所有出现。通过这种方法，可以保证每个字符都只出现在一个片段中

改进思路
- 为了避免重复检查，可以`预处理`：先记录字符串中每个字符 最后一次出现的位置
- 这样，当从左到右遍历时：
  - 对于当前位置 `i` 的字符 `s[i]`，我们知道它的`最后出现位置`是 `last_index[s[i]]`
  - 这个字符须包含在当前分段中，所以当前分段的右边界至少要延伸到这个最后出现的位置
- 用变量 `end` 来维护当前分段的最远右边界：`end = max(end, last_index[s[i]])`

局部最优到全局最优：在遍历过程中，一旦当前索引 `i` 等于该片段的结束位置 `end`，就确定了一个片段，然后继续处理后面的字符，寻找下一个片段。这样通过局部的最优分割点逐步得到全局最优的片段划分

思路：
- 记录每个字符最后出现的位置：首先遍历整个字符串，记录每个字符最后一次出现的索引位置
- 划分片段：
  - 再次遍历字符串，用两个指针 `start` 和 `end` 来确定当前片段的开始和结束位置
  - 对于当前字符，将 `end` 更新为该字符的最后出现位置
  - 若遍历到的位置等于 `end`，则可以确定一个片段，将该片段的长度加入结果列表
- 继续下一个片段：更新 `start` 为当前索引的下一个位置，继续寻找下一个片段


```js
var partitionLabels = function(s) {
    let n = s.length;
    // 存储每个字符的最后出现位置
    const lastIndex = {}, res = [];
    // 第一次遍历，记录每个字符的最后出现位置
    for (let i = 0; i < n; i++) {
        lastIndex[s[i]] = i;
    }

    let start = 0, end = 0;
    // 第二次遍历，根据最后出现位置划分片段
    for (let i = 0; i < n; i++) {
        // 更新当前片段的结束位置
        end = Math.max(end, lastIndex[s[i]]);  
        // 当遍历到片段的结束位置
        if (i === end) {  
            // 记录片段长度
            res.push(end - start + 1);  
            start = i + 1;  // 更新片段的开始位置
        }
    }

    return res;
};
```
```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        res = []
        # 用字典推导式预处理每个字符的最后出现位置
        # enumerate(s) 会返回 (index, char) 对
        # 后面的赋值会覆盖前面相同字符的下标，意味着最后一次更新的索引就是该字符在字符串中的最后一次出现位置
        last_index = {c: i for i, c in enumerate(s)}
        # start：当前分段的起点
        # end：当前分段的最远右边界
        start, end = 0, 0
        for i in range(len(s)): 
            # 对于当前位置 i 的字符 s[i]，查找它最后出现的位置 last_index[s[i]]
            # 更新 end 为这两者的最大值，表示当前分段至少要延伸到这个位置
            end = max(end, last_index[s[i]])
            # 如果当前下标 i 刚好等于当前分段的最远右边界 end：说明从 start 到 end 范围内的所有字符都被完整覆盖，这一段可以安全分割
            if i == end:
                # 计算当前段的长度：end - start + 1，并添加到 res 中
                res.append(end - start + 1)
                # 更新下一段的起点为当前段右边界的下一个位置
                start = i + 1
        
        return res
```

- 时间复杂度：`O(n)`，其中 `n` 是字符串的长度
  - 第一次遍历：记录每个字符最后出现的位置，`O(n)`
  - 第二次遍历：确定分割点，`O(n)`
  - 所有操作都是线性的，总时间复杂度为 `O(n)`
- 空间复杂度：`O(1)`
  - `JS` 解法：使用固定大小的数组（`26`个字母）
  - `Python` 解法：使用字典存储字符位置
  - 由于字符集是固定的（`26` 个小写字母），空间复杂度是常数级的
  - 结果列表 `res` 的空间复杂度可以忽略不计