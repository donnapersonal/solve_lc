# 767.重构字符串

题目链接：[767.重构字符串](https://leetcode.cn/problems/reorganize-string/)

## 题目大意

给定一个字符串 `s`，检查是否能重新排布其中的字母，使得两相邻的字符不同

返回 `s` 的任意可能的重新排列；若不可行，返回空字符串 `""`

```js
Example 1:
Input: s = "aab"
Output: "aba"

Example 2:
Input: s = "aaab"
Output: ""
```

限制：
- 1 <= s.length <= 500
- s consists of lowercase English letters.

## 解题

最初的朴素思路
- 想把相同的字符分开，避免相邻
- 直觉上，如果某个字符的数量特别多，超过了 “能被间隔开的最大容量”，那就无解。如 `"aaaaab"（5个a 1个b）`，无论如何排列都会有相邻的 `a`
- 如何检查？- 如果某个字符的数量大于 `(n+1)//2`（数组的“半数上取整”），那就一定无解

如何排列字符？
- 如果数量都不超标，那就可通过`贪心`来摆放：
  - 把出现次数最多的字符先摆在“间隔开的位置”（如 `0,2,4,…`）
  - 剩下的字符再依次填充到空位
  
> 为什么这样贪心是对的？
> - 因为把高频字符尽量分散在最稀疏的位置，能最大化降低冲突
> - 当这些位置填满后，剩下的字符数量一定足以填充空隙

### 思路 1: 贪心 + 哈希

实现思路：
- 统计每个字符出现次数，检查是否有超标
- 对字符按出现次数降序排列，从多到少依次放置：
  - 先填充 `index = 0, 2, 4…` 的偶数位
  - 如果放满了，就从 `index = 1, 3, 5…` 的奇数位继续填
- 这样保证了相同字符之间尽量分散，且不会出现相邻相同的情况

```js
var reorganizeString = function(s) {
    const charCount = new Map();
    let maxCount = 0, maxChar = '';
    // 统计字符频率
    for (const char of s) {
        charCount.set(char, (charCount.get(char) || 0) + 1);
        if (charCount.get(char) > maxCount) {
            maxCount = charCount.get(char);
            maxChar = char;
        }
    }

    // 如果最高频率字符的出现次数超过 (n+1)/2，无法重构
    if (maxCount > (s.length + 1) / 2) return "";

    // 构建结果数组
    const res = new Array(s.length);
    let index = 0;

    // 先放置出现次数最多的字符
    for (let i = 0; i < maxCount; i++) {
        res[index] = maxChar;
        index += 2;
        if (index >= s.length) index = 1;
    }
    charCount.delete(maxChar);

    // 放置其他字符
    for (const [char, count] of charCount) {
        for (let i = 0; i < count; i++) {
            if (index >= s.length) index = 1;
            res[index] = char;
            index += 2;
        }
    }
    
    return res.join('');
};
```
```python
class Solution:
    def reorganizeString(self, s: str) -> str:
        # n 是字符串长度，后面会用来判断最大频率是否允许，以及初始化结果数组
        n = len(s)
        # 用 collections.Counter 统计每个字符出现的次数，结果是一个字典，键是字符，值是频率
        char_counts = Counter(s)
        # 找到出现次数最多的字符的次数 max_count
        max_count = max(char_counts.values())
        # 关键判定：如果某个字符出现次数 max_count 超过 (n+1)//2，就不可能重新排列出相邻不同的字符串，直接返回空字符串
        if max_count > (n + 1) // 2:
            return ""
        
        # 始化一个长度为 n 的列表 res，用来按位置填充字符，最后再拼接成字符串
        res = [''] * n
        # index 表示当前要填充的位置，从0开始，先填偶数位
        index = 0
        # 对 char_counts 按频率降序排序：char 是字符，count 是出现次数
        # 这样可先处理频率最高的字符，尽量先分散摆放
        for char, count in sorted(char_counts.items(), key=lambda x: -x[1]):
            # 对当前字符，根据它的出现次数 count，循环填充多次
            for _ in range(count):
                # 如果偶数位置已经填满 (index >= n)，就从 index = 1 开始填充奇数位置
                if index >= n:
                    index = 1
                # 在当前 index 位置放置 char
                # 从 index = 0 开始，将字符填入 res 数组的偶数位置。我们先从偶数位开始填充，因为这是在频率最高字符的情况下，最理想的分配方式
                res[index] = char
                # 向后移动两个位置，保证相同字符之间至少隔一个位置，避免相邻
                index += 2
        
        # 把列表 res 拼接成字符串返回
        return ''.join(res)
```

- 时间复杂度：`O(n+ klogk)`，`n` 是字符串 `s` 的长度，`k` 为字符集合的大小(本题字符均为小写字母，所以 `k=26`)
  - 使用 `Counter(s)` 需要遍历整个字符串一次，时间复杂度为 `O(n)`
  - 使用 `max(char_counts.values())` 需遍历字典的值，时间复杂度为 `O(k)`，其中 `k` 是不同字符的数量（最多为 `26`）
  - 排序字符（仅 `Python` 版本）：`O(k log k)`，由于 `k` 是常数，所以 `O(k log k)` 可以看作 `O(1)`
  - 构建结果字符串：`O(n)`，这部分的时间复杂度取决于字符总数
- 空间复杂度：`O(n+k)`
  - 哈希表/计数器：`O(k)`，其中 `k ≤ 26`
  - 结果数组/列表：`O(n)`
  - 如果不考虑返回值的空间，`C++` 为 `O(k)`

### 思路 2: 贪心 + 最大堆

更灵活的贪心：使用`最大堆`
思考：我们每次都应该选出当前剩余频率最高的两个不同字符依次放入，避免相邻冲突

关键操作：
- 统计每个字符频率
- 使用`最大堆（优先队列）`按频率排序，每次取出频率最高的字符放入结果
- 但如果连续放相同字符会冲突，所以需要一个缓冲：
  - 每次放出一个字符后，把它的频率减 `1`
  - 等到下一轮时再把它重新放回堆里（如果它还剩余）

为何这样做是最优
- 每次都取当前剩下最多的字符，保证高频字符被尽早分散开
- 使用堆动态更新，避免一次性排定位置，不论字符集大小都通用

- 最终复杂度
  - 构建堆 O(k)，k 为不同字符数
  - 每次取出和插入堆元素，时间 O(n log k)，但 k 很小（26），所以几乎是 O(n)
  - 空间 O(n) 用于结果，O(k) 用于堆

```js
var reorganizeString = function(s) {
    let freq = new Map();
    // 统计字符频率
    for (let char of s) {
        freq.set(char, (freq.get(char) || 0) + 1);
    }
    let maxHeap = [];
    // 将字符和频率放入最大堆
    for (let [char, count] of freq.entries()) {
        maxHeap.push([count, char]);
    }
    // 将数组转为最大堆
    maxHeap.sort((a, b) => b[0] - a[0]);
    let res = [], prev = null;
    while (maxHeap.length) {
        let [count, char] = maxHeap.shift();
        res.push(char);
        if (prev) {
            maxHeap.push(prev);
            maxHeap.sort((a, b) => b[0] - a[0]);  // 保持最大堆
        }
        if (count > 1) {
            prev = [count - 1, char];  // 记录当前字符，减少次数
        } else {
            prev = null;
        }
    }
    // 如果不能重新排列成有效字符串，返回空字符串
    return res.length === s.length ? res.join('') : '';
};
```
```python
class Solution:
    def reorganizeString(self, s: str) -> str:
        # 使用 Counter 统计每个字符出现的频率
        # 例如 s = "aab" → freq = {'a':2, 'b':1
        freq = Counter(s)
        # 创建一个空列表，用作 最大堆
        # Python 默认是最小堆，所以我们后面会把频率取负数来实现最大堆
        max_heap = []
        # 遍历每个字符及其频率：
        # - 用 (-count, char) 入堆，频率取负数，这样堆顶是最大频率
        # - 入堆后 max_heap 就是按频率从大到小排序的优先队列
        for char, count in freq.items():
            heapq.heappush(max_heap, (-count, char))
        
        # 用于记录上一次取出的字符及其剩余频率：
        # - prev_count 是该字符剩余的负数频率
        # - prev_char 是该字符本身
        # 初始为空
        prev_count, prev_char = 0, ''
        # 用于存放最终结果的字符序列
        res = []
        # 当堆里还有字符时，继续安排
        while max_heap:
            # 取出当前频率最高的字符 char，count 是它的负频率
            count, char = heapq.heappop(max_heap)
            # 把这个字符加到结果序列中
            res.append(char)
            # 检查上一次取出的字符是否还有剩余频率（prev_count < 0 表示还有剩余）
            # 如果有，就把它重新入堆，以便后续继续使用
            if prev_count < 0:
                heapq.heappush(max_heap, (prev_count, prev_char))
            
            # 更新 prev_count 和 prev_char：
            # - 每次弹出字符后将其剩余次数减少 1（即 count + 1），因为用的是负频率，count + 1 相当于消耗掉一次使用的频率
            # - 保存当前字符作为上一次取出的，等下一轮再入堆
            prev_count, prev_char = count + 1, char
        
        # 如果最后结果长度和原字符串长度不一致，说明无法满足条件（通常发生在有字符频率过高时）
        # 返回 "" 表示无解
        if len(res) != len(s):
            return ""
        
        # 把 res 列表拼接成字符串返回
        return ''.join(res)
```

- 时间复杂度：`O(n)`
  - 统计字符频率、构建堆、处理堆的时间复杂度分别为 `O(n)`、`O(klogk)` 和 `O(nlogk)`
  - 因为 `k` 是不同字符的数量（固定的常数 `26`），可以忽略与 `k` 相关的复杂度，因此总的时间复杂度为：`O(n)`
- 空间复杂度：`O(n)`
  - `Counter` 对象：`O(k)`，存储每个字符的频率
  - 最大堆：`O(k)`，存储每个字符及其频率
  - 结果列表：`O(n)`，存储重组后的字符串
  - 其他变量（如 `prev_count`, `prev_char`）：`O(1)`
  - 总空间复杂度：`O(n + k) = O(n)`，因为 `k` 最大为 `26`，是一个常数