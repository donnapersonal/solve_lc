# 738.单调递增的数字

题目链接：[738.单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

## 题目大意

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是单调递增的

给定一个整数 `n`，返回小于或等于 `n` 的最大数字，且数字呈单调递增 

```js
Example 1:
Input: n = 10
Output: 9

Example 2:
Input: n = 1234
Output: 1234

Example 3:
Input: n = 332
Output: 299
```

限制：
- 0 <= n <= 10^9

## 解题

最直观的暴力思路
- 从 `n` 开始，依次往下减，直到遇到第一个满足「单调不减」的数为止
- 检查一个数是否单调不减需要 `O(d)(d 是 n 的位数)` 时间，最坏可能要尝试很多次，整体效率非常低
- 问题：当 `n` 比较大时，效率不可接受

优化思路——从高位到低位分析
- 想象 `n` 的每一位，如果要满足单调不减，必须保证：`s[0] <= s[1] <= s[2] <= ... <= s[n-1]`
- 如何构造 `≤ n` 的最大数？-> 从左到右遍历，如果发现`某一位 s[i] < 前一位 s[i-1]`，那么从 `i-1` 这一位开始，后面的数就不满足单调性了

如果出现 `s[i] < s[i-1]`：
- 直接把 `s[i-1] - 1`，然后把 `i` 及其后面的位全部变成 `9`，确保结果尽量大且不会再违背单调不减
- 但，注意：`s[i-1] - 1` 后，可能又小于前一位，所以需继续向前检查，因此可从右往左遍历，发现问题就立即回退并标记后面要变 `9`

因此得到最优解思路：
- 遍历方向：`从右向左`，便于一旦发现递减就回退修改前面的数
- 最终处理：从第一个「破坏单调性」的位置开始，后面全部置为 `9`

```js
var monotoneIncreasingDigits = function(n) {
    let s = String(n).split('');
    let mark = s.length;

    for (let i = s.length - 1; i > 0; i--) {
        if (s[i] < s[i - 1]) {
            mark = i;
            s[i - 1] = String(Number(s[i - 1]) - 1);
        }
    }

    for (let i = mark; i < s.length; i++) {
        s[i] = '9';
    }

    return Number(s.join(''));
};
```
```python
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        # 将整数 n 转成字符列表，方便按位修改
        s = list(str(n))
        slen = len(s)
        # 用来标记从哪一位开始要改成 9，初始默认全不改
        mark = slen
        # 从右往左遍历，检查相邻的两位是否满足单调不减
        # i 从 n-1 到 1
        for i in range(slen - 1, 0, -1):
            # 如果发现当前位 < 左边一位，破坏了单调递增性
            if s[i] < s[i-1]:
                # 记录要从 i 开始把后面都改成 9
                mark = i
                # 把左边那位减 1 来修正
                s[i-1] = str(int(s[i-1]) - 1)
                # 注意：这里不用立即回退，因为后续 i-1 还会继续在循环中检查上一位是否需要继续调整
        
        # 把 mark 及之后的所有位都改成 '9'，保证结果最大
        for i in range(mark, slen):
            s[i] = '9'
        
        # 把修改后的字符列表拼接回整数返回
        return int(''.join(s))
```

- 时间复杂度：`O(logn)`，其中 `O(logn)` 表示数字 `n` 的位数，遍历 `O(logn)` 的时间即能构造出满足条件的数字
- 空间复杂度：`O(logn)`，需要 `O(logn)` 的空间存放数字 `n` 每一位的数字大小