# 3408.设计任务管理器

题目链接：[3408.设计任务管理器](https://leetcode.cn/problems/design-task-manager/)

## 题目大意

一个任务管理器系统可以让用户管理他们的任务，每个任务有一个优先级。这个系统需要高效地处理添加、修改、执行和删除任务的操作

请你设计一个 TaskManager 类：
- TaskManager(vector<vector<int>>& tasks) 初始化任务管理器，初始化的数组格式为 [userId, taskId, priority] ，表示给 userId 添加一个优先级为 priority 的任务 taskId 
- void add(int userId, int taskId, int priority) 表示给用户 userId 添加一个优先级为 priority 的任务 taskId ，输入 保证 taskId 不在系统中
- void edit(int taskId, int newPriority) 更新已经存在的任务 taskId 的优先级为 newPriority 。输入 保证 taskId 存在于系统中
- void rmv(int taskId) 从系统中删除任务 taskId 。输入 保证 taskId 存在于系统中。
- int execTop() 执行所有用户的任务中优先级 最高 的任务，如果有多个任务优先级相同且都为 最高 ，执行 taskId 最大的一个任务。执行完任务后，taskId 从系统中 删除。同时请你返回这个任务所属的用户 userId。如果不存在任何任务，返回 -1 

注意，一个用户可能被安排多个任务

```js
Example 1:
Input:
["TaskManager", "add", "edit", "execTop", "rmv", "add", "execTop"]
[[[[1, 101, 10], [2, 102, 20], [3, 103, 15]]], [4, 104, 5], [102, 8], [], [101], [5, 105, 15], []]

Output: [null, null, null, 3, null, null, 5]
Explanation:
TaskManager taskManager = new TaskManager([[1, 101, 10], [2, 102, 20], [3, 103, 15]]); // Initializes with three tasks for Users 1, 2, and 3.
taskManager.add(4, 104, 5); // Adds task 104 with priority 5 for User 4.
taskManager.edit(102, 8); // Updates priority of task 102 to 8.
taskManager.execTop(); // return 3. Executes task 103 for User 3.
taskManager.rmv(101); // Removes task 101 from the system.
taskManager.add(5, 105, 15); // Adds task 105 with priority 15 for User 5.
taskManager.execTop(); // return 5. Executes task 105 for User 5.
```

限制：
- 1 <= tasks.length <= 10^5
- 0 <= userId <= 10^5
- 0 <= taskId <= 10^5
- 0 <= priority <= 10^9
- 0 <= newPriority <= 10^9
- At most 2 * 10^5 calls will be made in total to add, edit, rmv, and execTop methods.
The input is generated such that taskId will be valid.

## 解题

改进思路：用堆（优先队列）
- Python 的 heapq 支持最小堆，因此可以通过取负数来实现最大堆
- 插入 add 和获取最高优先级任务 execTop 都能 O(log n) 完成
- 修改和删除直接在堆里“懒惰删除”（标记无效），取出时检查有效性即可，避免 O(n) 删除

最优解：哈希表 + 堆（优先队列）
- 堆：维护 (priority, taskId, userId) 的元组（取负号保证最大堆效果）
- 哈希表（mp）：存储 taskId → (priority, userId)，便于校验任务是否有效

这样：
- add：O(log n)
- edit：O(log n)（实际是再次 add）
- rmv：O(1)（懒删除）
- execTop：O(log n)（从堆顶弹出直到遇到有效任务）

```python
class TaskManager:

    def __init__(self, tasks: List[List[int]]):
        # self.mp：字典，映射任务 ID → (优先级, 用户 ID)，用于快速校验任务状态
        self.mp = {taskId: (priority, userId) for userId, taskId, priority in tasks}
        # self.heap：用堆存储元组 (-priority, -taskId, userId)
        # -priority：实现最大堆（因为 heapq 是最小堆）
        # -taskId：同优先级时 taskId 越大优先级越高
        # userId：谁提交的任务
        self.heap = [(-priority, -taskId, userId) for userId, taskId, priority in tasks]  
        # heapify(self.heap)：将列表原地转换为堆结构 O(n)
        heapify(self.heap)

    def add(self, userId: int, taskId: int, priority: int) -> None:
        # 添加任务：
        # 在 mp 中更新该任务的最新 (priority, userId)
        # 把任务 ( -priority, -taskId, userId ) 压入堆（O(log n)）
        self.mp[taskId] = (priority, userId)
        heappush(self.heap, (-priority, -taskId, userId))

    def edit(self, taskId: int, newPriority: int) -> None:
        # 修改任务优先级：
        # 直接调用 add()，在 mp 中更新优先级并把新优先级入堆
        # 老的优先级留在堆中作为“无效”条目，稍后懒惰删除
        self.add(self.mp[taskId][1], taskId, newPriority)

    def rmv(self, taskId: int) -> None:
        # 移除任务：
        # 不直接在堆里删（那样 O(n)）
        # 而是在 mp 中把任务标记为 (-1,-1) 表示已删除
        # 堆中旧数据将来在 execTop 时检查丢弃
        self.mp[taskId] = (-1, -1)
    
    # 执行最高优先级任务：
    # 不断从堆顶弹出任务（O(log n)）
    # 
    def execTop(self) -> int:
        while self.heap:
            # 取出来的 (priority, taskId, userId) 是负数形式，实际任务是 -taskId 和 -priority
            priority, taskId, userId = heappop(self.heap)
            # 检查 mp[-taskId] 是否仍然等于 (-priority, userId)
            if self.mp[-taskId] == (-priority, userId):
                # 如果相等 → 这是有效任务
                # 调用 rmv() 标记移除
                # 返回该任务的用户 ID
                self.rmv(-taskId)
                return userId
            # 如果不相等 → 任务已被修改或删除 → 忽略继续弹堆顶
        
        # 如果堆空了 → 返回 -1
        return -1
```

- 时间复杂度：
  - 初始化：`O(n)` 或 `O(nlogn)`，其中 `n` 是 `tasks` 的长度，`m` 为后续操作的次数
  - `Python` 和 `Go` 使用了堆化，复杂度是 `O(n)` 的
  - `add` 和 `edit`：`O(log(n+m))`
  - `rmv`：`O(1)`
  - `execTop`：均摊 `O(log(n+m))`，每个元素至多入堆出堆各一次
- 空间复杂度：`O(n+m)`

