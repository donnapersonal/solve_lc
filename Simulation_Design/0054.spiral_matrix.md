# 54.螺旋矩阵

题目链接：[54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

## 题目大意

给一个 `m` 行 `n` 列的矩阵 `matrix`，请按照`顺时针螺旋顺序`，返回矩阵中的所有元素

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1zimjaav4e.webp)

限制：
- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 10
- -100 <= matrix[i][j] <= 100

## 解题

思路：`使用「四个边界指针」进行螺旋遍历`

关键思想：用四个变量维护未访问的边界：
- `up`：上边界（从上往下推进）
- `low`：下边界（从下往上收缩）
- `left`：左边界（从左向右推进）
- `right`：右边界（从右向左收缩）

按照顺时针顺序，执行以下步骤：
- 从左到右遍历上边界 → `up += 1`
- 从上到下遍历右边界 → `right -= 1`
- 从右到左遍历下边界 → `low -= 1`
- 从下到上遍历左边界 → `left += 1`

每走完一圈（外层），四条边界都向内收缩一格；只要输出数组 `res` 的长度小于 `m * n`，就持续执行 ➡️ 不使用额外空间，逻辑清晰，操作原始矩阵

```js
var spiralOrder = function(matrix) {
    let m = matrix.length, n = matrix[0].length;
    let up = 0, low = m - 1;
    let left = 0, right = n - 1;
    let res = [];
    while (res.length < m * n) {
        if (up <= low) {
            // 在顶部从左向右遍历
            for (let j = left; j <= right; j++) {
                res.push(matrix[up][j]);
            }
            // 上边界下移
            up++;
        }

        if (left <= right) {
            // 在右侧从上向下遍历
            for (let i = up; i <= low; i++) {
                res.push(matrix[i][right]);
            }
            // 右边界左移
            right--;
        }

        if (up <= low) {
            // 在底部从右向左遍历
            for (let j = right; j >= left; j--) {
                res.push(matrix[low][j]);
            }
            // 下边界上移
            low--;
        }

        if (left <= right) {
            // 在左侧从下向上遍历
            for (let i = low; i >= up; i--) {
                res.push(matrix[i][left]);
            }
            // 左边界右移
            left++;
        }
    }

    return res;
};
```
```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        # m 是行数，n 是列数，如输入是 3 行 4 列矩阵，则 m = 3, n = 4
        m, n = len(matrix), len(matrix[0])
        # 定义四个边界指针：
        # - up：当前尚未访问的上边界行索引
        # - low：尚未访问的下边界行索引
        # - left：左边界列索引
        # - right：右边界列索引
        up, low = 0, m - 1
        left, right = 0, n - 1
        # 定义结果数组 res，用于按顺序存放遍历结果
        res = []

        # 螺旋循环的终止条件：当结果数组长度达到总元素数 m * n 时停止
        # 可以避免越界或重复添加
        while len(res) < m * n:
            # 第一圈：从左到右（上边界）
            # 如果当前上边界仍小于等于下边界，说明还可以走上边
            # 遍历第 up 行，从 left 到 right
            # 访问完后，将 up 往下移一行 → up += 1
            if up <= low:
                for i in range(left, right + 1):
                    res.append(matrix[up][i])
                up += 1
            
            # 第二圈：从上到下（右边界）
            # 如果当前左边界小于等于右边界
            # 遍历第 right 列，从 up 到 low
            # 访问完后，将 right 左移一列
            if left <= right:
                for i in range(up, low + 1):
                    res.append(matrix[i][right])
                right -= 1
            
            # 第三圈：从右到左（下边界）
            # 如果 up <= low，表示还可以处理底部一行
            # 遍历第 low 行，从 right 到 left（逆向）
            # 向上收缩 low
            if up <= low:
                for i in range(right, left - 1, -1):
                    res.append(matrix[low][i])
                low -= 1
            
            # 第四圈：从下到上（左边界）
            # 如果 left <= right，还可以向上走左边一列
            # 遍历第 left 列，从 low 到 up（逆向）
            # 右移 left
            if left <= right:
                for i in range(low, up - 1, -1):
                    res.append(matrix[i][left])
                left += 1
        
        # 遍历完成，返回结果数组 res
        return res

# 写法 2
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        # 防御性判断：
        # matrix 为空（即 []）
        # 或矩阵的第一行为空（即 [[]]）
        # 如果遇到上述情况，直接返回空列表 []。
        if not matrix or not matrix[0]:
            return list()
        
        # m 是行数，n 是列数
        m, n = len(matrix), len(matrix[0])
        # 定义结果列表 res，用于收集遍历结果
        res = list()
        # 初始化四个边界指针：
        # left = 0，左边界
        # right = n - 1，右边界
        # top = 0，上边界
        # bottom = m - 1，下边界
        left, right, top, bottom = 0, n - 1, 0, m - 1

        # 只要矩阵还有未访问区域，就继续循环
        # 注意这里是 and 关系，意味着横向和纵向都还未收缩完才继续遍历
        while left <= right and top <= bottom:
            # 步骤 1：从左到右遍历 top 行
            # 行坐标是 top 固定
            # 从 left 列 到 right 列依次遍历
            # 添加 top 行的元素
            for i in range(left, right + 1):
                res.append(matrix[top][i])
            
            # 步骤 2：从上到下遍历 right 列
            # 列坐标是 right 固定
            # 从 top+1 到 bottom 行（不重复 top 行）
            # 添加 right 列的元素
            for i in range(top + 1, bottom + 1):
                res.append(matrix[i][right])
            
            # 条件判断：是否还有剩余的内圈可以处理
            # 只有当前矩阵至少为 2 行 2 列，才进行第三和第四步，避免在矩阵退化为单行或单列时重复访问
            if left < right and top < bottom:
                # 步骤 3：从右到左遍历 bottom 行
                # 行坐标是 bottom 固定
                # 从 right - 1 到 left + 1 之间遍历（不重复边界）
                for i in range(right - 1, left, -1):
                    res.append(matrix[bottom][i])
                
                # 步骤 4：从下到上遍历 left 列
                # 列坐标是 left 固定
                # 从 bottom 到 top+1 之间倒序遍历
                for i in range(bottom, top, -1):
                    res.append(matrix[i][left])
            
            # 收缩边界：每一圈遍历完后，将边界向内收缩一圈
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        
        # 返回结果列表
        return res
```

- 时间复杂度：`O(m * n)`，由于代码中有四个循环，每个循环都遍历矩阵的一边，但总共只遍历所有元素一次，所以时间复杂度为 `O(m * n)`，其中 `m` 和 `n` 分别是矩阵的行数和列数
- 空间复杂度：除了用于输出的列表 `res` 外，没有使用任何额外的空间，因此空间复杂度为 `O(1)`。注意，若输出空间不计算在内（通常情况下不计算输出空间），空间复杂度是`O(1)`；若输出空间计算在内，空间复杂度是 `O(m * n)`



