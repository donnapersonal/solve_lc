# 2.两数相加

题目链接：[2.两数相加](https://leetcode.cn/problems/add-two-numbers/)

## 题目大意

给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字

请将两个数相加，并以相同形式返回一个表示和的链表

可以假设除了数字 `0` 之外，这两个数都不会以 `0` 开头

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9gwxfuefdr.webp)

限制：
- The number of nodes in each linked list is in the range [1, 100].
- 0 <= Node.val <= 9
- It is guaranteed that the list represents a number that does not have leading zeros.

## 解题

最直觉的方式是：
- 把两个链表转换为整数 → `O(n)`
- 把它们相加 → `O(1)`
- 把结果转换为链表 → `O(n)`
- 问题：
  - 这个方法在 `Python` 中可行，但不适用于其他语言（可能会溢出）
  - 而且没有充分利用链表的逐位表示逆序数的结构
  
中间优化：不转成整数，模拟竖式加法 -> 可以模拟小学的按位加法：
- 从低位往高位加（链表本身就是逆序的）
- 每次加两个对应位的值 + 进位（carry）
- 保存当前位结果，更新进位

最优解：`双指针 + 进位处理`

这个解决方案的核心思想是同时遍历两个链表，按位相加并处理进位

实现的详细解释：
- 创建一个虚拟头节点 `dummy`，简化了边界情况的处理
- 使用一个循环同时遍历两个链表，直到两个链表都遍历完
- 在每一步中：
  - 获取当前位的值（如果链表已经遍历完，则用 `0` 代替）
  - 计算当前位的和，包括之前的进位
  - 创建一个新节点，其值为和的个位数
  - 更新进位值
- 如果最后还有进位，创建一个额外的节点
- 返回虚拟头节点的下一个节点，即结果链表的实际头节点

```js
var addTwoNumbers = function(l1, l2) {
    let dummy = new ListNode(0);
    let p = dummy;
    let carry = 0;
    while (l1 !== null || l2 !== null) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;
        let sum = carry + x + y;
        carry = Math.floor(sum / 10);
        p.next = new ListNode(sum % 10);
        p = p.next;
        if (l1 !== null) l1 = l1.next;
        if (l2 !== null) l2 = l2.next;
    }

    if (carry > 0) p.next = new ListNode(carry);
    return dummy.next;
};
```
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        # 创建一个哑节点 dummy，用于构建结果链表，最终返回 dummy.next
        dummy = ListNode(0)
        # 指针 p 负责遍历并构建结果链表
        p = dummy
        # 初始化进位 carry，每一位加法可能会产生进位（如 8 + 7 = 15）
        carry = 0

        # 主循环条件：只要还有节点没处理，就继续
        # 支持两个链表长度不等
        while l1 or l2:
            # 提取当前节点的值，如果当前链表为空，则用 0 代替
            # 这是为了避免空指针访问
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            # 本位总和 = l1 当前值 + l2 当前值 + 上一位的进位
            total = carry + x + y
            # 计算新的进位（如：15 // 10 = 1）
            carry = total // 10
            # 创建新节点：当前位只保留个位数（如 15 → 5）
            p.next = ListNode(total % 10)
            # 移动结果链表指针，继续构建下一个节点
            p = p.next

            # 如果 l1 还有下一个节点，就移动到下一个
            if l1:
                l1 = l1.next
            
            # 同样地，移动 l2 的指针
            if l2:
                l2 = l2.next
        
        # 最后可能还有一个进位（如 999 + 1 = 1000），需要额外加一位节点
        if carry > 0:
            p.next = ListNode(carry)
        
        # 跳过 dummy 节点，返回真正的结果链表头
        return dummy.next
```

- 时间复杂度：`O(max(n, m))`，`n` 和 `m` 是两个输入链表的长度，只需遍历一次最长的链表
- 空间复杂度：`O(max(n, m))`，在最坏的情况下新链表的长度为 `max(n, m) + 1`（如，当有一个额外的进位时）