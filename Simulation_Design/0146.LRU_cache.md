# 146.LRU 缓存

题目链接：[146.LRU 缓存](https://leetcode.cn/problems/lru-cache/)

## 题目大意

请设计并实现一个满足 `LRU (最近最少使用)` 缓存约束的数据结构

实现 `LRUCache` 类：
- `LRUCache(int capacity)` 以`正整数`作为容量 `capacity` 初始化 `LRU` 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value`；如果不存在，则向缓存中插入该组 `key-value`。如果插入操作导致关键字数量超过 `capacity`，则应该逐出最久未使用的关键字
- 函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行

```js
Example 1:
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
```

限制：
- 1 <= capacity <= 3000
- 0 <= key <= 10^4
- 0 <= value <= 10^5
- At most 2 * 10^5 calls will be made to get and put

## 解题

### 写法 1

`Python` 中 `collections.OrderedDict` 已内建维护插入顺序：
- 插入 `key` 时，它自动在尾部
- 删除最早插入项：只需弹出最前面一个
- 移动某个 `key` 到尾部：`pop` 后再插入
- 所有操作 时间复杂度都是 `O(1)`！

核心思想：利用 `OrderedDict` 自动维护使用顺序，实现一个容量固定的缓存
- `get(key)`：
  - 如果 `key` 存在 → 取出并更新为最近使用
  - 否则返回 `-1`
- `put(key, value)`：
  - 如果 `key` 存在 → 更新值并设置为最近使用
  - 否则：
    - 如果容量满了 → 删除最早插入的 `key`
    - 插入新 `key` → 放到末尾

```js
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.cap = capacity;
    this.cache = new Map();
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (!this.cache.has(key)) return -1;
    this.makeRecently(key);
    return this.cache.get(key);
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if (this.cache.has(key)) {
        this.cache.set(key, value);
        this.makeRecently(key);
        return;
    }

    if (this.cache.size >= this.cap) {
        // 链表头部就是最久未使用的 key
        const oldestKey = this.cache.keys().next().value;
        this.cache.delete(oldestKey);
    }

    // 将新的 key 添加链表尾部
    this.cache.set(key, value);
};

LRUCache.prototype.makeRecently = function(key) {
    const val = this.cache.get(key);
    // 删除 key，重新插入到队尾
    this.cache.delete(key);
    this.cache.set(key, val);
};
```
```python
class LRUCache:
    def __init__(self, capacity: int):
        # 构造函数接收 capacity（最大容量）
        self.cap = capacity
        # self.cache 是一个 OrderedDict，自动维护 key 的使用顺序（最近插入/使用的在末尾）
        # 初始为空
        self.cache = collections.OrderedDict()

    def get(self, key: int) -> int:
        # 若 key 不存在，返回 -1，表示缓存未命中
        if key not in self.cache:
            return -1
        
        # 如果存在：
        # 调用 makeRecently(key) 将其移动到末尾（表示最近使用）
        # 然后返回对应的值
        self.makeRecently(key)
        return self.cache[key]
    
    # 定义 put 方法，插入或更新一个键值对
    def put(self, key: int, value: int) -> None:
        # 如果 key 已存在：
        # 更新值
        # 调用 makeRecently 把它移动到末尾（表示最近使用）
        # 提前 return
        if key in self.cache:
            self.cache[key] = value
            self.makeRecently(key)
            return
        
        # 如果缓存已满：
        # 使用 next(iter(...)) 获取最早插入的 key（最少使用）
        # pop 删除它（释放空间）
        if len(self.cache) >= self.cap:
            oldestKey = next(iter(self.cache))
            self.cache.pop(oldestKey)
        
        # 插入新 key，会自动加到 OrderedDict 的末尾，表示最近使用
        self.cache[key] = value
    
    # 辅助函数：将某个已存在的 key 移动到末尾（即标记为最近使用）：
    # pop 删除这个 key
    # 再次插入，会自动出现在末尾
    def makeRecently(self, key):
        val = self.cache.pop(key)
        self.cache[key] = val
```

- 时间复杂度：  
  - get：`O(1)`
  - put：`O(1)`
  - `makeRecently`：`O(1)`
- 空间复杂度：`O(n)`，其中 `n` 是缓存的最大容量 `capacity`

### 写法 2

使用：`哈希表 + 双向链表（Dict + Doubly Linked List）`

核心思想：
- 哈希表 (dict)：实现 O(1) 查询节点
- 双向链表：
  - 链表头表示“最近使用”
  - 链表尾表示“最久未使用”
  - 插入新节点 → 加入头部
  - 删除最近最少使用的节点 → 删除尾部

这样可以在 `O(1)` 时间内完成所有插入、删除、移动等操作

```python
# 定义双向链表节点类
class DLinkedNode:
    def __init__(self, key=0, value=0):
        # 每个节点包含 key 和 value
        self.key = key
        self.value = value
        # 还有 prev 和 next 指针用于双向链表
        # 用来支持 O(1) 地移动和删除节点
        self.prev = None
        self.next = None

class LRUCache:
    # 初始化 LRUCache
    def __init__(self, capacity: int):
        # 创建伪头节点 head 和伪尾节点 tail，方便统一插入和删除逻辑
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        # 初始状态：head <-> tail
        self.head.next = self.tail
        self.tail.prev = self.head

        # cache 是 key → node 的哈希映射
        self.cache = dict()
        # cap 是最大容量
        self.cap = capacity
        # size 记录当前元素数量
        self.size = 0

    def get(self, key: int) -> int:
        # 如果 key 不存在于缓存中，返回 -1
        if key not in self.cache:
            return -1
        
        # 若存在，则获取该节点
        node = self.cache[key]
        # 将其移动到链表头部（标记为最近使用）
        self.moveToHead(node)
        # 返回其值
        return node.value

    def put(self, key: int, value: int) -> None:
        # 如果 key 不存在，是插入新元素
        if key not in self.cache:
            # 创建新节点
            node = DLinkedNode(key, value)
            # 哈希表记录
            self.cache[key] = node
            # 加入到头部
            self.addToHead(node)
            # size +1
            self.size += 1
            # 如果超出容量：
            # 移除尾部节点（最久未使用）
            # 从哈希表中删除
            # size -1
            if self.size > self.cap:
                removed = self.removeTail()
                self.cache.pop(removed.key)
                self.size -= 1
        else:
            # 如果 key 存在：
            # 更新节点值
            # 移动到链表头（标记为最近使用）
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
    
    # 将 node 插入到 head 和 head.next 之间
    # 实现 O(1) 插入
    def addToHead(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    # 将 node 从链表中移除
    # 直接通过前后指针修改，不需遍历
    # O(1) 删除
    def removeNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
    
    # 先移除，再插入到头部
    # 用于标记某节点为最近使用
    def moveToHead(self, node):
        self.removeNode(node)
        self.addToHead(node)
    
    # 获取尾部节点（最久未使用）
    # 调用 removeNode 删除它
    # 返回这个节点，以便在哈希表中也删除
    def removeTail(self):
        node = self.tail.prev
        self.removeNode(node)
        return node
```

- 时间复杂度
  | 操作 | 时间复杂度 | 说明 |
  | --- | --- | --- |
  | `get` | O(1) | 哈希表查找 + 链表移动 |
  | `put` | O(1) | 哈希表插入/更新 + 链表操作 |
  | 插入头部 | O(1) | 通过前后指针直接插入 |
  | 删除尾部 | O(1) | 直接找到尾部节点并断开连接 |
- 空间复杂度：`O(capacity)`
  - 最多存储 `capacity` 个 `key`：
    - 哈希表中存储了 `key → node` 的映射，大小为 `O(capacity)`
    - 每个节点是一个双向链表节点，`key + value + prev + next`，也有 `O(capacity)` 个
  - 没有其他额外数据结构，空间使用是线性增长的