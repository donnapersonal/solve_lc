# 48.旋转图像

题目链接：[48.旋转图像](https://leetcode.cn/problems/rotate-image/)

## 题目大意

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像，请将图像顺时针旋转 `90` 度

必须在`原地`旋转图像，这意味着需要直接修改输入的二维矩阵

请不要`使用另一个矩阵`来旋转图像

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.4qroq2abfc.webp)

限制：
- n == matrix.length == matrix[i].length
- 1 <= n <= 20
- -1000 <= matrix[i][j] <= 1000

## 解题

### 思路 1: 原地翻转 - 转置 + 水平翻转

**写法 1: **

核心思路：
- 转置矩阵：把行列互换,即：`matrix[i][j] ↔ matrix[j][i]`
- 每行反转：行内左右对称交换
- 最终效果就是顺时针旋转 `90` 度！

✅ 空间复杂度 O(1)，只用原数组
✅ 实现简单，易读，安全

**写法 2: **



```js
var rotate = function(matrix) {
    let n = matrix.length;
    for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
            let temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    for (let row of matrix){
        reverse(row);
    }
};

var reverse = function(arr) {
    let i = 0, j = arr.length - 1;
    while (i < j) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
        i++;
        j--;
    }
};
```
```python
# 写法 1
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        # n 表示矩阵的大小（行数或列数）
        n = len(matrix)
        # 步骤一：转置矩阵（沿主对角线对称）
        # 外层循环 i 表示行
        for i in range(n):
            # 内层循环 j 从 i 开始，表示列
            for j in range(i, n):
                # 只遍历上三角区（含对角线）以避免重复交换
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        
        # 步骤二：每行进行水平翻转
        # 遍历每一行，调用 reverse 函数，将其左右翻转
        for row in matrix:
            self.reverse(row)
    
    # 工具函数：反转一个数组
    def reverse(self, row):
        # 设置左右指针 l 和 r，分别指向行首和行尾
        l, r = 0, len(row) - 1
        # 不断交换 row[l] 和 row[r]
        # 每次交换后左右指针向中间移动
        while l < r:
            row[l], row[r] = row[r], row[l]
            l += 1
            r -= 1


```

- 时间复杂度：`O(n^2)`
  - 对矩阵进行对角线镜像对称：这个步骤涉及遍历矩阵的一半，对于 `n x n` 的矩阵，需要 `O(n^2/2)`的时间，但因这是一个常数倍的差异，通常忽略常数倍差异，所以这部分的时间复杂度是 `O(n^2)`
  - 反转每一行：每行都被反转，对于每行的操作时间复杂度是 `O(n)`，因为矩阵有 `n` 行，所以这个步骤的总的时间复杂度是 `O(n^2)`
- 空间复杂度：`O(1)`，这个函数是原地操作，除了用于交换的 `temp` 变量外，没有使用额外的空间