# 622.设计循环队列

题目链接：[622.设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

## 题目大意

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值

你的实现应该支持如下操作：
- MyCircularQueue(k): 构造器，设置队列长度为 k 
- Front: 从队首获取元素。如果队列为空，返回 -1 
- Rear: 获取队尾元素。如果队列为空，返回 -1 
- enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真
- deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真
- isEmpty(): 检查循环队列是否为空
- isFull(): 检查循环队列是否已满

```js
Example 1:
Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
```

限制：
- 1 <= k <= 1000
- 0 <= value <= 1000
- At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.

## 解题

### 思路 1: 数组

最优思路：使用 循环数组（Circular Array）
- 使用 长度为 `k+1` 的数组 + 双指针（`front` 和 `rear`）实现循环队列，满足：
  - 固定容量，空间 `O(k)`
  - 所有操作时间复杂度 `O(1)`
- 支持循环操作：利用`取模 % `操作使指针回到起点（形成“环”）

```python
class MyCircularQueue:
    def __init__(self, k: int):
        # 初始化函数，传入参数 k 表示队列的最大容量为 k
        # 分配 k + 1 大小的数组空间（注意是 k+1）以便判断“满”与“空”的状态
        # 使用两个指针：
        # front：指向队首元素的位置
        # rear：指向下一个可插入元素的位置
        self.front = self.rear = 0
        self.elements = [0] * (k + 1)

    def enQueue(self, value: int) -> bool:
        # 插入前先判断队列是否已满
        # 满了就返回 False
        if self.isFull():
            return False
        
        # 将值插入到 rear 指向的位置
        self.elements[self.rear] = value
        # 然后 rear 向后移动一位，如果到了末尾就回到起点（通过 % 实现循环）
        self.rear = (self.rear + 1) % len(self.elements)
        # 插入成功返回 True
        return True
        
    def deQueue(self) -> bool:
        # 删除前先判断队列是否为空
        # 空了就返回 False
        if self.isEmpty():
            return False
        
        # 将 front 向后移动一位，即跳过当前队首元素
        self.front = (self.front + 1) % len(self.elements)
        # 删除成功返回 True
        return True

    def Front(self) -> int:
        # 如果队列为空，返回 -1
        # 否则返回 front 指向的元素，即队首元素
        return -1 if self.isEmpty() else self.elements[self.front]

    def Rear(self) -> int:
        # 如果队列为空，返回 -1
        # 否则返回队尾元素：rear 指向的是下一个可插入的位置，所以当前队尾是 (rear - 1) % n
        return -1 if self.isEmpty() else self.elements[(self.rear - 1) % len(self.elements)]

    def isEmpty(self) -> bool:
        # 当 front == rear 时，队列为空
        return self.rear == self.front

    def isFull(self) -> bool:  
        # 当 (rear + 1) % n == front，说明队列已满
        # 注意：这里必须有一个空位来区分空和满，所以数组长度为 k+1 而不是 k
        return (self.rear + 1) % len(self.elements) == self.front
```

- 时间复杂度：初始化和每项操作的时间复杂度均为 `O(1)`
- 空间复杂度：`O(k)`，其中 `k` 为给定的队列元素数目

### 思路 2: 链表

```python
class MyCircularQueue:
    def __init__(self, k: int):
        self.head = self.tail = None
        self.capacity = k
        self.size = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False

        node = ListNode(value)
        if self.head is None:
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            self.tail = node

        self.size += 1
        return True
        
    def deQueue(self) -> bool:
        if self.isEmpty():
            return False

        self.head = self.head.next
        self.size -= 1
        return True

    def Front(self) -> int:
        return -1 if self.isEmpty() else self.head.val

    def Rear(self) -> int:
        return -1 if self.isEmpty() else self.tail.val

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity
```

- 时间复杂度：初始化和每项操作的时间复杂度均为 `O(1)`
- 空间复杂度：`O(k)`，其中 `k` 为给定的队列元素数目