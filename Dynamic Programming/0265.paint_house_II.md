# 265.粉刷房子 II

题目链接：[265.粉刷房子 II](https://leetcode.cn/problems/paint-house-ii/)

## 题目大意

假如有一排房子共有 n 幢，每个房子可以被粉刷成 k 种颜色中的一种。房子粉刷成不同颜色的花费成本也是不同的。你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同

每个房子粉刷成不同颜色的花费以一个 n x k 的矩阵表示

例如，costs[0][0] 表示第 0 幢房子粉刷成 0 号颜色的成本；costs[1][2] 表示第 1 幢房子粉刷成 2 号颜色的成本，以此类推

返回 粉刷完所有房子的最低成本 

```js
Example 1:
Input: costs = [[1,5,3],[2,9,4]]
Output: 5
Explanation:
Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; 
Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.

Example 2:
Input: costs = [[1,3],[2,4]]
Output: 5
```

限制:
- costs.length == n
- costs[i].length == k
- 1 <= n <= 100
- 2 <= k <= 20
- 1 <= costs[i][j] <= 20

## 解题

暴力思路
- 最直接的做法：每一栋房子选择每种颜色，然后递归或者 `DFS` 遍历所有合法的组合
- 时间复杂度：`O(k^n)` → 当 `n` 或 `k` 较大时不可行

动态规划（DP）
- 可以用 `DP` 定义状态：`dp[i][c] = 涂完第 i 栋房子，并且第 i 栋房子涂颜色 c 的最小成本`
- 转移方程：`dp[i][c] = costs[i][c] + min(dp[i-1][c'] for c' != c)`
- 时间复杂度：`O(n * k^2)` → 每次计算第 `i` 栋房子每种颜色时，要找前一栋房子最小的其他颜色成本
- 空间复杂度：`O(n * k)` 或 `O(k)`（滚动数组优化）
- 问题：当 `k` 很大时，`O(n * k^2)` 仍然太慢

优化 DP → 只维护最小值和第二小值
- 关键观察：
  - 对于第 `i` 栋房子选择颜色 `c`，只关心前一栋房子`最小成本`和`第二小成本`：
    - 如果 `c` 与前一栋房子的最小成本颜色相同 → 使用第二小成本
    - 否则 → 使用最小成本
- 这样每栋房子只需 `O(k)` 时间即可计算最小成本
- 时间复杂度：`O(n * k)`，空间复杂度：`O(1)`（除了输入数组）

```js
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCostII = function(costs) {
    const n = costs.length;
    if (n === 0) return 0;

    const k = costs[0].length;
    let prevMinCost = null, prevSecondMinCost = null, prevMinColor = null;

    // Initialize first house
    for (let color = 0; color < k; color++) {
        const cost = costs[0][color];
        if (prevMinCost === null || cost < prevMinCost) {
            prevSecondMinCost = prevMinCost;
            prevMinCost = cost;
            prevMinColor = color;
        } else if (prevSecondMinCost === null || cost < prevSecondMinCost) {
            prevSecondMinCost = cost;
        }
    }

    // Process remaining houses
    for (let house = 1; house < n; house++) {
        let minCost = null, secondMinCost = null, minColor = null;

        for (let color = 0; color < k; color++) {
            let cost = costs[house][color];
            if (color === prevMinColor) {
                cost += prevSecondMinCost;
            } else {
                cost += prevMinCost;
            }

            if (minCost === null || cost < minCost) {
                secondMinCost = minCost;
                minCost = cost;
                minColor = color;
            } else if (secondMinCost === null || cost < secondMinCost) {
                secondMinCost = cost;
            }
        }

        prevMinCost = minCost;
        prevMinColor = minColor;
        prevSecondMinCost = secondMinCost;
    }

    return prevMinCost;
};
```
```python
class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        # n = 房子数量
        n = len(costs)
        # 特殊情况：没有房子 → 总成本 0
        if n == 0: 
            return 0 
        
        # k = 每栋房子的颜色数量
        k = len(costs[0])
        # 初始化前一栋房子的最小成本、第二小成本、最小成本对应的颜色
        prev_min_cost = prev_second_min_cost = prev_min_color = None
        # 处理第一栋房子
        # 遍历所有颜色，找出：
        # prev_min_cost → 最小成本
        # prev_second_min_cost → 第二小成本
        # prev_min_color → 最小成本对应的颜色
        # 作用：为后续房子 DP 转移提供基础数据
        for color, cost in enumerate(costs[0]):
            if prev_min_cost is None or cost < prev_min_cost:
                prev_second_min_cost = prev_min_cost
                prev_min_color = color
                prev_min_cost = cost
            elif prev_second_min_cost is None or cost < prev_second_min_cost:
                prev_second_min_cost = cost
        
        # 遍历剩余房子
        for house in range(1, n):
            # 初始化当前房子的最小成本、第二小成本和对应颜色
            min_cost = second_min_cost = min_color = None
            # 核心转移逻辑：
            # 如果当前颜色与前一栋房子的最小成本颜色相同 → 使用第二小成本
            # 否则 → 使用最小成本
            # 这样保证 相邻房子颜色不同 且成本最小
            for color in range(k):
                cost = costs[house][color]
                if color == prev_min_color:
                    cost += prev_second_min_cost
                else:
                    cost += prev_min_cost
                
                # 更新 当前房子的最小成本和第二小成本
                # min_color = 当前最小成本对应颜色
                if min_cost is None or cost < min_cost:
                    second_min_cost = min_cost
                    min_color = color
                    min_cost = cost
                elif second_min_cost is None or cost < second_min_cost:
                    second_min_cost = cost
            
            # 更新前一栋房子的最小值信息，为下一栋房子使用
            prev_min_cost = min_cost
            prev_min_color = min_color
            prev_second_min_cost = second_min_cost
        
        # 返回 最后一栋房子的最小成本 → 即整个房子的最小总成本
        return prev_min_cost
```

- 时间复杂度：`O(n⋅k)`
  - 找到第一行的最小值的第一个循环是 `O(K)`，因为它只查看第一行中的每个 `k` 值一次
  - 第二个循环是 `O(n⋅k)` 因为外层循环 `n` 次，内层循环 `k` 次
  - `O(n⋅k)+O(k)=O(n⋅k)`
  - 我们知道 不可能 比这做的更好，因为不可能不先遍历一次所有的 `n⋅k` 个单元格就解决这个问题
- 空间复杂度：`O(1)`