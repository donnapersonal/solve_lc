# 2851.字符串转换

题目链接：[2851.字符串转换](https://leetcode.cn/problems/string-transformation/)

## 题目大意

给你两个长度都为 n 的字符串 s 和 t 。你可以对字符串 s 执行以下操作：
- 将 s 长度为 l （0 < l < n）的 后缀字符串 删除，并将它添加在 s 的开头
- 比方说，s = 'abcd' ，那么一次操作中，你可以删除后缀 'cd' ，并将它添加到 s 的开头，得到 s = 'cdab' 
- 给你一个整数 k ，请你返回 恰好 k 次操作将 s 变为 t 的方案数

由于答案可能很大，返回答案对 109 + 7 取余 后的结果

```js
Example 1:
Input: s = "abcd", t = "cdab", k = 2
Output: 2
Explanation: 
First way:
In first operation, choose suffix from index = 3, so resulting s = "dabc".
In second operation, choose suffix from index = 3, so resulting s = "cdab".

Second way:
In first operation, choose suffix from index = 1, so resulting s = "bcda".
In second operation, choose suffix from index = 1, so resulting s = "cdab".

Example 2:
Input: s = "ababab", t = "ababab", k = 1
Output: 2
Explanation: 
First way:
Choose suffix from index = 2, so resulting s = "ababab".

Second way:
Choose suffix from index = 4, so resulting s = "ababab".
```

限制:
- 2 <= s.length <= 5 * 10^5
- 1 <= k <= 10^15
- s.length == t.length
- s and t consist of only lowercase English alphabets.
  
## 解题

题解详见: [KMP + 矩阵快速幂优化 DP](https://leetcode.cn/problems/string-transformation/solutions/2435348/kmp-ju-zhen-kuai-su-mi-you-hua-dp-by-end-vypf/)

```js
/**
 * @param {string} s
 * @param {string} t
 * @param {number} k
 * @return {number}
 */
var numberOfWays = function(s, t, k) {
    const n = s.length;
    const c = kmpSearch(s + s.substring(0, n - 1), t);
    const m = [
        [BigInt(c - 1), BigInt(c)],
        [BigInt(n - c), BigInt(n - 1 - c)],
    ];
    const res = pow(m, k);
    return Number(s === t ? res[0][0] : res[0][1]);
};

// KMP 模板
function calcMaxMatch(s) {
    const match = Array(s.length).fill(0);
    let c = 0;
    for (let i = 1; i < s.length; i++) {
        const v = s.charAt(i);
        while (c && s.charAt(c) !== v) {
            c = match[c - 1];
        }
        if (s.charAt(c) === v) {
            c++;
        }
        match[i] = c;
    }
    return match;
}

// KMP 模板
// 返回 text 中出现了多少次 pattern（允许 pattern 重叠）
function kmpSearch(text, pattern) {
    const match = calcMaxMatch(pattern);
    let matchCount = 0;
    let c = 0;
    for (let i = 0; i < text.length; i++) {
        const v = text.charAt(i);
        while (c && pattern.charAt(c) !== v) {
            c = match[c - 1];
        }
        if (pattern.charAt(c) === v) {
            c++;
        }
        if (c === pattern.length) {
            matchCount++;
            c = match[c - 1];
        }
    }
    return matchCount;
}

// 矩阵乘法
function multiply(a, b) {
    const c = [[0, 0], [0, 0]]
    for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
            c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % 1_000_000_007n;
        }
    }
    return c;
}

// 矩阵快速幂
function pow(a, n) {
    let res = [[BigInt(1), BigInt(0)], [BigInt(0), BigInt(1)]];
    while (n) {
        if (n % 2) {
            res = multiply(res, a);
        }
        a = multiply(a, a);
        n = Math.floor(n / 2);
    }
    return res;
}
```
```python
class Solution:
    def numberOfWays(self, s: str, t: str, k: int) -> int:
        n = len(s)
        c = self.kmp_search(s + s[:-1], t)
        m = [
            [c - 1, c],
            [n - c, n - 1 - c]
        ]
        m = self.pow(m, k)
        return m[0][s != t]
    
    def calc_pi(self, s: str) -> List[int]:
        pi = [0] * len(s)
        c = 0
        for i in range(1, len(s)):
            v = s[i]
            while c and s[c] != v:
                c = pi[c - 1]
            if s[c] == v:
                c += 1
            pi[i] = c
        return pi

    def kmp_search(self, text: str, pattern: str) -> int:
        pi = self.calc_pi(pattern)
        match_count = c = 0
        for i, v in enumerate(text):
            while c and pattern[c] != v:
                c = pi[c - 1]
            if pattern[c] == v:
                c += 1
            if c == len(pattern):
                match_count += 1
                c = pi[c - 1]

        return match_count
    
    def multiply(self, a: List[List[int]], b: List[List[int]]) -> List[List[int]]:
        c = [[0, 0], [0, 0]]
        for i in range(2):
            for j in range(2):
                c[i][j] = (a[i][0] * b[0][j] + a[i][1] * b[1][j]) % 1_000_000_007
        return c
    
    def pow(self, a: List[List[int]], n: int) -> List[List[int]]:
        res = [[1, 0], [0, 1]]
        while n:
            if n % 2:
                res = self.multiply(res, a)
            a = self.multiply(a, a)
            n //= 2
        return res
```

- 时间复杂度：`O(n+logk)`，其中 `n` 为 `s` 的长度
- 空间复杂度：`O(n)`