# 70.爬楼梯

题目链接：[70.爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

## 题目大意

假设你正在爬楼梯，需要 `n` 阶你才能到达楼顶

每次你可以爬 `1` 或 `2` 个台阶，你有多少种不同的方法可以爬到楼顶呢？

```js
Example 1:
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

限制：
- 1 <= n <= 45

## 解题

题目描述：假设你正在爬楼，需要 `n` 阶才能到达楼顶，每次可以爬 `1` 或 `2` 个台阶，请问有多少种不同的方法可以爬到楼顶？

这其实是一个斐波那契数列问题变种：
- 若在第 `n` 阶，可能是：从 `n-1` 阶走一步上来
- 或从 `n-2` 阶走两步上来
- 因此：`dp(n) = dp(n-1) + dp(n-2)`


### 思路 1：记忆化递归（Top-down 动态规划）

将递归的中间结果保存下来，避免重复计算
- 使用一个 `memo` 数组记录已计算的 `dp(n)`
- 每次递归前先判断 `memo[n]` 是否已有值，有就直接返回

```js
var climbStairs = function(n) {
    // 备忘录
    let memo = new Array(n + 1).fill(0);
    // 定义：爬到第 n 级台阶的方法个数为 dp(n)
    // @visualize status(n)
    const dp = function(n) {
        // base case
        if (n <= 2) return n;
        if (memo[n] > 0) return memo[n];
        // 状态转移方程：
        // 爬到第 n 级台阶的方法个数等于爬到 n - 1 的方法个数和爬到 n - 2 的方法个数之和
        memo[n] = dp(n - 1) + dp(n - 2);
        return memo[n];
    };
    return dp(n);
};
```
```python
class Solution:
    # 主函数接收一个整数 n，表示楼梯总阶数
    # 返回的是爬上 n 阶的总方法数
    def climbStairs(self, n: int) -> int:
        # 创建一个长度为 n+1 的数组 memo，用于保存子问题的解
        # 如，memo[3] 表示爬到第 3 阶的方法总数
        # 初始化为全 0，表示还没计算
        self.memo = [0] * (n+1)
        # 调用辅助递归函数 dp(n)，实际执行记忆化递归逻辑
        return self.dp(n)
    
    def dp(self, n):
        # 递归终止条件
        # 当 n 为 1 或 2 时，返回 n，因为：
        # - n=1：只有一种走法（1）
        # - n=2：两种走法（1+1, 2）
        # 是递归基础情况
        if n <= 2:
            return n
        
        # 记忆化判断：如果 memo[n] 已经算过（不为 0），就直接返回，避免重复计算
        if self.memo[n] > 0:
            return self.memo[n]
        
        # 状态转移公式
        # 使用递归计算子问题：dp(n-1) 和 dp(n-2)
        # 状态转移方程：爬到第 n 级台阶的方法个数等于爬到 n - 1 的方法个数和爬到 n - 2 的方法个数之和
        # 如果最后一步是跨 1 阶到达 n，则之前就在 n-1
        # 如果最后一步是跨 2 阶到达 n，则之前就在 n-2
        # 然后把结果保存在 memo[n] 中
        self.memo[n] = self.dp(n-1) + self.dp(n-2)
        
        # 将缓存好的结果返回
        return self.memo[n]
```

- 时间复杂度：`O(n)`
  - 每个 `dp(n)` 在首次计算时最多会计算 `n-1` 和 `n-2` 两个子问题，之后由于备忘录的存在 `self.memo`，每个子问题只会被计算一次
  - 由于每个子问题的解被存储在 `memo` 中，避免了重复计算，所以时间复杂度是 `O(n)`
- 空间复杂度：`O(n)`

### 思路 2: Bottom-up DP

思路：
- 从 `dp[1]`、`dp[2]` 开始迭代推到 `dp[n]`，去掉递归栈
- 仍需 `O(n)` 存整张表，但其实只用到了上一项和上上一项
- 

可空间优化为滚动变量（Bottom-Up + Rolling）最优
- 由于 `dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`，用两个变量滚动即可
- 令 `prev1 = dp[i-1]`，`prev2 = dp[i-2]`，计算 `cur = prev1 + prev2`，随后右移窗口
- 时间 `O(n)`、空间 `O(1)`、实现简洁健壮

```js
var climbStairs = function(n) {
    let dp = new Array(n+1).fill(0);
    dp[0] = 1;
    dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
};
```
```python
# 写法 1
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0 for _ in range(n + 1)]
        # dp[0] = 1：表示爬到第 0 级台阶（也就是不动）的方法数为 1
        # dp[1] = 1：表示爬到第 1 级台阶的方法数为 1，因为只能有一种方法：爬 1 阶
        dp[0] = 1
        dp[1] = 1

        # 从第 2 级台阶开始，逐级计算爬到每一级台阶的方法数
        for i in range(2, n + 1):
            # 如果最后一步是跨 1 阶到达第 i 级台阶，则之前就在 i-1
            # 如果最后一步是跨 2 阶到达第 i 级台阶，则之前就在 i-2
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # 爬到第 n 级台阶的所有不同方法数
        return dp[n]

# 写法 2: 空间优化
class Solution:
    def climbStairs(self, n: int) -> int:
        # 处理小输入的基础情形，避免后续循环复杂化
        if n <= 2:
            # 当 n 为 1 或 2 时，答案就是 n：
            # n=1：只有 [1] 一种
            # n=2：[1,1]、[2] 共两种
            return n
        
        # 引入两个滚动变量：
        # prev1 表示 dp[i-1]（初始化为 dp[2]=2）
        # prev2 表示 dp[i-2]（初始化为 dp[1]=1）
        # 之所以从 2, 1 开始，是因为接下来循环从 i=3 起推，正好用到 dp[2] 和 dp[1]
        prev1, prev2 = 2, 1

        # 自底向上，从第 3 阶推到第 n 阶
        # Python 的 range(3, n+1) 会生成 [3, 4, ..., n]
        for i in range(3, n+1):
            # 按递推式 dp[i] = dp[i-1] + dp[i-2] 计算当前阶的走法数
            # 其中 prev1 即 dp[i-1]，prev2 即 dp[i-2
            cur = prev1 + prev2
            # 窗口右移：下一轮中，旧的 dp[i-1] 将成为新的 dp[i-2]
            prev2 = prev1
            # 同理：当前计算出的 dp[i] 将成为下一轮的 dp[i-1]
            # 这两步实现了“用两个变量滚动保存相邻两项”的思想
            prev1 = cur
        
        # 循环结束时，prev1 正是 dp[n]（最后一次更新得到），返回之
        # 小结：这段代码把“dp[i] = dp[i-1] + dp[i-2]” 的依赖缩到两个变量，因此空间是 O(1)
        return prev1
```

- 时间复杂度：`O(n)`，一次线性循环
- 空间复杂度：`O(1)`，仅常数级变量