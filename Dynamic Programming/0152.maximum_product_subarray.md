# 152.乘积最大子数组

题目链接：[152.乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

## 题目大意

给一个整数数组 `nums`，请找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积

测试用例的答案是一个`32-位`整数

```js
Example 1:
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

Example 2:
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

限制：
- 1 <= nums.length <= 2 * 10^4
- -10 <= nums[i] <= 10
- The product of any subarray of nums is guaranteed to fit in a 32-bit integer.

## 解题

暴力法：
- 遍历所有子数组，逐个计算其乘积，记录最大值
  ```python
  max_product = float('-inf')
  for i in range(len(nums)):
    prod = 1
    for j in range(i, len(nums)):
        prod *= nums[j]
        max_product = max(max_product, prod)
  ```
- 时间复杂度：`O(n²)`，在数据量大的时候会超时 
- 问题：
  - 每个起点都要重新乘一次，重复计算
  - 无法高效利用之前的结果


观察到的问题：
-「乘积」不同于「和」，它会被负数和 `0` 的出现打断
- 比如：
  - 一个负数可能会让最大值变成最小值
  - 但若连续两个负数，反而可能变成最大值

关键点：
- 在每一步不能只记录“最大乘积”，还必须同时记录“最小乘积”
- 因为当前值是负数时，最大值可能来源于最小值 × 当前值

状态定义：
- `maxSoFar`：以当前元素结尾的最大连续子数组乘积
- `minSoFar`：以当前元素结尾的最小连续子数组乘积（为了应对负数翻转）
- `res`：记录全局最大值


算法的核心思想：
- 同时跟踪到当前位置的最大乘积和最小乘积
- 最小乘积是必要的，因为当遇到负数时，最小乘积乘以负数可能会变成新的最大乘积
- 对于每个数，计算：
  - 包含当前数的最大乘积
  - 包含当前数的最小乘积
- 持续更新全局最大乘积

注意：因为状态转移方程中只涉及到当前元素和前一个元素，所以可以不使用数组，只使用两个变量来维护最大乘积和最小乘积 - `写法 2`
，定义两个变量：
- `max_num`：当前以 `nums[i]` 结尾的 最大乘积
- `min_num`：当前以 `nums[i]` 结尾的 最小乘积（因为当前是负数时可能变最大）
- 同时维护一个全局最大值 `res`

```js
var maxProduct = function(nums) {
    let n = nums.length;
    if(n === 0) return 0;
    let maxSoFar = nums[0], minSoFar = nums[0];
    let res = nums[0];
    for (let i = 1; i < n; i++) {
        let cur = nums[i];
        let tempMax = Math.max(cur, maxSoFar * cur, minSoFar * cur);
        minSoFar = Math.min(cur, maxSoFar * cur, minSoFar * cur);
        maxSoFar = tempMax;
        res = Math.max(res, maxSoFar);
    }
    return res;
};
```
```python
# 写法 1
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        # 若数组为空，直接返回 0（虽然题目中一般不会出现空数组）
        if n == 0:
            return 0
        
        # 初始化：
        # 第一个元素既是当前最大值 maxSoFar，也是最小值 minSoFar
        # 同时用它初始化最终结果 res
        maxSoFar, minSoFar = nums[0], nums[0]
        res = nums[0]

        # 遍历从第 1 个元素到最后一个元素（因为第 0 个已经初始化）
        for i in range(1, n):
            cur = nums[i]

            # 计算以当前元素结尾的最大值：
            # 三种可能：
            # - 当前值自己断开新开始：cur
            # - 当前值 × 上一轮最大值（继续扩展最大）: maxSoFar * cur
            # - 当前值 × 上一轮最小值（若 cur 为负数）: minSoFar * cur
            # 注意：不能立即更新 maxSoFar，因为下一行还需要旧的 maxSoFar
            # 一旦更新了 max_so_far，就无法再直接使用它来计算 min_so_far，因为 min_so_far 也依赖于更新前的 max_so_far
            # 直接更新 max_so_far 会影响到 min_so_far 的计算，因此需一个临时变量来保存新的 max_so_far 值
            tempMax = max(cur, maxSoFar * cur, minSoFar * cur)
            # 同样更新当前的最小值（为了防止下一轮出现负数翻转变最大）
            minSoFar = min(cur, cur * maxSoFar, minSoFar * cur)
            # 更新真正的 maxSoFar 为刚才的 tempMax
            maxSoFar = tempMax
            # 比较当前全局最大乘积是否需要更新
            res = max(res, maxSoFar)
        
        # 返回最终结果
        return res

# 写法 2
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # 获取数组长度
        n = len(nums)
        # 初始化：
        # max_num：以第一个元素为结尾的最大乘积
        # min_num：以第一个元素为结尾的最小乘积
        max_num, min_num = nums[0], nums[0]
        # res：记录全局最大乘积结果
        res = nums[0]
        
        # 从第二个元素开始遍历数组（第一个已经作为初始值处理）
        for i in range(1, n):
            # 保存上一个状态的最大和最小值
            # 由于 max_num 会在下一行更新，而还需要旧的 max_num 计算 min_num，因此临时保存
            temp_max = max_num
            temp_min = min_num

            # 更新当前最大乘积，三种可能：
            # 当前值自己单独成为新的起点
            # 当前值 × 上一轮最大乘积（继续扩展）
            # 当前值 × 上一轮最小乘积（如果当前为负值，反而可能变大）
            max_num = max(temp_max * nums[i], nums[i], temp_min * nums[i])
            # 同样更新当前最小乘积：同样考虑三种情况
            min_num = min(temp_min * nums[i], nums[i], temp_max * nums[i])
            # 更新全局最大值 res，取当前最大乘积和历史最大值之间的最大者
            res = max(max_num, res)

        # 返回最终结果
        return res
```

- 时间复杂度：`O(n)`，`n` 是数组的长度，只需遍历数组一次
- 空间复杂度：`O(1)`，只使用了固定数量的额外变量，不论输入规模如何