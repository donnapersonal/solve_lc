# 64.最小路径和

题目链接：[64.最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

## 题目大意

给定一个包含非负整数的 `m x n` 网格 `grid`，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小

说明：每次只能向下或者向右移动一步

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8vn9akd84f.webp)

限制：
- m == grid.length，n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i][j] <= 200

## 解题

暴力递归
- 直接从 `(m-1, n-1)` 向上或向左回溯，尝试所有路径
- 缺点：存在大量重复子问题，效率极低，时间复杂度是指数级别 `O(2^(m+n))`

### 思路 1：记忆化搜索（Top-down + Memoization）

一般来说，让在二维矩阵中求最优化问题（最大值或最小值），可以想到`递归 + 备忘录`，即动态规划技巧

通过递归地计算到达每个格子的最小路径和，并使用备忘录来避免重复计算，从而提升效率

思路：
- 使用 `dp(i, j)` 表示从 `(0, 0)` 到 `(i, j)` 的最小路径和
- 状态转移方程：`dp(i,j)=min(dp(i−1,j),dp(i,j−1))+grid[i][j]`
- 使用二维数组 `memo[i][j]` 记录已经计算过的结果，避免重复递归

优点：
- 把暴力递归优化为 带缓存的递归（记忆化搜索）
- 时间复杂度降为 `O(m × n)`，空间复杂度也为 `O(m × n)`

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 获取网格的行数 m 和列数 n
        m, n = len(grid), len(grid[0])
        # 初始化一个 memo 数组用来做记忆化缓存，初始值为 -1 表示尚未计算
        self.memo = [[-1 for _ in range(n)] for _ in range(m)]
        # 调用递归函数，从右下角 (m-1, n-1) 反推路径和
        return self.dp(grid, m - 1, n - 1)
    
    # 定义递归函数 dp(i, j) 表示从 (0,0) 到 (i,j) 的最小路径和
    def dp(self, grid: List[List[int]], i: int, j: int) -> int:
        # 边界条件：如果到达起点 (0,0)，最小路径就是该点的值
        if i == 0 and j == 0:
            return grid[0][0]
        
        # 越界处理：当访问非法坐标（左边或上边界外）时，返回无穷大（不会被选中）
        if i < 0 or j < 0:
            return float('inf')
        
        # 如果 memo[i][j] 不等于 -1，表示已经计算过该位置的最小路径和，直接返回 memo[i][j]，避免重复计算
        if self.memo[i][j] != -1:
            return self.memo[i][j]
        
        # 将计算结果记入备忘录
        # self.dp(grid, i - 1, j) 表示从上方的格子到达当前格子的最小路径和
        # self.dp(grid, i, j - 1) 表示从左方的格子到达当前格子的最小路径和
        # 两者取最小值，然后加上当前格子的值 grid[i][j]，得到到达 (i, j) 的最小路径和
        # 将结果存入 memo[i][j]，以便后续直接使用
        self.memo[i][j] = min(self.dp(grid, i - 1, j), self.dp(grid, i, j - 1) ) + grid[i][j]
        # 返回结果
        return self.memo[i][j]  
```

- 时间复杂度：`O(m×n)`，`m` 和 `n` 是 `grid` 的行数和列数。每个位置的最小路径和只会被计算一次，因此总的计算量为 `O(m×n)`
- 空间复杂度：`O(m×n)`，由于使用了 `memo` 备忘录，存储每个位置的最小路径和，因此空间复杂度为 `O(m×n)`

### 思路 2：动态规划（Bottom-up DP）+原地修改

思路：
- 定义状态：使用一个二维数组 `dp`，`dp[i][j]` 表示到达位置 `(i, j)` 时的最小路径和
- 状态转移方程：
  - 对于位置 `(i, j)`，可以从上方 `(i-1, j)` 或左方 `(i, j-1)` 到达。因此，`dp[i][j]` 的值为当前网格的值加上其上方或左方的最小路径和，即：`dp[i][j] = grid[i][j] + min(dp[i−1][j], dp[i][j−1])`
  - 如果在第一行，只能从左边过来：`dp[0][j] = dp[0][j-1] + grid[0][j]`
  - 如果在第一列，只能从上面过来：`dp[i][0] = dp[i-1][0] + grid[i][0]`
- 初始化：`dp[0][0] = grid[0][0]`，表示起点的路径和就是起点的值
- 结果：最终答案为 `dp[m-1][n-1]`，即到达右下角的最小路径和

```js
var minPathSum = function(grid) {
    const m = grid.length, n = grid[0].length;
    // 初始化第一列
    for (let i = 1; i < m; i++) {
        grid[i][0] += grid[i - 1][0];
    }

    // 初始化第一行
    for (let j = 1; j < n; j++) {
        grid[0][j] += grid[0][j - 1];
    }

    // 填充dp数组
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
        }
    }

    return grid[m - 1][n - 1];
};
```
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 获取 grid 的行数 m 和列数 n
        m, n = len(grid), len(grid[0])
        # 初始化第一列：只能从上面走下来，因此每一格都是上方的累加值
        for i in range(1, m):
            grid[i][0] += grid[i - 1][0]
        
        # 初始化第一行：只能从左边走过来，因此每一格是左边的累加值
        for j in range(1, n):
            grid[0][j] += grid[0][j - 1]
        
        # 从 (1,1) 开始遍历所有格子
        for i in range(1, m):
            for j in range(1, n):
                # 每个格子只能从上方或左方来，取两者路径和较小的，加上当前格子值，得到当前位置的最小路径和
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        
        # 返回终点格子的最小路径和结果
        return grid[m - 1][n - 1]

# 写法 2
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = grid[0]  # 这里没有拷贝，f 和 grid[0] 都持有同一段内存
        for j in range(1, n):
            dp[j] += dp[j - 1]

        for i in range(1, m):
            dp[0] += grid[i][0]
            for j in range(1, n):
                dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]

        return dp[-1]
```

- 时间复杂度：`O(m * n)`，`m` 是网格的行数，`n` 是网格的列数，需遍历整个网格一次，每个单元格只被访问一次
- 空间复杂度：`O(1)`
  - 直接在原网格上修改，不需要额外空间
  - 如果不允许修改原数组，空间复杂度会是 `O(m * n)`