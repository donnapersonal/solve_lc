# 72.编辑距离

题目链接：[72.编辑距离](https://leetcode.cn/problems/edit-distance/description/)

## 题目大意

给两个单词 `word1` 和 `word2`，请返回将 `word1` 转换成 `word2` 所使用的最少操作数  

可以对一个单词进行如下三种操作：
- 插入一个字符
- 删除一个字符
- 替换一个字符

```js
Example 1:
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

限制：
- 0 <= word1.length, word2.length <= 500
- word1 and word2 consist of lowercase English letters.

## 解题

暴力 DFS / 回溯（超时）
- 尝试对 `word1` 每个位置插入/删除/替换字符，让它和 `word2` 尽量一致
- 分支数量非常庞大（指数级复杂度），无法处理较长字符串
- 时间复杂度：`O(3^n)`，`TLE`

### 思路 1: 动态规划

核心思想：使用二维动态规划表 `dp[i][j]` 表示将 `word1[0:i]` 转换成 `word2[0:j]` 的最小操作数

状态定义：`dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需的最少操作数

状态转移公式：
- 如果 `word1[i-1] == word2[j-1]`：字符相同，无需操作 → `dp[i][j] = dp[i-1][j-1]`
- 否则，取三种操作的最小值：
  - 插入：`dp[i][j-1] + 1`
  - 删除：`dp[i-1][j] + 1`
  - 替换：`dp[i-1][j-1] + 1`

边界初始化：
- `dp[0][j] = j`：将空串变成 `word2[0:j]` 需插入 `j` 次
- `dp[i][0] = i`：将 `word1[0:i]` 变成空串需要删除 `i` 次


```js
var minDistance = function(word1, word2) {
    let m = word1.length, n = word2.length;
    let dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++)
        dp[i][0] = i;
    
    for (let j = 1; j <= n; j++)
        dp[0][j] = j;

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1.charAt(i-1) == word2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + 1);
            }
        }
    }

    return dp[m][n]
};
```
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 获取两个字符串的长度
        m, n = len(word1), len(word2)
        # 初始化 dp 二维数组，大小为 (m+1) x (n+1)
        dp = [[0] * (n+1) for _ in range(m+1)]
        # 初始化第一列：将 word1 的前 i 个字符变成空串，需删除 i 次
        for i in range(1, m+1):
            # 初始化 dp[i][0] 的值，表示将 word1[0:i] 转换为空字符串所需的最小操作次数
            # 即需要进行 i 次删除操作
            dp[i][0] = i
        
        # 初始化第一行：将空串变成 word2 的前 j 个字符，需插入 j 次
        for j in range(1, n+1):
            # 初始化 dp[0][j] 的值，表示将空字符串转换为 word2[0:j] 所需的最小操作次数
            # 即需要进行 j 次插入操作
            dp[0][j] = j
        
        # 填充整个 dp 表
        for i in range(1, m+1):
            for j in range(1, n+1):
                # 字符相同，无需操作
                if word1[i-1] == word2[j-1]:
                    # dp[i][j] 表示将 word1[0:i] 转换为 word2[0:j] 所需的最小操作次数
                    dp[i][j] = dp[i-1][j-1]
                else:
                    # 选择插入、删除或替换操作中的最小值，并加 1 表示进行了一次操作
                    # dp[i-1][j-1] + 1 # 替换操作
                    # dp[i-1][j] + 1   # 删除操作
                    # dp[i][j-1] + 1)  # 插入操作
                    dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1)
       
        # 返回 dp[m][n]，即将 word1 转换为 word2 的最小编辑距离
        return dp[m][n]
```

- 时间复杂度：`O(m×n)`，其中 `m` 和 `n` 分别是 `word1` 和 `word2` 的长度
  - 需要填充一个大小为 `m x n` 的 `dp` 数组，每个位置的计算复杂度为 `O(1)`，因此总体时间复杂度为 `O(m×n)`
- 空间复杂度：`O(m×n)`，使用了一个大小为 `m x n` 的 `dp` 数组来保存中间结果

### 思路 2: 空间优化

观察转移公式发现当前 `dp[i][j]` 只依赖：
- 上一行：`dp[i-1][j]`, `dp[i-1][j-1]`
- 当前行左侧：`dp[i][j-1]`

所以只需用两个一维数组（`prev, cur`）滚动更新即可

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 获取两个字符串的长度，分别记为 m 和 n
        m, n = len(word1), len(word2)
        # 初始化上一行 prev，表示 dp[0][*]：
        # 当 word1 是空串时，把它变成 word2[:j] 需要插入 j 个字符
        # 所以 prev = [0, 1, 2, ..., n]
        prev = list(range(n+1))
        # 初始化当前行 cur，每轮循环都重置这个数组，从头填一行
        cur = [0] * (n+1)

        # 外层循环：遍历 word1 的每个字符。i 表示当前考虑 word1[:i]
        for i in range(1, m+1):
            # 边界条件：将 word1[:i] 变成空串 → 删除 i 次
            cur[0] = i

            # 内层循环：遍历 word2 的每个字符。j 表示当前考虑 word2[:j]
            for j in range(1, n+1):
                # 如果当前字符相同（注意是 i-1 和 j-1，因为字符串从 0 开始）：无需操作，直接继承左上角 prev[j-1]
                if word1[i-1] == word2[j-1]:
                    cur[j] = prev[j-1] 
                else:
                    # 否则，三种操作取最小值 + 1：
                    # prev[j-1] + 1：替换
                    # prev[j] + 1：删除
                    # cur[j-1] + 1：插入
                    cur[j] = min(prev[j-1] + 1, prev[j] + 1, cur[j-1] + 1)
            
            # 当前行计算完毕，复制给 prev，准备下一行
            # 注意要用 [:] 拷贝，否则只是引用，会影响后续计算
            prev = cur[:] 
        
        # 最终答案在 prev[n] 中，即将 word1[:m] 转成 word2[:n] 所需的最小操作数
        return prev[n]
```

- 时间复杂度：`O(m × n)`，双重循环遍历两个字符串每个字符组合
- 空间复杂度：`O(n)`，只保留当前行与上一行两个数组（长度 `n+1`）