# 1049.最后一块石头的重量 II

题目链接：[1049.最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

## 题目大意

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
- 如果 x == y，那么两块石头都会被完全粉碎
- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x
  
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0

```js
Example 1:
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.

Example 2:
Input: stones = [31,26,33,21,40]
Output: 5
```

限制:
- 1 <= stones.length <= 30
- 1 <= stones[i] <= 100

## 解题

**Step 1: 暴力模拟（❌ TLE）**
- 最直接的想法是：每次枚举两块石头，把它们撞一下，把新的数组加入回去，递归继续；直到只剩下一块石头，记录其重量
- 但是：
  - 每次都有多个组合可选 → 可能性指数级爆炸
  - 时间复杂度是 `O(2^n)`，远远超时 ❌

**Step 2: 转换为「子集划分问题」**
- 这是一个经典套路：撞石头操作的本质是减法操作
- 我们最终目的不是模拟每一次，而是思考 如何让正负石头抵消，让最后剩下的尽可能小
- 将所有石头划分成两个集合 `S1` 和 `S2`，使得它们的和的差最小
  - 即我们要最小化 `abs(sum(S1) - sum(S2))`
  - 可以转化为一个 `0/1` 背包问题，在数组中选择一些石头，使它们的和尽量接近 `sum // 2`

**Step 3: 背包动态规划（最优解）**
- 定义：`dp[j] = True/False` 表示是否能选出一部分石头，使得总和为 `j`
- 最终目标：求最大 `j`，使得 `dp[j] == True` 且 `j <= sum // 2`，那么答案就是 `sum - 2 * j`

```js
var lastStoneWeightII = function(stones) {
    const total = stones.reduce((a, b) => a + b, 0);
    const target = Math.floor(total / 2);
    const dp = new Array(target + 1).fill(false);
    dp[0] = true;

    for (const stone of stones) {
        for (let j = target; j >= stone; j--) {
            dp[j] = dp[j] || dp[j - stone];
        }
    }

    for (let j = target; j >= 0; j--) {
        if (dp[j]) {
            return total - 2 * j;
        }
    }
    return 0;
};
```
```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        # 计算所有石头的总和 total。最终我们要将总重量尽量平分
        total = sum(stones)
        n = len(stones)
        # 希望从数组中选出一个子集，使得它的和尽量接近 total // 2（背包容量）
        target = total // 2
        # 初始化一维 DP 数组：
        # dp[j] = True 表示是否可以选出若干个石头，使得和为 j
        # 初始状态：和为 0 一定可以（不选任何石头）
        dp = [False] * (target + 1)
        dp[0] = True

        # 遍历每一块石头
        for stone in stones:
            # 逆序遍历背包容量 j，从大到小（为了保证每块石头只被用一次）
            for j in range(target, stone - 1, -1):
                # 状态转移：如果 j - stone 可达，那么 j 也可达（表示可以选这块石头放入背包）
                dp[j] = dp[j] or dp[j - stone]
        
        # 从最大容量 target 向下找，找到最接近 target 的可达值
        for j in range(target, -1, -1):
            # 找到第一个可达的子集和 j，就能计算出最小剩余重量：total - 2*j
            if dp[j]:
                return total - 2 * j

        # 如果都不可达（理论上不会出现），返回 0  
        return 0

        # 写法 2
        # res = None
        # for j in range(m, -1, -1):
            # if dp[n][j]:
                # res = total - 2 * j
                # break
        
        # return res
```

- 时间复杂度：`O(n⋅sum)`。其中 `n` 是数组 `stones` 的长度，`sum` 为 `stones` 所有元素之和
- 空间复杂度：`O(sum)`