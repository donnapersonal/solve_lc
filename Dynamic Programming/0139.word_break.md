# 139.单词拆分

题目链接：[139.单词拆分](https://leetcode.cn/problems/word-break/)

## 题目大意

给一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`

注意：不要求字典中出现的单词全部都使用，且字典中的单词可以重复使用

```js
Example 1:
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

Example 2:
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.

Example 3:
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
```

限制：
- 1 <= s.length <= 300
- 1 <= wordDict.length <= 1000
- 1 <= wordDict[i].length <= 20
- s and wordDict[i] consist of only lowercase English letters.
- All the strings of wordDict are unique

## 解题

暴力解法：递归 + 回溯
- 可以尝试从字符串的开头开始，尝试所有可能的切分，只要某个前缀在字典中，就递归地判断剩余部分是否可以继续切分
- 缺点：重复子问题太多，例如判断 "code" 会被重复调用多次
- 时间复杂度指数级，效率低下

### 思路 1: DP

优化：动态规划（Dynamic Programming）
- 为了避免重复判断，可以引入`DP数组`来记录每一个前缀是否可以被拆分

按照单词结尾位置进行阶段划分

`s` 能否拆分为单词表的单词，可以分解为：
- 前 `i` 个字符构成的字符串，能否分解为单词
- 剩余字符串，能否分解为单词

核心思想：
- 定义 `dp[i]` 表示：`s[0:i]`（不包含第 `i` 个字符）是否可以被拆分成字典中的单词
- 初始状态：长度为 `0` 的字符串 `s[0:i]` 可以拆分为单词，即 `dp[0] == true`
- 状态转移方程：
  - 如果 `s[0:j]` 可以拆分为单词（即 `dp[j] == true`），且字符串 `s[j:i]` 出现在字典中，则 `dp[i] = true`
  - 如果 `s[0:j]` 不可以拆分为单词（即 `dp[j] == false`），或字符串 `s[j:i]` 没出现在字典中，则 `dp[i] = false`

根据之前定义的状态，`dp[i]` 表示长度为 `i` 的字符串 `s[0:i]` 能否拆分成单词。则最终结果为 `dp[size]`，`size` 为字符串长度

```js
var wordBreak = function(s, wordDict) {
    // 将 wordDict 转化为 Set，便于快速查找
    const wordSet = new Set(wordDict);
    const size = s.length;
    const dp = new Array(size + 1).fill(false);  // 初始化 dp 数组
    dp[0] = true;  // 空字符串可以被拆分
    for (let i = 1; i <= size; i++) {
        // 遍历 i 之前的所有位置 j
        for (let j = 0; j < i; j++) {
            // 如果 dp[j] 为 true，并且 s[j:i] 在字典中，则 dp[i] 置为 true
            if (dp[j] && wordSet.has(s.substring(j, i))) {
                dp[i] = true;
                break; // 如果找到了一个可以拼接的位置，就不用再继续检查其他位置
            }
        }
    }
    return dp[size];  // 返回整个字符串是否可以被拼接
};
```
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # 为了提高查询效率（O(1) 查询），将 wordDict 转为一个集合 word_set
        # list in 查询是 O(n)，而 set in 是 O(1)
        word_set = set(wordDict)
        # 获取字符串 s 的长度，后续用于 dp 数组初始化和循环。
        size = len(s)
        # 初始化一个长度为 size + 1 的布尔型数组 dp，全部为 False
        # dp[i] 表示 s[0:i] 是否可以被拆分
        dp = [False] * (size + 1)
        # 空字符串是可以被成功拆分的，所以设为 True
        # 动态规划的起点
        dp[0] = True

        # 外层循环控制终点 i，将检查字符串 s[0:i] 是否可拆分
        for i in range(1, size + 1):
            # 内层循环控制切分点 j，枚举 s[0:i] 所有可能的切分位置
            # 关心的是 s[0:j] 是否可拆，s[j:i] 是否在字典中
            for j in range(i):
                # 如果前一段 s[0:j] 可以被拆分（即 dp[j] == True）并且当前段 s[j:i] 存在于字典中，就说明 s[0:i] 可以被拆分
                if dp[j] and s[j:i] in word_set:
                    # 一旦找到一个合法的切分点，就设置 dp[i] = True，并立即 break 提前退出内循环，节省时间
                    dp[i] = True
                    break

        # 最终返回的是 dp[len(s)]，表示整个字符串是否能被拆分
        return dp[size]
```

- 时间复杂度：`O(n^2)`
  - 总共有 `n` 个 `dp` 状态（`n` 是字符串的长度），每个 `dp[i]` 需检查 `j` 到 `i` 的子串（最坏情况下是 `O(n)` 次），因此，总时间复杂度为 `O(n^2)`
  - 查找 `s[j:i]` 是否在 `wordDict` 中的操作是 `O(1)`（因为使用了 `set`）
- 空间复杂度：`O(n)`
  - 需一个 `dp` 数组来存储 `n + 1` 个状态，空间复杂度为 `O(n)`
  - 还需一个集合来存储 `wordDict` 中的单词，空间复杂度为 `O(m)`，`m` 是 `wordDict` 中所有单词的总长度（如果不考虑哈希表的开销，可以忽略）

### 思路 2: 记忆化 DFS

此思路采用`记忆化 DFS`；
- 对每个位置 `i`，尝试匹配每个词典中的单词
- 如果当前单词 `word` 能匹配上 `s[i:i+len(word)]`，就递归判断 `s[i+len(word):]`
- 若后续成功，则当前也成功，记录在 `memo[i]` 中
- 否则，继续尝试其他单词

```js
var wordBreak = function(s, wordDict) {
    let memo = new Array(s.length).fill(-1);
    var dp = function(s, i, wordDict) {
        if (i == s.length) return true;
        if (memo[i] != -1) return memo[i] == 1;
        for (let word of wordDict) {
            let len = word.length;
            if (i + len > s.length) continue;
            let subStr = s.substring(i, i + len);
            if (subStr !== word) continue;
            if (dp(s, i + len, wordDict)) {
                // s[i..] 可以被拼出，将结果记入备忘录
                memo[i] = 1;
                return true;
            }
        }
        memo[i] = 0;
        return false;
    };
    return dp(s, 0, wordDict);
};
```
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # memo 是一个长度为 len(s) 的数组
        # 每个下标代表从 s[i:] 开始的子串是否可以成功拆分：
        # - memo[i] == 1：可以拆分
        # - memo[i] == 0：无法拆分
        # - memo[i] == -1：尚未计算
        # 即 -1 代表未计算，0 代表 false，1 代表 true
        self.memo = [-1] * len(s)
        # 从下标 0 开始尝试匹配
        return self.dp(s, 0, wordDict)

    # 定义：返回 s[i..] 是否能够被 wordDict 拼出
    def dp(self, s: str, i: int, wordDict: List[str]) -> bool:
        # 递归终点：当 i 到达字符串末尾，说明整个字符串已被成功匹配，返回 True
        if i == len(s):
            return True
        
        # 记忆化返回：如果已经计算过 s[i:] 的结果，直接返回
        # 防止冗余计算
        if self.memo[i] != -1:
            return self.memo[i] == 1
        
        # 遍历所有单词，尝试匹配 s[i..] 的前缀
        # 遍历字典中的每个单词 word，尝试匹配 s[i:] 的前缀
        for word in wordDict:
            length = len(word)
            # 如果 i + len(word) 超出字符串范围，则跳过（防止越界）
            if i + length > len(s):
                continue
            
            # 提取当前子串并检查是否等于字典中的 word；如果不匹配，跳过
            subStr = s[i:i + length]
            if subStr != word:
                continue
            
            # s[i..] 的前缀被匹配，去尝试匹配 s[i+len..]
            # ✅ 递归成功
            # - 如果当前单词匹配，并且剩下的部分也能成功匹配（dp(i + len(word)) == True）
            # - 说明 s[i:] 是可以被成功拆分的，记录为 1，并返回 True
            if self.dp(s, i + length, wordDict):
                self.memo[i] = 1
                return True
        
        # 所有 word 都试过失败，记录为失败
        # 当前 s[i:] 无法拆分，记录为 0，返回 False
        self.memo[i] = 0
        return False
```

- 时间复杂度: `O(n * m * k)`
  - `n` 是字符串 `s` 的长度
  - `m` 是字典中所有单词的平均长度
  - `k` 是字典 `wordDict` 中单词的数量
  - 在最坏情况下，递归会检查每个索引 `i` 处的所有字典中的单词。对于每个位置 `i`，需检查字典中的所有单词（`k` 个），每次查找子字符串的操作时间复杂度为 `O(m)`
- 空间复杂度: `O(n)`

更细化的：
![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2h8nl6vadb.webp)
