# 1312.让字符串成为回文串的最少插入次数

题目链接：[1312.让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

## 题目大意

给你一个字符串 `s`，每一次操作你都可以在字符串的任意位置插入任意字符

请你返回让 `s` 成为回文串的 最少操作次数 

「回文串」是正读和反读都相同的字符串

```js
Example 1:
Input: s = "zzazz"
Output: 0
Explanation: The string "zzazz" is already palindrome we do not need any insertions.

Example 2:
Input: s = "mbadm"
Output: 2
Explanation: String can be "mbdadbm" or "mdbabdm".

Example 3:
Input: s = "leetcode"
Output: 5
Explanation: Inserting 5 characters the string becomes "leetcodocteel".
```

限制:
- 1 <= s.length <= 500
- s consists of lowercase English letters.

## 解题

本质上，这是在问：`最少插入多少字符，使得 s 变成回文？`

等价于：`s 的最小插入次数 = s.length - s 的最长回文子序列长度（LPS）`

使用区间动态规划
- 定义二维 `dp` 表：`dp[i][j] = 将 s[i..j] 变成回文所需的最小插入次数`
- 状态转移：
  - 如果 `s[i] == s[j]`，则不需要插入：`dp[i][j] = dp[i+1][j-1]`
  - 否则，必须在两端插入：`dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1`
- 初始化：所有 `dp[i][i] = 0`，因为一个字符天然是回文

```js
var minInsertions = function(s) {
    const n = s.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    for (let length = 2; length <= n; length++) {
        for (let i = 0; i <= n - length; i++) {
            const j = i + length - 1;
            if (s[i] === s[j]) {
                dp[i][j] = dp[i + 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
            }
        }
    }

    return dp[0][n - 1];
};
```
```python
class Solution:
    def minInsertions(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1]
                else:
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
        
        return dp[0][n - 1]
```

- 时间复杂度：`O(n^2)`，其中 `n` 是字符串 `s` 的长度
- 空间复杂度：`O(n^2)`

**空间优化**

观察状态依赖关系：`dp[i][j] 依赖于 dp[i+1][j], dp[i][j-1], dp[i+1][j-1]`

注意：我们是从小区间长度开始更新，所以可使用`一维数组 + 临时变量`的技巧

```python
class Solution:
    def minInsertions(self, s: str) -> int:
        n = len(s)
        dp = [0] * n  
        for i in range(n - 2, -1, -1): 
            pre = 0  
            for j in range(i + 1, n):  
                temp = dp[j] 
                if s[i] == s[j]:
                    dp[j] = pre
                else:
                    dp[j] = min(dp[j], dp[j - 1]) + 1
                pre = temp 
        return dp[n - 1]
```

- 时间复杂度：`O(n²)`
- 空间复杂度：`O(n) `