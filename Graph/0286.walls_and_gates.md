# 286.墙与门

题目链接：[286.墙与门](https://leetcode.cn/problems/walls-and-gates/)

## 题目大意

你被给定一个 m × n 的二维网格 rooms ，网格中有以下三种可能的初始化值：
- -1 表示墙或是障碍物
- 0 表示一扇门
- INF 无限表示一个空的房间。然后，我们用 231 - 1 = 2147483647 代表 INF。你可以认为通往门的距离总是小于 2147483647 的

你要给每个空房间位上填上该房间到 最近门的距离 ，如果无法到达门，则填 INF 即可

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.99ttgjwgpp.webp)

限制:
- m == rooms.length, n == rooms[i].length
- 1 <= m, n <= 250
- rooms[i][j] is -1, 0, or 231 - 1.

## 解题

优化思路：`多源 BFS`
- 观察题目：门是 固定的起点，房间是终点
- 如果从每个门出发进行 `BFS`，同时更新每个房间的最短距离，可以：
  - 避免对每个房间单独 `BFS`
  - 一次 `BFS` 就能填出所有房间的最短距离
- 关键点：
  - 墙（-1）不可通行
  - `BFS` 保证 先到达的距离最短

为什么 `BFS` 可以得到最优解?
- `BFS` 是层序遍历，每一层距离增加 `1`
- `多源 BFS`：从所有门同时入队 → 每次 `BFS` 扩展一层 → 空房间首次被访问的距离就是最近门的距离

```js
/**
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
    // Use the specific value for ROOM
    const ROOM = 2147483647;
    const GATE = 0;

    let m = rooms.length;
    let n = rooms[0].length;

    let q = [];
    // 把所有的门放入队列，作为 BFS 遍历的起点
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (rooms[i][j] === GATE) {
                q.push([i, j]);
            }
        }
    }

    let dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    // 开始执行 BFS 算法，根据 BFS 算法的特性，第一次遍历到新节点所走的步数就是最短距离
    while (q.length > 0) {
        let cur = q.shift();
        let x = cur[0], y = cur[1];
        for (let d of dirs) {
            let next_x = x + d[0], next_y = y + d[1];
            if (next_x < 0 || next_y < 0 || next_x >= m || next_y >= n
                || rooms[next_x][next_y] !== ROOM) {
                // 这个位置是障碍物或者已经计算出最短距离了，跳过
                continue;
            }
            // 计算出 (next_x, next_y) 达到最近的门的距离
            rooms[next_x][next_y] = rooms[x][y] + 1;
            q.push([next_x, next_y]);
        }
    }
};
```
```python
class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        # 定义常量，更直观
        # ROOM：空房间
        # GATE：门
        ROOM = 2147483647
        GATE = 0

        # 获取网格行数 m 和列数 n
        m = len(rooms)
        n = len(rooms[0])

        # 初始化 BFS 队列，使用双端队列 deque，O(1) 出队入队
        que = deque()
        # 将所有门的坐标加入 BFS 队列
        # 多源 BFS 起点 → 每个门同时开始扩展
        for i in range(m):
            for j in range(n):
                if rooms[i][j] == GATE:
                    que.append((i, j))
        
        # 定义四个方向（上下左右），用于遍历相邻格子
        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        while que:
            # BFS 核心循环：队列非空 → 弹出当前格子 (x, y)
            x, y = que.popleft()
            # 遍历四个方向，计算下一个格子 (next_x, next_y)
            for d in dirs:
                next_x, next_y = x + d[0], y + d[1]

                # 越界或不是空房间 → 跳过
                # 保证只访问未更新的空房间
                if next_x < 0 or next_y < 0 or next_x >= m or next_y >= n or rooms[next_x][next_y] != ROOM:
                    continue
                
                # 更新空房间距离：
                # 当前格子距离 rooms[x][y]
                # 下一层距离 = 当前距离 + 1
                # BFS 的层序保证这是 最短距离
                rooms[next_x][next_y] = rooms[x][y] + 1
                # 将更新后的房间入队，继续 BFS 扩展
                que.append((next_x, next_y))
```

- 时间复杂度：`O(mn)` 
  - 如果你对直接得到时间复杂度有困难的话，可以从简单的情况开始
  - 首先考虑只有一个门的情况，宽度优先搜索最多只需要 `m×n` 步就能到达所有的房间，所以时间复杂度是 `O(mn)`，但是如果从 `k` 个门开始呢？
  - 一旦到达了一个房间并记录下它的距离时，这意味着我们也标记了这个房间已经被访问过了，这意味着每个房间最多会被访问一次。因此，时间复杂度与门的数量无关，所以时间复杂度为 `O(mn)` 
- 空间复杂度：`O(mn)`。空间复杂度与队列的大小有关，我们最多将 `m×n` 个位置插入队列，所以空间最大为 `m×n` 

