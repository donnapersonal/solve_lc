# 743.网络延迟时间

题目链接：[743.网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

## 题目大意

有 `n` 个网络节点，标记为 `1` 到 `n`

给你一个列表 `times`，表示信号经过 有向 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点，`wi` 是一个信号从源节点传递到目标节点的时间

现在，从某个节点 `K` 发出一个信号，需多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.77dtrkpaa8.webp)

限制：
- 1 <= k <= n <= 100
- 1 <= times.length <= 6000
- times[i].length == 3
- 1 <= ui, vi <= n
- ui != vi
- 0 <= wi <= 100
- All the pairs (ui, vi) are unique. (i.e., no multiple edges.)

## 解题

经典的单源最短路径（`Single-Source Shortest Path`） 问题

> 最优解法：`Dijkstra` 算法（最短路径），适合边权为正的图中求单源最短路径

暴力 DFS 枚举所有路径思路：
- 使用 `DFS` 或 `BFS`，从起点 `k` 出发，遍历所有可能的路径
- 在每次遇到一个节点时更新其“最短时间”
- 对于一个图中的每个路径都尝试，记录所有到达某个节点的路径时间并取最小
- 问题：
  - 无法避免重复路径遍历（尤其是环或有多个路径时）
  - 可能会超时（TLE），因为图是稠密图时，组合过多
  - 复杂度：最坏 `O(n!)`，不现实

优化：`Memoized DFS`
- 引入剪枝：
  - 在 `DFS` 中记录每个节点的最短时间
  - 如果当前路径时间已经比已知最小值大，则直接剪枝
- 仍然存在问题：
  - 路径多时仍会冗余递归
  - 对于大图依旧可能超时

转向正确的解法方向：`图的单源最短路径`，我们观察到：
- `问题核心是从某点出发，找到到达所有点的最短路径`
- 不用关心所有路径的组合，只要找到最短的即可
- 边权又是正数

于是想到经典算法：`Dijkstra 算法`，关键思想：
- 使用`小根堆（优先队列）`每次取`当前距离最小的节点`进行扩展
- 每个节点只访问一次，第一次访问时即为最短路径
- 所有邻居根据当前节点的时间 + 边权加入堆中等待处理
- 最终记录所有被访问的节点时间，取最大值作为所需时间

示例逻辑：
- 起点 `k` 入堆，初始时间为 `0`
- 每次弹出时间最短的点，标记访问
- 将它的邻居加入堆，时间为`当前时间 + 边权`
- 所有点访问完成后，取 `max(到达时间)`
- 如果有节点未访问，说明无法到达，返回 `-1`

总结：从最初的暴力路径枚举（`DFS`）出发，意识到不需全部路径，而是只关心`最短路径`。因此采用了 `Dijkstra` 算法，以`优先队列 + 贪心方式`高效地找到所有节点的最短时间，并取最大值作为答案。如果有节点无法被访问，就说明无法全部到达，返回 `-1`

> 为什么是最优？
> - 使用了`贪心策略`保证每个节点最短时间在第一次访问时就被确定
> - 每个节点最多进入堆一次（只要一旦被确定最短路径就不再进）
> - 时间复杂度 `O(E log V)`，远优于暴力路径搜索

```python
# 写法 1
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))
        
        min_heap = [(0, k)]
        dist = {}

        while min_heap:
            time, node = heapq.heappop(min_heap)
            if node in dist:
                continue
            
            dist[node] = time
            for nei, wt in graph[node]:
                if nei not in dist:
                    heapq.heappush(min_heap, (time + wt, nei))
        
        return max(dist.values()) if len(dist) == n else -1

# 写法 2
```