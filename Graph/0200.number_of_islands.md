# 200.岛屿数量

题目链接：[200.岛屿数量](https://leetcode.cn/problems/number-of-islands/)

## 题目大意

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量

岛屿总是被水包围，且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成

此外，你可以假设该网格的四条边均被水包围

```js
Example 1:
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1

Example 2:
Input: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
Output: 3
```

限制：
- m == grid.length, n == grid[i].length
- 1 <= m, n <= 300
- grid[i][j] is '0' or '1'.

## 解题

思路 1：逐个计数 `'1'` 的数量（暴力法）
- 最先想到的可能是：遍历整个网格，每当遇到 `'1'` 就计数 `+1`
- 但发现不对 — 一整块连通的岛屿会被计数多次！
- 失败原因：
  - 没有判断哪些 `'1'` 是属于同一个岛屿的连通块
  - 没有标记哪些 `'1'` 已经被计数
  
但也可以发现：“一个岛屿就是一块连通区域”
- 那若每次遇到 `'1'`，就从这个点出发，把它所有相邻的 `'1'` 全部标记为 `'0'`，那这块区域就不会被重复计数了
- 这就引出了经典图遍历方法：`DFS（深度优先搜索）`

实现核心逻辑：
- 遍历每个格子，遇到 `'1'`：
  - 计数 `+1`
  - 从这个点 `DFS`，向四个方向递归，把所有 `'1'` 都变成 `'0'`
- 这其实是「`Flood Fill` 模板」：像水墨渲染一样，从一个点开始扩散

本题本质是一个典型的「二维图连通块计数问题」，可以通过 `DFS` 或 `BFS` 遍历整个图。每当遇到一个未访问的 `'1'`，就从该点出发将其所属的整个岛屿“淹没”处理并计数 `+1`。这样每个岛屿只会被遍历一次，从而避免重复计数，保证准确性与高效性

> 为什么每次遇到岛屿，可想到要用 `DFS` 算法把岛屿「淹了」呢？
> - 主要是为了省事，避免维护 `visited` 数组
> - 一般遍历图是需 `visited` 数组记录遍历过的节点防止走回头路
> - `dfs` 函数遍历到值为 `0` 的位置会直接返回，所以只要把经过的位置都设置为 `0`，就可以起到不走回头路的作用

> 扩展：`用 BFS 替代 DFS（更稳定）`
> - `DFS` 虽然能做，但面试官可能会问：“当网格很大、岛屿很大时，是否有栈溢出的风险？”
> - 是的，`DFS` 是递归写法，会用到调用栈。于是可自然会想到用队列实现 `BFS`（广度优先搜索） 来规避风险
>
> 为什么这也是自然推导？
> - 图的遍历方式一共有两种：`DFS` 和 `BFS`
> - 如果在刷题中对 `DFS` 模板熟悉，`BFS` 是天然的候选替代品

```js
var numIslands = function(grid) {
    let res = 0;
    let m = grid.length, n = grid[0].length;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === '1') {
                // 每发现一个岛屿，岛屿数量加一
                res++;
                // 然后使用 DFS 将岛屿淹了
                dfs(grid, i, j);
            }
        }
    }
    return res;
};

// 从 (i, j) 开始，将与之相邻的陆地都变成海水
var dfs = function(grid, i, j) {
    let m = grid.length, n = grid[0].length;
    // 超出索引边界
    if (i < 0 || j < 0 || i >= m || j >= n) return;

    // 已经是海水了
    if (grid[i][j] === '0') return;
    // 将 (i, j) 变成海水
    grid[i][j] = '0';

    // 淹没上下左右的陆地
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
};
```
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        res = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    # 每发现一个岛屿，岛屿数量加一
                    res += 1
                    # 然后使用 DFS 将岛屿淹了
                    # 调用 dfs 函数，将与该 '1' 相连的所有 '1' 转化为 '0'（表示将岛屿淹没），避免重复计算
                    self.dfs(grid, i, j)
        
        return res
    
    def dfs(self, grid, i, j):
        m, n = len(grid), len(grid[0])
        # 超出索引边界
        if i < 0 or j < 0 or i >= m or j >= n:
            return
        
        # 已经是海水了
        if grid[i][j] == '0':
            return
        
        # 将 (i, j) 变成海水
        grid[i][j] = "0"
        # 淹没上下左右的陆地
        # 用于将发现的岛屿（所有相连的 '1'）淹没为 '0'
        self.dfs(grid, i + 1, j)
        self.dfs(grid, i, j + 1)
        self.dfs(grid, i - 1, j)
        self.dfs(grid, i, j - 1)
```

- 时间复杂度：`O(m * n)`，`m` 和 `n` 分别为行数和列数
  - 外层循环遍历整个网格，时间复杂度是 `O(m * n)`
  - 对于每个陆地单元格（`'1'`）调用 `dfs` 函数。在最坏的情况下（整个网格都是陆地），`dfs` 函数会访问每个单元格一次
  - 虽然看起来对每个陆地单元格都调用了 `dfs`，但实际上每个单元格最多只会被访问一次。因为一旦被访问，它就会被标记为 `'0'`（海水），不会再被访问
  - 总的时间复杂度是 `O(m * n)`，因为每个单元格最多被访问两次：一次在主循环中，一次在 `DFS` 中
- 空间复杂度：
  - 这个算法没有使用任何额外的数据结构来存储信息，所有的操作都是直接在输入网格上进行的
  - 然而，需考虑递归调用栈的空间。在最坏的情况下（整个网格形成一条蛇形的岛屿），递归的深度可能达到 `m * n`
  - 因此，最坏情况下的空间复杂度是 `O(m * n)`
  - 但在平均情况下，特别是当岛屿形状比较规则时，递归深度通常不会达到这个极限，空间复杂度会更接近 `O(min(m, n))`
    - 如果一个岛屿是一条水平的直线，递归栈的最大深度为网格的宽度 `n`
    - 如果一个岛屿是一条垂直的直线，递归栈的最大深度为网格的高度 `m`
    - 在这些情况下，递归栈的最大深度接近 `min(m, n)`