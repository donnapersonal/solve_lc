# 1976.到达目的地的方案数

题目链接：[1976.到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)

## 题目大意

你在一个城市里，城市由 n 个路口组成，路口编号为 0 到 n - 1 ，某些路口之间有 双向 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路

给你一个整数 n 和二维整数数组 roads ，其中 roads[i] = [ui, vi, timei] 表示在路口 ui 和 vi 之间有一条需要花费 timei 时间才能通过的道路。你想知道花费 最少时间 从路口 0 出发到达路口 n - 1 的方案数

请返回花费 最少时间 到达目的地的 路径数目 。由于答案可能很大，将结果对 109 + 7 取余 后返回

![example](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1vz44lkirh.webp)

限制：
- 1 <= n <= 200
- n - 1 <= roads.length <= n * (n - 1) / 2
- roads[i].length == 3
- 0 <= ui, vi <= n - 1
- 1 <= timei <= 109
- ui != vi
- There is at most one road connecting any two intersections.
- You can reach any intersection from any other intersection.

## 解题

暴力 DFS / 回溯法
- 尝试遍历所有路径，记录最短时间，然后再数有多少条路径时间等于最短时间
- 缺陷：时间复杂度爆炸（指数级），无法通过大数据

思路进化：`最短路径 + 路径计数` -> `堆优化 Dijkstra（适用于稀疏图）`
- 类似 `Dijkstra`（迪杰斯特拉）最短路径算法
  - 对于每个节点，维护：
    - `dist[i]`: 从起点 `0` 到 `i` 的最短时间
    - `ways[i]`: 从起点 `0` 到 `i` 的最短路径数量
- 核心逻辑（`Dijkstra` 扩展版）：
  - 用最小堆（优先队列）按最短时间扩展节点
  - 当我们第一次以最短时间访问到某个节点时：
    - 记录 `dist[node] = 当前最短时间`
    - 将路径数量 `ways[node]` 设为到达它的所有方式之和
  - 如果有多个路径以 相同最短时间 到达同一个节点 → 把它们的路径数量叠加上去

```js
/**
 * @param {number} n
 * @param {number[][]} roads
 * @return {number}
 */
var countPaths = function(n, roads) {
    const graph = Array(n).fill(null).map(() => []); // 邻接表
    for (const [x, y, d] of roads) {
        graph[x].push([y, d]);
        graph[y].push([x, d]);
    }

    const dist = Array(n).fill(Infinity);
    dist[0] = 0;
    const ways = Array(n).fill(0);
    ways[0] = 1;
    const pq = new MinPriorityQueue(p => p[0]);
    pq.enqueue([0, 0]);
    while (!pq.isEmpty()) {
        const [dx, x] = pq.dequeue();
        if (x === n - 1) {
            return ways[n - 1];
        }
        if (dx > dist[x]) {
            continue;
        }
        for (const [y, d] of graph[x]) { 
            const newDis = dx + d;
            if (newDis < dist[y]) {
                dist[y] = newDis;
                ways[y] = ways[x];
                pq.enqueue([newDis, y]);
            } else if (newDis === dist[y]) {
                ways[y] = (ways[y] + ways[x]) % 1_000_000_007;
            }
        }
    }
};
```
```python
 Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        MOD = 10**9 + 7
        graph = defaultdict(list)
        for u, v, time in roads:
            graph[u].append((v, time))
            graph[v].append((u, time))  

        dist = [float('inf')] * n
        dist[0] = 0
        ways = [0] * n
        ways[0] = 1
        heap = [(0, 0)] 
        while heap:
            time_so_far, u = heapq.heappop(heap)
            if u == n - 1:
                return ways[n - 1]

            if time_so_far > dist[u]:
                continue
            
            for v, wt in graph[u]:
                total_time = time_so_far + wt
                if total_time < dist[v]:
                    dist[v] = total_time
                    ways[v] = ways[u]
                    heapq.heappush(heap, (total_time, v))
                elif total_time == dist[v]:
                    ways[v] = (ways[v] + ways[u]) % MOD
```

- 时间复杂度：`O(mlogm)`，其中 `m` 为 `roads` 的长度
  - 由于 `m≥n−1`，分析复杂度时以 `m` 为主
  - 注意堆中会有重复节点，所以至多有 `O(m)` 个元素，单次操作的复杂度是 `O(logm)`
  - 值得注意的是，如果输入的是稠密图，该时间复杂度为 O(n^2logn)，不如`朴素 Dijkstra`（适用于稠密图）
- 空间复杂度：`O(m)`

**朴素 Dijkstra（适用于稠密图）**

```python
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        graph = [[inf for _ in range(n)] for _ in range(n)]  # 邻接矩阵
        for x, y, d in roads:
            graph[x][y] = graph[y][x] = d

        dist = [inf] * n
        dist[0] = 0
        ways = [0] * n
        ways[0] = 1
        done = [False] * n

        while True:
            x = -1
            for i, ok in enumerate(done):
                if not ok and (x < 0 or dist[i] < dist[x]):
                    x = i
            if x == n - 1:
                # 不可能找到比 dist[-1] 更短，或者一样短的最短路了（注意本题边权都是正数）
                return f[-1]
            done[x] = True  # 最短路长度已确定（无法变得更小）
            dx = dist[x]
            for y, d in enumerate(g[x]):  # 尝试更新 x 的邻居的最短路
                new_dist = dx + d
                if new_dist < dist[y]:
                    # 就目前来说，最短路必须经过 x
                    dist[y] = new_dist
                    ways[y] = ways[x]
                elif new_dist == dist[y]:
                    # 和之前求的最短路一样长
                    ways[y] = (ways[y] + ways[x]) % 1_000_000_007
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(n^2)