# 834.树中距离之和

题目链接：[834.树中距离之和](https://leetcode.cn/problems/sum-of-distances-in-tree/)

## 题目大意

给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 

给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边

返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1lca47kyqo.webp)

限制：
- 1 <= n <= 3 * 10^4
- edges.length == n - 1
- edges[i].length == 2
- 0 <= ai, bi < n
- ai != bi
- The given input represents a valid tree.

## 解题

❌ 暴力 `DFS` 枚举法（TLE）
- 对每个节点 `i` 做 `DFS`，计算它到所有点的距离之和
- 时间复杂度：每个节点都要遍历一遍整棵树 -> `O(n²)`
- 原因：每个节点都要遍历一次整棵树

**思考：**
- 树是没有环的，每个节点之间的路径唯一
- 如果对每个节点都 `DFS`，是不是重复算了很多路径信息？
- 有没有办法将一个节点的 `DFS` 结果复用给另一个节点？
- 例如：
  - 从节点 `0` 出发，我们知道 `res[0] = 8`（包含了子树所有节点）
  - 能不能从根节点出发一次性算出 `res[0]`
  - 然后通过某种方式，把 `res[0]` “传播”给 `res[1]`、`res[2]`…
- 这就启发了我们可使用 `“树形动态规划 + 根的转换技巧”`

**利用树的结构 — 自顶向下、自底向上信息传递**
- 树的一个强大特性：它是有明确父子结构的（虽然题目是无向图，但选定根之后就可以定向）
- 目标是：在一次 `DFS` 的过程中，最大限度重用子问题结果
- 关键思想：
  - 后序遍历（Post-order）- 自底向上：  
    - 从子节点回溯到父节点
    - 每个节点的子树大小 `count[node]`
    - 每个节点作为根时，子树中所有节点到它的距离之和 `res[node]`
  - 前序遍历（Pre-order）- 自顶向下：
    - 从父节点传递信息给子节点
    - 根据`父节点 res[parent] 的值 + 子树大小`，计算出子节点 `res[child]`

> 这个想法的关键是：
> - 在第一轮后序遍历中，我们拿到了每个节点“局部”的统计信息
> - 在第二轮前序遍历中，我们用这些信息传递全局结果

**公式推导（重点）**

假设：
- 有 `n` 个节点
- 当前在 `node`，准备把根换成它的子节点 `child`
- 已经知道 `res[node]` 和 `count[child]`

设：
- `count[node]`: 以 `node` 为根的子树节点数（含自己）
- `res[node]`: `node` 作为根节点时，它到所有子树节点的距离和

后序遍历（从底往上）
- `res[node] += res[child] + count[child]`
- `count[node] += count[child]`
- 解释：`子树中的所有节点距离 + 1`，相当于增加了 `count[child]` 个距离

前序遍历（从上往下）
- `res[child] = res[parent] - count[child] + (n - count[child])`
- 解释：
  - 从 `parent → child`，所有 `child` 子树内节点少了 `1` 距离（向下移动，`count[child]` 个节点离 `child` 更近了，距离减少 `1`（因为 `child` 成为根））
  - 而所有非 `child` 子树的节点，多了 `1` 距离（远离）(`n - count[child]` 个节点离 `child` 更远了，距离增加 `1`)

```js
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number[]}
 */
var sumOfDistancesInTree = function(n, edges) {
    const graph = new Array(n).fill(0).map(() => []);
    
    // 构建无向图
    for (const [u, v] of edges) {
        graph[u].push(v);
        graph[v].push(u);
    }

    const res = new Array(n).fill(0);    // 存储每个节点的最终距离和
    const count = new Array(n).fill(1);  // 子树节点数（包含自己）

    // 后序遍历：先算子树的节点数和距离和
    const postOrder = (node, parent) => {
        for (const child of graph[node]) {
            if (child === parent) continue;
            postOrder(child, node);
            count[node] += count[child];
            res[node] += res[child] + count[child];
        }
    };

    // 前序遍历：根据父节点结果推导子节点
    const preOrder = (node, parent) => {
        for (const child of graph[node]) {
            if (child === parent) continue;
            res[child] = res[node] - count[child] + (n - count[child]);
            preOrder(child, node);
        }
    };

    postOrder(0, -1);  // 任选一个根，通常是 0
    preOrder(0, -1);

    return res;
};
```
```python
class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:
        # 构建邻接表，表示无向图
        # 将每条边添加到图中，两边都要添加（无向图）
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        # 初始化结果数组 res，每个 count 初始为 1（因为节点本身也算）
        res = [0] * n  
        count = [1] * n  

        # 后序遍历
        # 先递归处理所有子节点
        # 回溯时更新当前节点的子树大小与距离和 
        def post_order(node, parent):
            for child in graph[node]:
                if child == parent:
                    continue
                
                post_order(child, node)
                count[node] += count[child]  # 累加子树大小
                res[node] += res[child] + count[child]  # 距离和累加
        
        # 前序遍历
        # 将父节点的结果转化为子节点的结果（利用公式）
        # 再将子节点继续向下传递
        def pre_order(node, parent):
            for child in graph[node]:
                if child == parent:
                    continue
                res[child] = res[node] - count[child] + (n - count[child])
                pre_order(child, node)
        
        # 任意选一个根节点开始
        post_order(0, -1)
        # 从根节点开始传递结果
        pre_order(0, -1)
        
        return res
```

- 时间复杂度：`O(n)`。`DFS` 两次，每次 `DFS` 会递归访问每个节点恰好一次，所以时间复杂度为 `O(n)`
- 空间复杂度：`O(n)`