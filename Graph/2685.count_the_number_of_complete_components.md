# 2685.统计完全连通分量的数量

题目链接：[2685.统计完全连通分量的数量](https://leetcode.cn/problems/count-the-number-of-complete-components/)

## 题目大意

给你一个整数 `n`。现有一个包含 `n` 个顶点的无向图，顶点按从 `0` 到 `n - 1` 编号。给你一个二维整数数组 `edges` 其中 `edges[i] = [ai, bi]` 表示顶点 `ai` 和 `bi` 之间存在一条无向边

返回图中 完全连通分量 的数量

如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 连通分量 

如果连通分量中每对节点之间都存在一条边，则称其为 完全连通分量 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6bhg0kuom0.webp)

限制：
- 1 <= n <= 50
- 0 <= edges.length <= n * (n - 1) / 2
- edges[i].length == 2
- 0 <= ai, bi <= n - 1
- ai != bi
- There are no repeated edges.

## 解题

最直接的想法：对每一个连通分量中的节点，检查是否所有两两节点都有边
- 先找到每个连通分量里的节点集合
- 然后枚举这个集合里的任意两两节点，看是否存在边。
问题：如果连通分量中有 `v` 个节点，需要检查 `v*(v-1)/2` 对节点是否有边，时间复杂度很高（尤其在 `n` 大时不可取）

### 思路 1: DFS

优化思路：用度数/边数快速判断
- 对于一个含 `v` 个节点的完全连通分量：
  - 它包含的边数是 `v*(v-1)/2`
  - 由于无向图每条边在邻接表里会出现两次（一次在 `u`，一次在 `v`），所以遍历邻接表时计数 `e`（边的度和）应为 `v*(v-1)`
- 因此判断条件：如果某个连通分量内：
  - 节点数 = `v`
  - 遍历邻接表时累计的边数 = `e`
  - 如果 `e == v*(v-1)` → 这个分量是完全连通分量
- 这样就避免了两两检查

如何遍历每个连通分量
- 用 `DFS/BFS` 遍历图，把同一个连通分量的节点都找出来，同时统计：
  - `v`：节点数
  - `e`：邻接边数和（即邻接表长度之和）
  - 遍历完成后检查 `e == v*(v-1)`，如果成立，计数器加 `1`

```js
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {number}
 */
var countCompleteComponents = function(n, edges) {
    const graph = Array.from({ length: n }, () => []);
    for (const [x, y] of edges) {
        graph[x].push(y);
        graph[y].push(x);
    }

    const visited = new Array(n).fill(false);

    const dfs = (x, state) => {
        visited[x] = true;
        state.v += 1;
        state.e += graph[x].length;

        for (const y of graph[x]) {
            if (!visited[y]) {
                dfs(y, state);
            }
        }
    };

    let res = 0;
    for (let i = 0; i < n; i++) {
        if (!visited[i]) {
            const state = { v: 0, e: 0 };
            dfs(i, state);
            if (state.e === state.v * (state.v - 1)) {
                res += 1;
            }
        }
    }

    return res;
};
```
```python
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        # 用邻接表 graph 存储无向图
        # 初始化 graph 为长度为 n 的空列表
        graph = [[] for _ in range(n)]
        # 对每条边 (x,y)：
        # graph[x].append(y) 表示 x→y
        # graph[y].append(x) 表示 y→x
        # 目的： 建立无向图的邻接表结构，方便 DFS 遍历
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        
        # visited[i] 表示节点 i 是否已经访问过
        # 用来避免重复遍历同一连通分量
        visited = [False] * n
        # 定义 DFS 函数
        def dfs(x: int) -> None:
            # visited[x] = True：标记当前节点已访问
            visited[x] = True
            # nonlocal v, e：声明 v 和 e 在外层函数中定义，用于统计当前连通分量
            nonlocal v, e
            # v += 1：当前连通分量的节点数加 1
            v += 1
            # e += len(graph[x])：累计当前节点的邻接边数量（度数）
            e += len(graph[x])
            # 递归遍历未访问的邻居 y：把同一连通分量的所有节点都遍历到
            for y in graph[x]:
                if not visited[y]:
                    dfs(y)
        
        # 初始化结果 res 为 0，表示完全连通分量的计数器
        res = 0
        # 遍历所有节点
        for i, b in enumerate(visited):
            # 如果当前节点没被访问（not b），说明遇到一个新的连通分量
            if not b:
                # 重置 v 和 e 为 0
                v = e = 0
                # 从这个节点开始 DFS，把整个连通分量遍历完，并统计 v、e
                dfs(i)
                # 判断条件 e == v*(v-1)：
                # 因为每条边在 graph 里被算了两次，所以一个 v 节点的完全连通分量，边数和（度和）应等于 v*(v-1)
                # 如果成立，res += 1
                res += e == v * (v - 1)
        
        # 返回最终完全连通分量的数量
        return res
```

- 时间复杂度：`O(n+m)`，其中 `m` 为 `edges` 的长度，`DFS` 遍历每条边和节点一次
- 空间复杂度：`O(n+m)`，存储图和 `visited` 数组

### 思路 2: Union-Find

核心想法：
- 使用 `Union-Find` 将所有连通分量（`Connected Components`）归类
- 对于每个连通分量，统计它的：
  - 节点数 `v`
  - 边数 `e`
- 若某个连通分量是完全图，必须满足：
  - `e == v * (v - 1) / 2`
  - 注意这里边数是唯一边数，和 `DFS` 中统计方式不同（不需要 `*2`）

```js
var countCompleteComponents = function(n, edges) {
    const parent = Array.from({ length: n }, (_, i) => i);
    const size = new Array(n).fill(1);
    const edgeCount = new Array(n).fill(0);

    const find = (x) => {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    };

    const union = (x, y) => {
        const px = find(x), py = find(y);
        if (px !== py) {
            parent[py] = px;
            size[px] += size[py];
            edgeCount[px] += edgeCount[py];
        }
        edgeCount[find(x)] += 1;
    };

    for (const [u, v] of edges) {
        union(u, v);
    }

    const roots = new Set();
    for (let i = 0; i < n; i++) {
        roots.add(find(i));
    }

    let res = 0;
    for (const r of roots) {
        const v = size[r];
        const e = edgeCount[r];
        if (e === v * (v - 1) / 2) {
            res += 1;
        }
    }
    return res;
};
```
```python
class Solution:
    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        parent = list(range(n))
        # size[i]: 该连通分量中节点个数
        size = [1] * n
        # edge_count[i]: 该连通分量中的边数量
        edge_count = [0] * n
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])  

            return parent[x]
        
        def union(x, y):
            px, py = find(x), find(y)
            if px != py:
                parent[py] = px
                size[px] += size[py]
                edge_count[px] += edge_count[py]
            
            # union 后仍要计边
            edge_count[find(x)] += 1
        
        for u, v in edges:
            union(u, v)
        
        # 汇总每个 root 代表的连通分量
        roots = set(find(i) for i in range(n))
        res = 0
        for r in roots:
            v = size[r]
            e = edge_count[r]
            if e == v * (v - 1) // 2:
                res += 1

        return res
```

- 时间复杂度：`O(n+m)`，其中 `m` 为 `edges` 的长度
  - 初始化 `O(n)`
  - 构建并查集 `O(α(n)) ≈ O(1)`（近似常数）
  - 遍历节点 + 统计答案 `O(n)`
- 空间复杂度：`O(n)`
  - 因为所有主要数组（parent、size、edgeCount）都是长度为 `n`
  - 并查集本身是一个非常节省空间的数据结构
  - 不需要构造完整邻接表，因此比 `DFS` 的空间开销更优（`DFS` 需要 `O(n + e)` 来存图）