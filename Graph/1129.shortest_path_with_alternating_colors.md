# 1129.颜色交替的最短路径

题目链接：[1129.颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)

## 题目大意

给定一个整数 `n`，即有向图中的节点数，其中节点标记为 `0` 到 `n - 1`。图中的每条边为红色或者蓝色，并且可能存在自环或平行边

给定两个数组 `redEdges` 和 `blueEdges`，其中：
- `redEdges[i] = [ai, bi]` 表示图中存在一条从节点 `ai` 到节点 `bi` 的红色有向边
- `blueEdges[j] = [uj, vj]` 表示图中存在一条从节点 `uj` 到节点 `vj` 的蓝色有向边
  
返回长度为 `n` 的数组 `answer`，其中 `answer[x]` 是从节点 `0` 到节点 `x` 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 `answer[x] = -1`

```js
Example 1:
Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
Output: [0,1,-1]

Example 2:
Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]
Output: [0,1,-1]
```

限制：
- 1 <= n <= 100
- 0 <= redEdges.length, blueEdges.length <= 400
- redEdges[i].length == blueEdges[j].length == 2
- 0 <= ai, bi, uj, vj < n

## 解题

对于边长度为 `1` 的图，`BFS` 第一次遍历到节点时就是最短距离

我们可以使用 `BFS` 来解决无权图中的最短路径问题。但本题加入了颜色交替限制：
- 从红色边走出去，下一步必须走蓝色边
- 从蓝色边走出去，下一步必须走红色边

所以必须将“当前所在节点” + “当前边颜色” 作为状态进行区分

最优思路：`颜色状态 BFS`
- 状态建模
  - 每个状态不仅包含当前节点，还包含“上一步所使用的边的颜色”：`(node, color)` 表示当前在 `node`，上一步使用的颜色是 `color`
  - 颜色用数字表示：`红色：0`，`蓝色：1`
- 初始状态
  - 从节点 `0` 出发，可以走红色或蓝色边，所以初始状态有两个：`(0, 0)` 和 `(0, 1)`
  - 初始距离为 `0`

```js
var shortestAlternatingPaths = function(n, redEdges, blueEdges) {
    const graph = Array.from({ length: n }, () => []);
    for (const [u, v] of redEdges) {
        graph[u].push([v, 0]); // 0 = red
    }
    for (const [u, v] of blueEdges) {
        graph[u].push([v, 1]); // 1 = blue
    }

    const res = new Array(n).fill(-1);
    const visited = new Set();
    visited.add("0,0");
    visited.add("0,1");

    let que = [[0, 0], [0, 1]]; // (node, color)
    let level = 0;

    while (que.length > 0) {
        const tmp = que;
        que = [];
        for (const [u, color] of tmp) {
            if (res[u] === -1) {
                res[u] = level;
            }
            for (const [v, edgeColor] of graph[u]) {
                if (edgeColor !== color && !visited.has(v + "," + edgeColor)) {
                    visited.add(v + "," + edgeColor);
                    que.push([v, edgeColor]);
                }
            }
        }
        level++;
    }

    return res;
};
```
```python
class Solution:
    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:
        # 初始化邻接表 graph，其中每个元素是一个列表，表示该节点所有出边（包括颜色）
        graph = [[] for _ in range(n)]
        # 遍历红边，将边加入邻接表中，同时标记颜色为 0（红）
        for u, v in redEdges:
            graph[u].append((v, 0))
        
        # 遍历蓝边，加入邻接表中，颜色标记为 1（蓝）
        for u, v in blueEdges:
            graph[u].append((v, 1))
        
        # 初始化结果数组，初始都为 -1，表示未访问
        res = [-1] * n
        # 记录访问状态的集合，元素是 (node, color)，表示从哪个颜色访问了哪个节点
        # 初始将 (0,0) 和 (0,1) 加入，表示起点 0 已经从红边和蓝边同时开始了
        visited = {(0, 0), (0, 1)}
        # 初始化 BFS 队列，两个起点状态：(0,红) 和 (0,蓝)
        que = [(0, 0), (0, 1)]
        # 表示当前 BFS 所在的层数，也就是到达节点的距离
        level = 0
        # BFS 主循环
        while que:
            # 保存当前层的所有节点到 tmp
            tmp = que
            # 清空 que，准备加入下一层节点
            que = []
            # 遍历当前层的每个状态
            for u, color in tmp:
                # 如果该节点 u 还没被访问（res[u] == -1），就更新它的最短距离为当前 level
                if res[u] == -1:
                    res[u] = level
                
                # 遍历从 u 出发的所有边 (v_node, v_color)：
                for v in graph[u]:
                    # v[1] != color：颜色必须交替
                    # v not in visited：该状态没访问过
                    if v[1] != color and v not in visited:
                        # 满足条件就加入下一层 BFS 队列，并标记为已访问
                        visited.add(v)
                        que.append(v)
            
            # 层数加一，表示下一层路径长度
            level += 1
        
        # 返回最终结果数组
        return res
```

- 时间复杂度：`O(n+r+b)`，其中 `n` 是节点数，`r` 是红色边的数目，`b` 是蓝色边的数目。广度优先搜索最多访问一个节点两次，最多访问一条边一次，因此时间复杂度为 `O(n+r+b)`
- 空间复杂度：`O(n+r+b)`。队列中最多有 `2n` 个元素，保存 `next` 需要 `O(r+b)` 的空间，保存 `dist` 需要 `O(n)` 的空间

