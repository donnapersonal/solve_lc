# 694.不同岛屿的数量

题目链接：[694.不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/)

## 题目大意

给定一个非空 01 二维数组表示的网格，一个岛屿由四连通（上、下、左、右四个方向）的 1 组成，你可以认为网格的四周被海水包围

请你计算这个网格中共有多少个形状不同的岛屿。两个岛屿被认为是相同的，当且仅当一个岛屿可以通过平移变换（不可以旋转、翻转）和另一个岛屿重合

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.4ube87ycup.webp)

限制:
- m == grid.length, n == grid[i].length
- 1 <= m, n <= 50
- grid[i][j] is either 0 or 1.

## 解题

**第一步：识别所有岛屿 — DFS/BFS 遍历**

- 最基本的岛屿问题是：遍历所有陆地（1），对每个未访问的陆地做 DFS，把它连接的所有陆地标记为已访问
- 但这题不止要求统计个数，还要求识别“形状”

**初始思路：直接记录坐标集合**

- 比如对于某个岛屿，我们用集合记录所有的 `(x, y)` 坐标
- 但是这样不同位置的同形岛屿会被认为不同，因为坐标不一样

**优化思路：记录“相对位置路径”作为形状标识**

- 以某个岛屿的起点为原点 `(0,0)`，然后把其他坐标都相对于这个起点进行编码
- 即，假设 `DFS` 从 `(x0, y0)` 开始，则把访问过的坐标 `(x, y)` 统一记录为 `(x - x0, y - y0)`
- 相同形状的岛屿，不管它们在网格中的起始位置不同，其相对路径是一样的

**最优方案：DFS + 相对路径字符串**

- 我们在 `DFS` 中记录每一步的方向（上/下/左/右）与回溯（`backtracking`）路径，形成唯一的字符串来表示岛屿形状
- 例如方向编码：
  - "u": up
  - "d": down
  - "l": left
  - "r": right
  - "z": backtrack (回溯)
- 每个岛屿形成的路径字符串若相同，则表示它们是相同形状

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var numDistinctIslands = function(grid) {
    const rows = grid.length;
    const cols = grid[0].length;
    const seen = new Set();

    function dfs(r, c, dir) {
        // 越界或遇到水则返回空串
        if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] === 0) return '';
        
        grid[r][c] = 0;  // 标记访问过
        let path = dir;  // 记录方向
        
        // 依次探索上下左右方向，并记录路径
        path += dfs(r + 1, c, 'd'); // down
        path += dfs(r - 1, c, 'u'); // up
        path += dfs(r, c + 1, 'r'); // right
        path += dfs(r, c - 1, 'l'); // left
        
        path += 'z';  // 回溯标记
        return path;
    }

    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === 1) {
                const shape = dfs(i, j, 'o'); // 从起点出发
                seen.add(shape);             // 把路径加入集合
            }
        }
    }

    return seen.size;
};
```
```python
class Solution:
    def numDistinctIslands(self, grid: List[List[int]]) -> int:
        # 定义 DFS 函数，带方向参数。我们将每次移动的方向拼接成路径字符串
        def dfs(x: int, y: int, direction: str) -> str:
            # 越界或遇到海水（0）则返回空字符串
            if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0:
                return ""
            
            # 标记当前点为已访问
            grid[x][y] = 0  
            # 记录从哪来
            path = direction  
            # 分别递归上下左右的方向，把路径拼接进 path
            path += dfs(x + 1, y, 'd')  # down
            path += dfs(x - 1, y, 'u')  # up
            path += dfs(x, y + 1, 'r')  # right
            path += dfs(x, y - 1, 'l')  # left

            path += 'z'  # 代表从当前点回溯
            # 回溯标志 'z' 是关键，防止路径拼接出相同形状但不同路径
            return path
        
        # 存储所有不同岛屿的路径编码
        seen = set() 
        # 遍历整个网格，遇到陆地就启动 DFS，把生成的路径编码放进集合中
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    shape = dfs(i, j, 'o')    # 从起点出发，记录整条路径
                    seen.add(shape)
        
        # 不同路径的数量即为不同岛屿的数量
        return len(seen)
```

- 时间复杂度：`O(m × n)`，每个格子最多访问一次
- 空间复杂度：
  - 递归深度最坏为 `O(m × n)`
  - 集合 `seen` 的大小为岛屿个数，每个字符串最多 `O(m × n)` 长

