# 785.判断二分图

题目链接：[785.判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

## 题目大意

存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
- 不存在自环（graph[u] 不包含 u）
- 不存在平行边（graph[u] 不包含重复值）
- 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
- 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径
  
二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 

如果图是二分图，返回 true ；否则，返回 false 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6bhjfp692j.png)

限制:
- graph.length == n
- 1 <= n <= 100
- 0 <= graph[u].length < n
- 0 <= graph[u][i] <= n - 1
- graph[u] does not contain u.
- All the values of graph[u] are unique.
- If graph[u] contains v, then graph[v] contains u.

## 解题

二分图的定义是：图中的所有节点可以分成两个集合 A 和 B，使得图中每一条边连接的两个节点分别来自不同集合（不能同属 A 或同属 B）

换句话说，可以把图中每个点染成黑白两种颜色，相邻节点颜色必须不同。如果可以做到，则是二分图

**暴力思路**
- 尝试所有可能的分组组合，会有指数级的复杂度 → 不可行

### DFS
✅ 正确思路：图染色（DFS 或 BFS）
- 本质：判断是否能使用两种颜色对图染色，且任意一条边两端的颜色不同
- 步骤：
  - 用一个数组 `color` 记录每个节点的染色情况：初始化为 `-1`（未染色）
  - 从任意一个未访问节点出发，开始 `DFS`（或 BFS）染色：
    - 当前节点染成 `0`，则相邻节点染成 `1`
    - 当前节点染成 `1`，则相邻节点染成 `0`
  - 如果在染色过程中发现相邻节点已经染色且颜色相同 → 返回 `False`
  - 如果所有节点都成功染色，没有冲突 → 返回 `True`
- 注意：图可能是不连通的，因此要对每个未访问的节点重复以上过程

```js
/**
 * @param {number[][]} graph
 * @return {boolean}
 */
var isBipartite = function(graph) {
    const n = graph.length;
    const color = Array(n).fill(-1);

    for (let i = 0; i < n; i++) {
        if (color[i] !== -1) continue;

        const queue = [i];
        color[i] = 0;

        while (queue.length > 0) {
            const node = queue.shift();
            for (const neighbor of graph[node]) {
                if (color[neighbor] === -1) {
                    color[neighbor] = 1 - color[node];
                    queue.push(neighbor);
                } else if (color[neighbor] === color[node]) {
                    return false;
                }
            }
        }
    }

    return true;
};
```
```python
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        # 初始化颜色数组，长度为节点数
        n = len(graph)
         # -1 表示未染色，0/1 表示两种颜色
        color = [-1] * n 

        # 定义 DFS 函数，node 是当前节点，c 是要给它染的颜色
        def dfs(node: int, c: int) -> bool:
            # 给当前节点染色
            color[node] = c
            # 遍历当前节点的所有邻居
            for neighbor in graph[node]:
                # 如果邻居未染色，递归给邻居染相反的颜色。如果染色失败（冲突）则返回 False
                if color[neighbor] == -1 and not dfs(neighbor, 1 - c):
                    return False
                # 如果邻居已经染色，但和当前节点颜色一样 → 冲突，返回 False
                elif color[neighbor] == c:
                    return False
            
            # 如果当前节点及其邻居染色都成功，返回 True
            return True 
        
        # 外层循环处理图的所有连通分量。如果某个点没染色，说明是新的分量，就从它开始染色
        for i in range(n):
            if color[i] == -1 and not dfs(i, 0):
                return False
        
        # 如果所有节点都能成功染色，无冲突 → 是二分图
        return True
```

- 时间复杂度：`O(n+m)`，其中 `n` 和 `m` 分别是无向图中的点数和边数
- 空间复杂度：`O(n)`，存储节点颜色的数组需要 `O(n)` 的空间，并且在广度优先搜索的过程中，队列中最多有 `n−1` 个节点，需要 `O(n)` 的空间

### BFS

```python
class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        UNCOLORED, RED, GREEN = 0, 1, 2
        color = [UNCOLORED] * n
        
        for i in range(n):
            if color[i] == UNCOLORED:
                q = collections.deque([i])
                color[i] = RED
                while q:
                    node = q.popleft()
                    cNei = (GREEN if color[node] == RED else RED)
                    for neighbor in graph[node]:
                        if color[neighbor] == UNCOLORED:
                            q.append(neighbor)
                            color[neighbor] = cNei
                        elif color[neighbor] != cNei:
                            return False

        return True
```

- 时间复杂度：`O(n+m)`，其中 `n` 和 `m` 分别是无向图中的点数和边数
- 空间复杂度：`O(n)`，存储节点颜色的数组需要 `O(n)` 的空间，并且在广度优先搜索的过程中，队列中最多有 `n−1` 个节点，需要 `O(n)` 的空间

