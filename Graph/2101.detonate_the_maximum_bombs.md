# 2101.引爆最多的炸弹

题目链接：[2101.引爆最多的炸弹](https://leetcode.cn/problems/detonate-the-maximum-bombs/)

## 题目大意

给你一个炸弹列表，一个炸弹的 爆炸范围 定义为以炸弹为圆心的一个圆

炸弹用一个下标从 `0` 开始的二维整数数组 `bombs` 表示，其中 `bombs[i] = [xi, yi, ri]`。`xi` 和 `yi` 表示第 `i` 个炸弹的 `X` 和 `Y` 坐标，`ri` 表示爆炸范围的 半径 

需要选择引爆 一个 炸弹，当这个炸弹被引爆时，所有在它爆炸范围内的炸弹都会被引爆，这些炸弹会进一步将它们爆炸范围内的其他炸弹引爆

给数组 `bombs`，请返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目

![example1](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.3yetjlsczp.webp)

![example2](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8s3ofqdtcc.webp)

![example3](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.5fkylcxu2w.webp)

限制：
- 1 <= bombs.length <= 100
- bombs[i].length == 3
- 1 <= xi, yi, ri <= 10^5

## 解题

本题本质是有向图遍历问题，从每个节点出发做 `DFS` 即可，关键在于：
- 如何建图（计算两炸弹间距离）
- 如何进行搜索（`DFS + visited`）

步骤如下：
- 图建模：把每个炸弹看作图中的一个节点，若炸弹 `i` 可以引爆炸弹 `j`，就建立一条从 `i → j` 的有向边
- 判断爆炸范围：
  - 对于两个炸弹 `i` 和 `j`，若：`(𝑥𝑖 − 𝑥𝑗)^2 + (𝑦𝑖 − 𝑦𝑗)^2 ≤ 𝑟𝑖^2`，则说明 `i` 能引爆 `j`
- `DFS` 遍历图：从每个炸弹出发，使用 `DFS` 统计所有连锁爆炸能引爆的数量
- 取最大值：所有炸弹都作为起点尝试一次，取其中最大引爆数

```js
var maximumDetonation = function(bombs) {
    const n = bombs.length;
    const graph = Array.from({ length: n }, () => []);

    // 构建图：从 i 能引爆 j，就连边 i -> j
    for (let i = 0; i < n; i++) {
        const [x1, y1, r1] = bombs[i];
        for (let j = 0; j < n; j++) {
            if (i === j) continue;
            const [x2, y2] = bombs[j];
            const dx = x1 - x2;
            const dy = y1 - y2;
            if (dx * dx + dy * dy <= r1 * r1) {
                graph[i].push(j);
            }
        }
    }

    // DFS 计算从 x 能引爆多少个炸弹
    const dfs = (x, visited) => {
        visited[x] = true;
        let count = 1;
        for (const y of graph[x]) {
            if (!visited[y]) {
                count += dfs(y, visited);
            }
        }
        return count;
    };

    let res = 0;
    for (let i = 0; i < n; i++) {
        const visited = new Array(n).fill(false);
        res = Math.max(res, dfs(i, visited));
        if (res === n) break;  // 已经引爆全部炸弹，提前结束
    }

    return res;
};
```
```python
class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        # 获取炸弹总数 n
        n = len(bombs)
        # 初始化邻接表：graph[i] 表示从炸弹 i 能引爆哪些炸弹（邻居）
        graph = [[] for _ in range(n)]

        # 构建有向图，判断第 i 颗炸弹能否引爆第 j 颗炸弹
        for i, (x, y, r) in enumerate(bombs):
            for j, (x2, y2, _) in enumerate(bombs):
                # 计算两点间欧几里得距离的平方是否小于等于 r²
                dx = x - x2
                dy = y - y2
                if j != i and dx * dx + dy * dy <= r * r:
                    # 满足条件则在 graph[i] 中加入 j（建立 i → j 的边）
                    graph[i].append(j) 
        
        # 定义 DFS 函数，从炸弹 x 开始爆炸，统计引爆数量
        def dfs(x: int) -> int:
            visited[x] = True
            # 初始已引爆当前炸弹 x，所以 count = 1
            count = 1

            # 遍历所有可被 x 引爆的炸弹 y
            for y in graph[x]:
                # 如果 y 没被访问过，递归爆炸它
                if not visited[y]:
                    # 累加所有连锁爆炸的数量
                    count += dfs(y)

            return count

        res = 0
        # 遍历所有炸弹，作为起始爆炸点
        for i in range(n):
            # 每次都新建 visited 数组，避免污染
            visited = [False] * n
            # 使用 DFS 模拟从该炸弹开始的连锁爆炸
            # 每次更新最大值 res
            res = max(res, dfs(i))
            # 若某次已经引爆全部炸弹，直接提前 break
            if res == n:
                break
                
        return res
```

- 时间复杂度：`O(n^3)`，其中 `n` 是 `bombs` 的长度，注意图中至多有 `O(n^2)` 条边，每次 `DFS` 的时间复杂度为 `O(n^2)`
- 空间复杂度：`O(n^2)`

