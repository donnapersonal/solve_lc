# 1298.ä½ èƒ½ä»ç›’å­é‡Œè·å¾—çš„æœ€å¤§ç³–æœæ•°

é¢˜ç›®é“¾æ¥ï¼š[1298.ä½ èƒ½ä»ç›’å­é‡Œè·å¾—çš„æœ€å¤§ç³–æœæ•°](https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/)

## é¢˜ç›®å¤§æ„

ç»™ä½  n ä¸ªç›’å­ï¼Œæ¯ä¸ªç›’å­çš„æ ¼å¼ä¸º [status, candies, keys, containedBoxes] ï¼Œå…¶ä¸­ï¼š
- çŠ¶æ€å­— status[i]ï¼šæ•´æ•°ï¼Œå¦‚æœ box[i] æ˜¯å¼€çš„ï¼Œé‚£ä¹ˆæ˜¯ 1 ï¼Œå¦åˆ™æ˜¯ 0 
- ç³–æœæ•° candies[i]: æ•´æ•°ï¼Œè¡¨ç¤º box[i] ä¸­ç³–æœçš„æ•°ç›®
- é’¥åŒ™ keys[i]ï¼šæ•°ç»„ï¼Œè¡¨ç¤ºä½ æ‰“å¼€ box[i] åï¼Œå¯ä»¥å¾—åˆ°ä¸€äº›ç›’å­çš„é’¥åŒ™ï¼Œæ¯ä¸ªå…ƒç´ åˆ†åˆ«ä¸ºè¯¥é’¥åŒ™å¯¹åº”ç›’å­çš„ä¸‹æ ‡
- å†…å«çš„ç›’å­ containedBoxes[i]ï¼šæ•´æ•°ï¼Œè¡¨ç¤ºæ”¾åœ¨ box[i] é‡Œçš„ç›’å­æ‰€å¯¹åº”çš„ä¸‹æ ‡
  
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ initialBoxesï¼ŒåŒ…å«ä½ æœ€åˆæ‹¥æœ‰çš„ç›’å­ã€‚ä½ å¯ä»¥æ‹¿èµ°æ¯ä¸ª å·²æ‰“å¼€ç›’å­ é‡Œçš„æ‰€æœ‰ç³–æœï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨å…¶ä¸­çš„é’¥åŒ™å»å¼€å¯æ–°çš„ç›’å­ï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨åœ¨å…¶ä¸­å‘ç°çš„å…¶ä»–ç›’å­

è¯·ä½ æŒ‰ç…§ä¸Šè¿°è§„åˆ™ï¼Œè¿”å›å¯ä»¥è·å¾—ç³–æœçš„ æœ€å¤§æ•°ç›® 

```js
Example 1:
Input: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]
Output: 16
Explanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.
Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.
In box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.
Total number of candies collected = 7 + 4 + 5 = 16 candy.

Example 2:
Input: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]
Output: 6
Explanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys.
The total number of candies will be 6.
```

é™åˆ¶:
- n == status.length == candies.length == keys.length == containedBoxes.length
- 1 <= n <= 1000
- status[i] is either 0 or 1.
- 1 <= candies[i] <= 1000
- 0 <= keys[i].length <= n
- 0 <= keys[i][j] < n
- All values of keys[i] are unique.
- 0 <= containedBoxes[i].length <= n
- 0 <= containedBoxes[i][j] < n
- All values of containedBoxes[i] are unique.
- Each box is contained in one box at most.
- 0 <= initialBoxes.length <= n
- 0 <= initialBoxes[i] < n

## è§£é¢˜

è¿™é“é¢˜çš„æ ¸å¿ƒå¹¶ä¸æ˜¯ã€Œç›’å­ã€æˆ–ã€Œç³–æœã€ï¼Œè€Œæ˜¯ä¸€ä¸ªåŠ¨æ€å¯è¾¾æ€§é—®é¢˜ï¼š
- ä½ æ˜¯å¦ åŒæ—¶æ»¡è¶³ï¼š
  - æ‹¿åˆ°äº†æŸä¸ªç›’å­
  - å¹¶ä¸”æ‹¥æœ‰å®ƒçš„é’¥åŒ™ï¼ˆæˆ–å®ƒæœ¬èº«æ˜¯å¼€çš„ï¼‰
- åªæœ‰åœ¨è¿™ä¸¤ä¸ªæ¡ä»¶åŒæ—¶æ»¡è¶³æ—¶ï¼Œä½ æ‰èƒ½ï¼š
  - æ‰“å¼€ç›’å­
  - æ‹¿ç³–æœ
  - è·å¾—æ–°é’¥åŒ™
  - è·å¾—æ–°ç›’å­
  â†’ è¿™ä¼š æ”¹å˜æœªæ¥çš„å¯è¾¾çŠ¶æ€
- è¿™æ˜¯ä¸€ä¸ª`çŠ¶æ€ä¸æ–­å˜åŒ–çš„å›¾éå†é—®é¢˜`

**æœ€åˆç›´è§‰æ€è·¯**
- é”™è¯¯ç›´è§‰ 1ï¼šåª DFS / BFS initialBoxes
  - é—®é¢˜ï¼š
    - æœ‰äº›ç›’å­ä½ å·²ç»æ‹¿åˆ°ï¼Œä½†è¿˜æ²¡é’¥åŒ™
    - æœ‰äº›é’¥åŒ™ä½ å·²ç»æ‹¿åˆ°ï¼Œä½†ç›’å­è¿˜æ²¡æ‹¿åˆ°
  - å•çº¯ DFS ä¸€æ¡è·¯å¾„ä¼šé”™è¿‡ã€Œåç»­å˜å¾—å¯æ‰“å¼€ã€çš„ç›’å­
- é”™è¯¯ç›´è§‰ 2ï¼šåªè¦æœ‰é’¥åŒ™å°±ç«‹åˆ»å¼€
  - ä¹Ÿä¸è¡Œï¼šä½ å¯èƒ½æœ‰é’¥åŒ™ï¼Œä½†ç›’å­è¿˜æ²¡è¢«åŒ…å«è¿›æ¥
  - æ‰€ä»¥å¿…é¡»åŒæ—¶è¿½è¸ªï¼šæˆ‘æœ‰æ²¡æœ‰è¿™ä¸ªç›’å­ï¼Ÿæˆ‘èƒ½ä¸èƒ½æ‰“å¼€å®ƒï¼Ÿ

### BFS

**å…³é”®è½¬æŠ˜ï¼šçŠ¶æ€æ‹†åˆ†ï¼ˆæœ€é‡è¦çš„ä¸€æ­¥ï¼‰**
- è¦æ­£ç¡®è§£è¿™é¢˜ï¼Œå¿…é¡»æŠŠã€ŒçŠ¶æ€ã€æ‹†æˆä¸‰ä¸ªç‹¬ç«‹ç»´åº¦ï¼š
  - æˆ‘æ˜¯å¦æ‹¥æœ‰è¿™ä¸ªç›’å­ï¼Ÿ-> `has_box[i]`
  - æˆ‘æ˜¯å¦å¯ä»¥æ‰“å¼€è¿™ä¸ªç›’å­ï¼Ÿ-> `can_open[i]`
  - è¿™ä¸ªç›’å­æ˜¯å¦å·²ç»å¤„ç†è¿‡ï¼Ÿ-> `visited[i]`
- åªæœ‰å½“ï¼š`has_box[i] == True ä¸” can_open[i] == True ä¸” visited[i] == False`ï¼Œæ‰èƒ½æŠŠ `i` æ”¾å…¥é˜Ÿåˆ—è¿›è¡Œå¤„ç†

> `BFS` éå¸¸é€‚åˆè¿™é“é¢˜çš„åŸå› ï¼š
> - æ¯æ¬¡ã€Œæ‰“å¼€ä¸€ä¸ªç›’å­ã€éƒ½ä¼šï¼šè§£é”æ–°çš„ç›’å­ã€è·å¾—æ–°çš„ç›’å­
> - æ–°çŠ¶æ€ å¯èƒ½åè¿‡æ¥ è®©ä¹‹å‰ä¸å¯å¼€çš„ç›’å­å˜å¾—å¯å¼€
> ğŸ‘‰ è¿™æ˜¯ä¸€ä¸ªçŠ¶æ€é€æ­¥æ‰©æ•£çš„é—®é¢˜
> ğŸ‘‰ BFS èƒ½è‡ªç„¶åœ°å¤„ç†è¿™ç§ã€ŒçŠ¶æ€æ¨è¿›ã€

**ç®—æ³•æ•´ä½“æµç¨‹ï¼ˆé«˜åº¦æ¦‚æ‹¬ï¼‰**

åˆå§‹åŒ–ï¼š
- æ ‡è®°æœ€åˆæ‹¥æœ‰çš„ç›’å­
- æŠŠèƒ½æ‰“å¼€çš„ç›’å­æ”¾å…¥é˜Ÿåˆ—

BFSï¼š
- æ‰“å¼€ç›’å­ â†’ æ‹¿ç³–æœ
- æ‹¿é’¥åŒ™ â†’ å°è¯•è§£é”å·²æœ‰ç›’å­
- æ‹¿æ–°ç›’å­ â†’ å¦‚æœèƒ½å¼€ï¼Œç«‹åˆ»åŠ å…¥é˜Ÿåˆ—
- æ¯ä¸ªç›’å­åªå¤„ç†ä¸€æ¬¡ï¼ˆvisitedï¼‰

```js
var maxCandies = function(status, candies, keys, containedBoxes, initialBoxes) {
    const n = status.length;
    const canOpen = Array(n).fill(false);
    const hasBox = Array(n).fill(false);
    const visited = Array(n).fill(false);

    for (let i = 0; i < n; i++) {
        canOpen[i] = status[i] === 1;
    }

    const queue = [];
    let res = 0;

    for (const box of initialBoxes) {
        hasBox[box] = true;
        if (canOpen[box]) {
            queue.push(box);
            visited[box] = true;
            res += candies[box];
        }
    }

    while (queue.length > 0) {
        const cur = queue.shift();

        for (const key of keys[cur]) {
            canOpen[key] = true;
            if (hasBox[key] && !visited[key]) {
                queue.push(key);
                visited[key] = true;
                res += candies[key];
            }
        }

        for (const box of containedBoxes[cur]) {
            hasBox[box] = true;
            if (canOpen[box] && !visited[box]) {
                queue.push(box);
                visited[box] = true;
                res += candies[box];
            }
        }
    }

    return res;
};
```
```python
class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        # ç›’å­æ€»æ•°ï¼Œç”¨äºç»Ÿä¸€ç®¡ç†çŠ¶æ€æ•°ç»„
        n = len(status)
        # can_open[i] = True è¡¨ç¤º å½“å‰æˆ‘èƒ½æ‰“å¼€ i
        # åˆå§‹æ¥è‡ª status
        can_open = [status[i] == 1 for i in range(n)]
        # has_box[i]ï¼šæˆ‘æ˜¯å¦å·²ç»æ‹¥æœ‰ç›’å­ i
        # visited[i]ï¼šç›’å­ i æ˜¯å¦å·²ç»å¤„ç†è¿‡ï¼ˆé˜²æ­¢é‡å¤ï¼‰
        has_box, visited = [False] * n, [False] * n
        
        # BFS é˜Ÿåˆ—
        que = collections.deque()
        # res ç»Ÿè®¡æœ€ç»ˆç³–æœæ•°
        res = 0
        # åˆå§‹åŒ–é˜¶æ®µ
        for box in initialBoxes:
            # æ ‡è®°ä½ ä¸€å¼€å§‹æ‹¥æœ‰çš„ç›’å­
            has_box[box] = True
            # å¦‚æœï¼š
            # è¿™ä¸ªç›’å­æœ¬æ¥å°±æ˜¯å¼€çš„ ğŸ‘‰ ç«‹åˆ»å¤„ç†ï¼š
            # å…¥é˜Ÿ
            # æ ‡è®° visited
            # æ‹¿ç³–æœ
            if can_open[box]:
                que.append(box)
                visited[box] = True
                res += candies[box]
        
        # BFS ä¸»å¾ªç¯
        while len(que) > 0:
            # æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–ä¸€ä¸ªå½“å‰èƒ½æ‰“å¼€çš„ç›’å­
            big_box = que.popleft()
            # è·å¾—æ–°é’¥åŒ™ï¼Œæ„å‘³ç€ï¼šæŸäº›åŸæœ¬é”ç€çš„ç›’å­ç°åœ¨å¯ä»¥æ‰“å¼€äº†
            for key in keys[big_box]:
                can_open[key] = True
                # å¦‚æœï¼š
                # è¿™ä¸ªç›’å­ä½ å·²ç»æœ‰äº†
                # ä½†ä¹‹å‰æ‰“ä¸å¼€
                # ç°åœ¨æœ‰é’¥åŒ™äº†
                # ğŸ‘‰ ç«‹åˆ»å¤„ç†ï¼
                if not visited[key] and has_box[key]:
                    que.append(key)
                    visited[key] = True
                    res += candies[key]
            
            # å¤„ç†æ–°ç›’å­
            for box in containedBoxes[big_box]:
                # ä»å½“å‰ç›’å­ä¸­æ‹¿åˆ°æ–°ç›’å­
                has_box[box] = True
                # å¦‚æœï¼š
                # æ–°ç›’å­æ˜¯å¼€çš„ï¼ˆæˆ–ä¹‹å‰å·²è§£é”ï¼‰ğŸ‘‰ ç«‹åˆ»å¤„ç†
                if not visited[box] and can_open[box]:
                    que.append(box)
                    visited[box] = True
                    res += candies[box]
        
        # æ‰€æœ‰å¯è¾¾ç›’å­å¤„ç†å®Œæ¯•ï¼Œè¿”å›ç³–æœæ€»æ•°
        return 
        
# çŠ¶æ€ä¼˜åŒ–
class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        owned = set(initialBoxes)
        can_open = [False] * len(status)
        visited = [False] * len(status)

        for i in range(len(status)):
            if status[i] == 1:
                can_open[i] = True

        res = 0
        changed = True
        while changed:
            changed = False
            for box in list(owned):
                if can_open[box] and not visited[box]:
                    visited[box] = True
                    res += candies[box]
                    changed = True

                    for k in keys[box]:
                        can_open[k] = True
                    for b in containedBoxes[box]:
                        owned.add(b)
        return res
```

- æ—¶é—´å¤æ‚åº¦: `O(n)`
  - ç›®ä¿è¯äº†æ¯ä¸€æŠŠé’¥åŒ™åœ¨ `keys` ä¸­ä¸ä¼šå‡ºç°è¶…è¿‡ä¸€æ¬¡ï¼Œä¸”æ¯ä¸€ä¸ªç›’å­åœ¨ `containedBoxes` ä¸­ä¹Ÿä¸ä¼šå‡ºç°è¶…è¿‡ä¸€æ¬¡ï¼Œå› æ­¤åœ¨å¹¿åº¦ä¼˜å…ˆæœç´¢ä¸­æœ€å¤šä¼šå¾—åˆ° `n` æŠŠé’¥åŒ™å’Œ `n` ä¸ªç›’å­ï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º `O(n)`
- ç©ºé—´å¤æ‚åº¦: `O(n)`ï¼ŒçŠ¶æ€æ•°ç»„ + é˜Ÿåˆ—

### DFS

```python
class Solution:
    def maxCandies(self, status: List[int], candies: List[int], keys: List[List[int]], containedBoxes: List[List[int]], initialBoxes: List[int]) -> int:
        res = 0
        has_key = status  
        has_box = [False] * len(status)
        for x in initialBoxes:
            has_box[x] = True

        def dfs(x: int) -> None:
            nonlocal res
            res += candies[x]
            has_box[x] = False 

            for y in keys[x]:
                has_key[y] = True
                if has_box[y]:
                    dfs(y)

            for y in containedBoxes[x]:
                has_box[y] = True
                if has_key[y]:
                    dfs(y)

        for x in initialBoxes:
            if has_key[x] and has_box[x]: 
                dfs(x)

        return res
```

- æ—¶é—´å¤æ‚åº¦ï¼š`O(n+L)`ï¼Œå…¶ä¸­ `n` æ˜¯ `keys` çš„é•¿åº¦ï¼Œ`L` æ˜¯æ‰€æœ‰ `keys[i]` çš„é•¿åº¦ä¹‹å’Œã€‚å¯èƒ½ä¸åŒçš„ç›’å­ä¸­æœ‰ç›¸åŒçš„é’¥åŒ™ï¼Œéå†è¿™äº›æ•°æ®ä¸€å…±éœ€è¦ `O(n+L)` çš„æ—¶é—´
- ç©ºé—´å¤æ‚åº¦ï¼š`O(n)`
