# 684.冗余连接

题目链接：[684.冗余连接](https://leetcode.cn/problems/redundant-connection/)

## 题目大意

树可以看成是一个连通且 无环 的 无向 图

给定一个图，该图从一棵 n 个节点 (节点值 1～n) 的树中添加一条边后获得。添加的边的两个不同顶点编号在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的那个

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.99tq5i0nbn.webp)

限制：
- n == edges.length
- 3 <= n <= 1000
- edges[i].length == 2
- 1 <= ai < bi <= edges.length
- ai != bi
- There are no repeated edges.
- The given graph is connected.

## 解题

题意：输入是一个连通图，是一个树再加一条边。要找出那条多余的边（加入它会形成一个环），多个答案时，返回输入中最后出现的那条边

最优解：使用`并查集（Union-Find）`
- 从头开始遍历每条边：
  - 每次尝试将两个点 `union`
  - 如果发现这两个点已经连接过了（`find` 结果一样），说明这条边构成了环，直接返回它

```js
var findRedundantConnection = function(edges) {
    const parent = Array(edges.length + 1).fill(0).map((_, idx) => idx);

    function find(x) {
        if (parent[x] !== x) {
            parent[x] = find(parent[x]); // 路径压缩
        }
        return parent[x];
    }

    function union(x, y) {
        const rootX = find(x);
        const rootY = find(y);
        if (rootX === rootY) return false;
        parent[rootX] = rootY;
        return true;
    }

    for (let [u, v] of edges) {
        if (!union(u, v)) {
            return [u, v];
        }
    }

    return [];
};
```
```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        parent = [i for i in range(n + 1)]

        def find(x: int) -> int:
            if parent[x] != x:
                parent[x] = find(parent[x])

            return parent[x]
        
        # def union(index1: int, index2: int):
        #     parent[find(index1)] = find(index2)
        
        def union(x, y):
            rootX = find(x)
            rootY = find(y)
            if rootX == rootY:
                return False  # x 和 y 已在同一集合，表示成环

            parent[rootX] = rootY  # 合并集合

            return True
        
        for u, v in edges:
            if not union(u, v):
                return [u, v]

        return []
```

- 时间复杂度：`O(nlogn)`，其中 `n` 是图中的节点个数
  - 需要遍历图中的 `n` 条边，对于每条边，需要对两个节点查找祖先，如果两个节点的祖先不同则需要进行合并，需要进行 `2` 次查找和最多 `1` 次合并
  - 一共需要进行 `2n` 次查找和最多 `n` 次合并，因此总时间复杂度是 `O(2nlogn)=O(nlogn)`
  - 这里的并查集使用了路径压缩，但没有使用按秩合并，最坏情况下的时间复杂度是 `O(nlogn)`，平均情况下的时间复杂度依然是 `O(nα(n))`，其中 `α` 为阿克曼函数的反函数，`α(n)` 可以认为是一个很小的常数
- 空间复杂度：`O(n)`，其中 `n` 是图中的节点个数，使用数组 `parent` 记录每个节点的祖先
