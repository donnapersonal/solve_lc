# 2959.关闭分部的可行集合数目

题目链接：[2959.关闭分部的可行集合数目](https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/)

## 题目大意

一个公司在全国有 n 个分部，它们之间有的有道路连接。一开始，所有分部通过这些道路两两之间互相可以到达

公司意识到在分部之间旅行花费了太多时间，所以它们决定关闭一些分部（也可能不关闭任何分部），同时保证剩下的分部之间两两互相可以到达且最远距离不超过 maxDistance 

两个分部之间的 距离 是通过道路长度之和的 最小值 

给你整数 n ，maxDistance 和下标从 0 开始的二维整数数组 roads ，其中 roads[i] = [ui, vi, wi] 表示一条从 ui 到 vi 长度为 wi的 无向 道路

请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过 maxDistance

注意，关闭一个分部后，与之相连的所有道路不可通行

注意，两个分部之间可能会有多条道路

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ueke8b6g.webp)

限制:
- 1 <= n <= 10
- 1 <= maxDistance <= 105
- 0 <= roads.length <= 1000
- roads[i].length == 3
- 0 <= ui, vi <= n - 1
- ui != vi
- 1 <= wi <= 1000
- All branches are reachable from each other by traveling some roads.

## 解题

暴力解：`遍历所有子集 + Dijkstra 判断是否合法`
- 对于每个 `mask（0 ~ 2ⁿ−1）`，枚举子集中的节点
- 利用 `Dijkstra` 求出子集中任意两点的最短路径，判断是否都 `≤ maxDistance`
- 时间复杂度：`O(2ⁿ × n × log n)`，在 n=15 时不可接受

优化思路：`预处理所有子集的最短路径（Floyd）`
- 用 `DP + Floyd-Warshall` 算法加速每个子集的判断：
  - 子集可以通过逐位构造，每次只增加一个点
  - 增量地更新最短路径：用 `dp[prev]` 推出 `dp[curr]`
- 判断是否合法：判断该子集内任意两点的最短路径 `≤ maxDistance`

最优做法核心点：
- 状态压缩 `DP`：`dp[mask][i][j]` 表示子集 `mask` 中从 `i` 到 `j` 的最短路径
- 子集状态转移：`mask = prev | (1 << k)`，通过引入新点 `k`，用 `Floyd` 更新

```js
/**
 * @param {number} n
 * @param {number} maxDistance
 * @param {number[][]} roads
 * @return {number}
 */
var numberOfSets = function(n, maxDistance, roads) {
    const INF = Infinity;

    // 初始化距离矩阵 dist[i][j] 表示 i 到 j 的最短路径
    const dist = Array.from({ length: n }, () => Array(n).fill(INF));
    for (let i = 0; i < n; i++) {
        dist[i][i] = 0;
    }

    for (const [u, v, w] of roads) {
        dist[u][v] = Math.min(dist[u][v], w);
        dist[v][u] = Math.min(dist[v][u], w);
    }

    // 初始化 3D DP 表：dp[mask][i][j] 表示子集 mask 中 i 到 j 的最短路径
    const totalMasks = 1 << n;
    const dp = Array.from({ length: totalMasks }, () => 
        Array.from({ length: n }, () => Array(n).fill(INF))
    );
    dp[0] = dist.map(row => row.slice()); // 深拷贝初始距离矩阵

    let res = 1;  // 空集是合法的

    for (let mask = 1; mask < totalMasks; mask++) {
        const lastAdded = Math.floor(Math.log2(mask & -mask));  // 最右侧的1的index
        const prevMask = mask ^ (1 << lastAdded);

        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                dp[mask][i][j] = Math.min(
                    dp[prevMask][i][j],
                    dp[prevMask][i][lastAdded] + dp[prevMask][lastAdded][j]
                );
            }
        }

        let isValid = true;
        for (let i = 0; i < n; i++) {
            if ((mask & (1 << i)) === 0) continue;
            for (let j = 0; j < i; j++) {
                if ((mask & (1 << j)) === 0) continue;
                if (dp[mask][i][j] > maxDistance) {
                    isValid = false;
                    break;
                }
            }
            if (!isValid) break;
        }

        if (isValid) res++;
    }

    return res;
};
```
```python
class Solution:
    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
        # 初始化距离矩阵为无穷大
        dist = [[inf] * n for _ in range(n)]
        # 自己到自己距离为 0
        for i in range(n):
            dist[i][i] = 0
        
        # 处理输入边
        for u, v, w in roads:
            # 若有重边，保留最短的
            dist[u][v] = min(dist[u][v], w)
            # 无向图，对称赋值
            dist[v][u] = min(dist[v][u], w)
        
        # dp[mask][i][j]: 表示当前子集mask中从i到j的最短路径
        dp = [[[inf] * n for _ in range(n)] for _ in range(1 << n)]
        # 初始状态是空集，对应的路径使用原始图
        dp[0] = [row[:] for row in dist]  
        # 初始计数为1，空集合法（所有都关闭）
        res = 1  

        # 遍历所有非空子集
        for mask in range(1, 1 << n):
            # 找出最后加进来的那个点 k
            last_added = mask.bit_length() - 1
            # 前一个状态，去掉这个点
            prev_mask = mask ^ (1 << last_added) 

            for i in range(n):
                for j in range(n):
                    # 状态转移公式：是否通过新加入的点形成更短路径
                    dp[mask][i][j] = min(
                        dp[prev_mask][i][j],
                        dp[prev_mask][i][last_added] + dp[prev_mask][last_added][j]
                    )

            # 判断该子集是否满足条件
            is_valid = True
            for i in range(n):
                # 该节点不在子集中，跳过
                if not (mask & (1 << i)):
                    continue
                for j in range(i):
                    if not (mask & (1 << j)):
                        continue
                    
                    # 有一对点超过最大距离，非法
                    if dp[mask][i][j] > maxDistance:
                        is_valid = False
                        break
                        
                if not is_valid:
                    break
            
            # 当前子集合法，计数 +1
            if is_valid:
                res += 1
        
        return res

# 写法 2
class Solution:
    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:
        dist = [[inf] * n for _ in range(n)]
        for x, y, w in roads:
            dist[x][y] = min(dist[x][y], w)
            dist[y][x] = min(dist[y][x], w)
        
        res = 1 
        dp = [[[inf] * n for _ in range(n)] for _ in range(1 << n)]
        dp[0] = dist
        for s in range(1, 1 << n):
            k = s.bit_length() - 1
            t = s ^ (1 << k)
            ok = 1
            for i in range(n):
                for j in range(n):
                    dp[s][i][j] = min(dp[t][i][j], dp[t][i][k] + dp[t][k][j])  # 手动求 min 可以更快
                    if ok and j < i and s >> i & 1 and s >> j & 1 and dp[s][i][j] > maxDistance:
                        ok = 0
            res += ok
        return res
```

- 时间复杂度：`O(m+n^2⋅2^n)`，其中 `m` 为 `roads` 的长度
- 空间复杂度：`O(n^2⋅2^n)`