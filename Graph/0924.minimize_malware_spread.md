# 924.尽量减少恶意软件的传播

题目链接：[924.尽量减少恶意软件的传播](https://leetcode.cn/problems/minimize-malware-spread/)

## 题目大意

给出了一个由 n 个节点组成的网络，用 n × n 个邻接矩阵图 graph 表示。在节点网络中，当 graph[i][j] = 1 时，表示节点 i 能够直接连接到另一个节点 j

一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染

假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数

如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点

请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后仍有可能因恶意软件传播而受到感染

```js
Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

Example 3:
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1
```

限制:
- n == graph.length, n == graph[i].length
- 2 <= n <= 300
- graph[i][j] is 0 or 1.
- graph[i][j] == graph[j][i]
- graph[i][i] == 1
- 1 <= initial.length <= n
- 0 <= initial[i] <= n - 1
- All the integers in initial are unique.

## 解题

题意：我移除的仅仅是 `initial` 列表中的节点而不是图中的节点，不会影响图的结构

思路：
- 一个大小为 `k` 的连通块内，如果只有一个节点 `x` 被感染（`x` 在 `initial` 中），则从 `initial` 中移除 `x` 后这个连通块不会被感染，从而让 `M(initial)` 减少 `k`
- 如果连通块内至少有两个节点被感染，无论移除哪个节点，仍然会导致连通块的所有节点被感染，`M(initial)` 不变
- 所以要找的是`只包含一个被感染节点的连通块，且这个连通块越大越好`

算法：
- 遍历 `initial` 中的节点 `x`
- 如果 `x` 没有被访问过，则从 `x` 开始 `DFS`，同时用一个 `visited` 数组标记访问过的节点
- `DFS` 过程中，统计连通块的大小 `size`
- `DFS` 过程中，记录访问到的在 `initial` 中的节点
- `DFS` 结束后，如果发现该连通块只有一个在 `initial` 中的节点，且该连通块的大小比最大的连通块更大，则更新最大连通块的大小，以及答案节点 `x`；如果一样大，就更新答案节点的最小值
- 最后，如果没找到符合要求的节点，返回 `min(initial)`；否则返回答案节点

> 如何判断出「连通块内有一个或多个在 initial 中的节点」？要记录被感染的节点列表吗？-> 无需记录节点列表，而是用如下状态机：
> - 初始状态为 `−1`
> - 如果状态是 `−1`，在找到被感染的节点 `x` 后，状态变为 `x`
> - 如果状态是非负数 `x`，在找到另一个被感染的节点后，状态变为 `−2`；如果状态已经是 `−2`，则不变
> 此外，可以用一个`哈希表`或`布尔数组`，记录哪些点在 `initial` 中，从而在 `DFS` 中快速判断当前节点是否在 `initial` 中

```js
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
    const initial_set = new Set(initial);
    const visited = Array(graph.length).fill(false);
    let nodeId, size;
    function dfs(x) {
        visited[x] = true;
        size++;
        if (nodeId !== -2 && initial_set.has(x)) {
            nodeId = nodeId === -1 ? x : -2;
        }
        for (let y = 0; y < graph[x].length; y++) {
            if (graph[x][y] === 1 && !visited[y]) {
                dfs(y);
            }
        }
    }

    let res = -1;
    let max_size = 0;
    for (const x of initial) {
        if (visited[x]) {
            continue;
        }
        nodeId = -1;
        size = 0;
        dfs(x);
        if (nodeId >= 0 && (size > max_size || size === max_size && nodeId < res)) {
            res = nodeId;
            max_size = size;
        }
    }
    return res < 0 ? Math.min(...initial) : res;
};
```
```python
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # 将初始感染节点转换为集合以加快查询速度，供 DFS 使用
        # 时间复杂度从 O(n) 降到 O(1)
        initial_set = set(initial)
        # 创建一个布尔数组 visited 用于标记哪些节点已经被访问过
        # 长度为图的节点数 n
        visited = [False] * len(graph)

        def dfs(x: int) -> None:
            # 标记当前节点 x 已访问
            # 使用递归方式处理所有与 x 相连的未访问节点
            visited[x] = True

            # size：当前连通分量的节点数量
            # nonlocal 表示使用外部函数 minMalwareSpread 中定义的变量
            nonlocal node_index, size
            size += 1

            # 这部分用于判断连通分量中是否有 多个感染源：
            # node_index == -1：当前 DFS 是该连通块中遇到的第一个初始感染节点
            # 如果遇到第二个感染节点，则设置为 -2，表示该连通块有 多个感染节点，无法通过移除一个节点阻止其全部感染
            if node_index != -2 and x in initial_set:
                node_index = x if node_index == -1 else -2
            
            # 遍历所有与 x 相连的节点 y
            # 如果 x 和 y 有连接（conn == 1）且 y 没有访问过，就递归访问 y
            for y, conn in enumerate(graph[x]):
                if conn and not visited[y]:
                    dfs(y)
        
        # 主逻辑：遍历 initial 节点并判断哪个删除最优
        # res：记录当前最优的被删除节点编号（结果）
        res = -1
        # max_size：记录最大可救连通分量的大小
        max_size = 0
        for x in initial:
            # 如果 x 已访问过，说明其所在的连通块已经处理，无需重复
            if visited[x]:
                continue
            
            # 初始化一个新连通块，准备进行 DFS
            # node_index 用于判断这个连通块是否只含有一个感染源
            node_index = -1
            size = 0
            dfs(x)

            # 仅当该连通分量 只包含一个初始感染节点（即 node_index >= 0）时，才考虑移除
            # 如果该连通块更大（更值得“拯救”）或大小相等但编号更小，则更新 res
            if node_index >= 0 and (size > max_size or size == max_size and node_index < res):
                res = node_index
                max_size = size
        
        # 如果所有连通块都包含多个感染节点（无法拯救任何节点），就返回编号最小的初始节点
        # 否则返回 res，即可以“救下最多节点”的初始节点
        return min(initial) if res < 0 else res
```

- 时间复杂度：`O(n^2)`，其中 `n` 为 `graph` 的长度瓶
- 空间复杂度：`O(n)`