# 1136.并行课程

题目链接：[1136.并行课程](https://leetcode.cn/problems/parallel-courses/)

## 题目大意

给你一个整数 n ，表示编号从 1 到 n 的 n 门课程。另给你一个数组 relations ，其中 relations[i] = [prevCoursei, nextCoursei] ，表示课程 prevCoursei 和课程 nextCoursei 之间存在先修关系：课程 prevCoursei 必须在 nextCoursei 之前修读完成

在一个学期内，你可以学习 任意数量 的课程，但前提是你已经在 上 一学期修读完待学习课程的所有先修课程

请你返回学完全部课程所需的 最少 学期数。如果没有办法做到学完全部这些课程的话，就返回 -1

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.icktch4ac.webpp)

限制：
- 1 <= n <= 5000
- 1 <= relations.length <= 5000
- relations[i].length == 2
- 1 <= prevCoursei, nextCoursei <= n
- prevCoursei != nextCoursei
- All the pairs [prevCoursei, nextCoursei] are unique.

## 解题

在这个问题中，我们需要以最快的速度学完所有课程
- 我们在一个学期内可以学习的课程数量是无限的，唯一的限制是先修课程关系：只能学习那些已经满足先修课程要求的课程

这个问题是`拓扑排序`的一个应用，主要有两种思路：`广度优先搜索（Breadth-First Search，简称 BFS）`和`深度优先搜索（Depth-First Search，简称 DFS）`

> 拓扑排序正是为了解决“有依赖关系的顺序问题”，拓扑排序是用来处理 有向无环图（DAG） 中的任务调度问题。常见的应用场景包括：
> - 课程安排（如本题）
> - 编译依赖
> - 项目任务顺序
> - 数据流管线构建
> 
> 拓扑排序能解决什么问题？
> - 给出任务的一个执行顺序，使得所有依赖都被满足
> - `检测是否有环（如果图不是 DAG，就无法进行拓扑排序）`
> - 支持计算“最早完成某个任务的时间”或“总时间最少需要几步完成所有任务”

可以有三种方法：
- 广度优先搜索（Kahn's 算法）
- 深度优先搜索：检查循环 + 寻找最长路径
- 深度优先搜索：结合前两种

### 思路 1: 广度优先搜索（Kahn's 算法）

将问题看作`有向图问题（课程是节点，先修课程关系是边）`，把 `relations[i] = [u, v]` 视为一条从 `u → v` 的有向边，表示上完 `u` 才能上 `v`，我们需要做的就是以某种方式遍历图中的所有节点

为了达到最快的学习速度，策略是：`在每个学期学习所有可供学习的课程`
> 即使刻意选择不学习一个可用的课程，在以后的学期中仍然需要学习它，现在学习没有任何害处。另外，如果晚点再学习，那么就必须推迟所有以该课程为先修课程的课程

- 现在，第一个问题是：从哪里开始？（哪些课程是可供学习的？）
- 不能从有先修课程的课程开始学习，从没有先修课程的节点开始

解题思路：
- 拓扑排序模型
  - 使用 入度表 `in_degree` 记录每门课被多少先修课依赖
  - 使用 邻接表 `graph` 记录每门课可以通向哪些后续课程
  - 初始时，把所有 入度为 `0` 的课程加入队列（这些可以在第一学期上）
- 学期模拟（层次遍历）
  - 一轮 `BFS` 代表一个学期，表示当前所有入度为 `0` 的课程可以并行上
  - 每上一门课，就将它影响的课程的入度减 `1`，如果变成 `0`，则加入下一轮
  - 最终，如果能把所有课程上完，则返回总轮数；否则说明存在环，返回 `-1`

```js
var minimumSemesters = function(n, relations) {
    // 构建邻接表
    const graph = new Map();
    const inDegree = new Array(n + 1).fill(0);

    for (const [start, end] of relations) {
        if (!graph.has(start)) {
        graph.set(start, []);
        }
        graph.get(start).push(end);
        inDegree[end]++;
    }

    // 初始化队列：所有入度为 0 的课程
    const queue = [];
    for (let i = 1; i <= n; i++) {
        if (inDegree[i] === 0) {
        queue.push(i);
        }
    }

    let semester = 0;
    let taken = 0;

    // BFS 按层遍历
    while (queue.length > 0) {
        semester++;
        const size = queue.length;

        for (let i = 0; i < size; i++) {
        const course = queue.shift();
        taken++;

        if (!graph.has(course)) continue;

        for (const next of graph.get(course)) {
            inDegree[next]--;
            if (inDegree[next] === 0) {
            queue.push(next);
            }
        }
        }
    }

    return taken === n ? semester : -1;
};
```
```python
# 写法 1
class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = defaultdict(list)
        in_degree = [0] * (n + 1)

        for start, end in relations:
            graph[start].append(end)
            in_degree[end] += 1
        
        queue = deque()
        for i in range(1, n + 1):
            if in_degree[i] == 0:
                queue.append(i)
        
        semester = 0
        taken = 0

        while queue:
            semester += 1
            for _ in range(len(queue)):
                course = queue.popleft()
                taken += 1
                for neighbor in graph[course]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)

        return semester if taken == n else -1
      
# 写法 2
class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = {i: [] for i in range(1, n + 1)}
        in_count = {i: 0 for i in range(1, n + 1)}  # 或者入度
        for start_node, end_node in relations:
            graph[start_node].append(end_node)
            in_count[end_node] += 1

        queue = []
        # 我们使用 list 因为我们
        # 在这份代码中不会弹出前面的元素
        for node in graph:
            if in_count[node] == 0:
                queue.append(node)

        step = 0
        studied_count = 0
        # 开始使用BFS学习
        while queue:
            # 开始一个新学期
            step += 1
            next_queue = []
            for node in queue:
                studied_count += 1
                end_nodes = graph[node]
                for end_node in end_nodes:
                    in_count[end_node] -= 1
                    # 如果所有先修课程都已经学习
                    if in_count[end_node] == 0:
                        next_queue.append(end_node)
            queue = next_queue

        return step if studied_count == n else -1
```

- 时间复杂度：`O(N+E)`. 设 `E` 为 `relations` 的长度，`N` 是课程的数量
  - 对于构建图，需 `O(N)` 来初始化图，并需 `O(E)` 来添加边，因为要遍历一次 `relations`
  - 对于 `BFS`，需 `O(N+E)`，因为在最坏的情况下，需在 `BFS` 中访问每个节点和边一次
- 空间复杂度：`O(N+E)`. 
  - 对于图，需 `O(N+E)`，因为有 `O(N)` 个键和 `O(E)` 个值
  - 对于 `BFS`，需 `O(N)`，因为在最坏的情况下，需要在同一时间添加所有节点到队列中

### 思路 2: 

问题建模
- 每门课程是一个 有向图中的节点
- 每个 `relations[i] = [a, b]` 表示：`a → b`，即 `b` 的前置课程是 `a`
- 需要找出 图中最长的一条路径的长度（即最长依赖链），这就是最少需要的学期数

这就变成了：`在一个 有向无环图（DAG） 中找出最长路径的长度`

```js
var minimumSemesters = function(n, relations) {
    const graph = new Map();

    for (const [start, end] of relations) {
        if (!graph.has(start)) {
        graph.set(start, []);
        }
        graph.get(start).push(end);
    }

    // visited 状态：
    // -1 = 正在访问（用于检测环）
    // >0 = 该节点的最长路径长度
    const visited = new Map();

    function dfs(course) {
        if (visited.has(course)) {
        return visited.get(course);
        }

        // 标记为访问中
        visited.set(course, -1);

        let maxLen = 1; // 当前课程至少需要 1 个学期

        if (graph.has(course)) {
        for (const next of graph.get(course)) {
            const len = dfs(next);
            if (len === -1) return -1; // 检测到环
            maxLen = Math.max(maxLen, len + 1);
        }
        }

        visited.set(course, maxLen);
        return maxLen;
    }

    let res = 0;
    for (let course = 1; course <= n; course++) {
        const len = dfs(course);
        if (len === -1) return -1;
        res = Math.max(res, len);
    }

    return res;
};
```
```python
class Solution:
    def minimumSemesters(self, n: int, relations: List[List[int]]) -> int:
        graph = defaultdict(list)
        for start, end in relations:
            graph[start].append(end)
        
        visited = {}
        def dfs(node: int) -> int:
            if node in visited:
                return visited[node]
            else:
                visited[node] = -1

            max_len = 1  
            for neibour in graph[node]:
                length = dfs(neibour)
                if length == -1:
                    return -1

                max_len = max(max_len, length + 1)

            visited[node] = max_len
            return max_len

        res = 0
        for course in range(1, n + 1):
            length = dfs(course)
            if length == -1:
                return -1 
                
            res = max(res, length)

        return res
```

- 时间复杂度：`O(N+E)`
  - 对于构建图，需 `O(N)` 来初始化图，并花费 `O(E)` 来添加边，因为要遍历一次 `relations`
  - 对于 `DFS`，需 `O(N+E)`，因为在最坏的情况下，需要在 `DFS` 中访问每个节点和边一次
- 空间复杂度：`O(N+E)`
  - 对于图，需 `O(N+E)`，因为有 `O(N)` 个键和 `O(E)` 个值
  - 对于 `DFS`，需 `O(N)`，因为在最坏的情况下，需要在栈中添加所有节点以递归调用 `DFS`

