# 535.TinyURL 的加密与解密

题目链接：[535.TinyURL 的加密与解密](https://leetcode.cn/problems/encode-and-decode-tinyurl/)

## 题目大意

TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 

加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 

实现 Solution 类：

Solution() 初始化 TinyURL 系统对象。
String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。
String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的

```js
Example 1:
Input: url = "https://leetcode.com/problems/design-tinyurl"
Output: "https://leetcode.com/problems/design-tinyurl"
Explanation:
Solution obj = new Solution();
string tiny = obj.encode(url); // returns the encoded tiny url.
string ans = obj.decode(tiny); // returns the original url after decoding it.
```

限制:
- 1 <= url.length <= 10^4
- url is guranteed to be a valid URL.

## 解题

**最初思路 — 暴力哈希**

- 用一个全局字典存储映射：
  - longUrl → shortUrl
  - shortUrl → longUrl
- 生成短 URL 可以：
  - 使用计数器 + base62 编码
  - 或随机生成固定长度字符串

问题分析
- 如果使用计数器 + base62：
  - 每次 encode → 计数器自增 → base62 → 得到短字符串
  - decode → 用映射表查回原 URL
- 随机字符串 + 冲突处理：
  - 生成随机长度 6 的字符（a-zA-Z0-9）
  - 检查是否重复 → 避免冲突

### 思路 1: 自增 ID + base62 + 哈希表

核心思路
- URL 编码 → 唯一 ID → base62 → 短 URL
- 短 URL → base62 → ID → 查表 → 原 URL

base62 原理
- 用 62 个字符表示数字：
  ```js
  0-9 → '0'-'9'
  10-35 → 'a'-'z'
  36-61 → 'A'-'Z'
  ```
- 将数字转换为 base62 → 短字符串
- 反向转换 → 原 ID

优势
- 短码长度随计数器增长 → 早期短 URL 很短
- 支持数百万 URL

优先选择计数器 + 哈希表，因为：
- 确保唯一性，无需处理随机冲突
- encode/decode 都是 O(1)
- 简单易实现

核心结构：
```js
counter: int → 自增，生成唯一 id
url_map: dict[int → str] → 存储 id → longUrl
shortUrl_prefix: "http://tinyurl.com/"
```

`encode` 流程：
- counter 自增得到唯一 id
- id 转 base62 得到短码
- 保存 id → longUrl 映射
- 返回 prefix + short_code

`decode` 流程：
- 从短 URL 提取短码
- base62 → id
- 查表返回原 URL

```js
const base = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const prefix = "http://tinyurl.com/";
let counter = 1;                // 全局自增计数器
const urlMap = new Map();       // id -> longUrl 映射

// 辅助函数：id -> base62
function idToBase62(id) {
    if (id === 0) return base[0];
    let chars = [];
    while (id > 0) {
        chars.push(base[id % 62]);
        id = Math.floor(id / 62);
    }
    return chars.reverse().join('');
}

// 辅助函数：base62 -> id
function base62ToId(shortCode) {
    let id = 0;
    for (const c of shortCode) {
        id = id * 62 + base.indexOf(c);
    }
    return id;
}

/**
 * Encodes a URL to a shortened URL.
 *
 * @param {string} longUrl
 * @return {string}
 */
var encode = function(longUrl) {
    const id = counter++;
    urlMap.set(id, longUrl);
    const shortCode = idToBase62(id);
    return prefix + shortCode;
};

/**
 * Decodes a shortened URL to its original URL.
 *
 * @param {string} shortUrl
 * @return {string}
 */
var decode = function(shortUrl) {
    const shortCode = shortUrl.replace(prefix, "");
    const id = base62ToId(shortCode);
    return urlMap.get(id);
};
```
```python
class Codec:
    def __init__(self):
        self.counter = 1                          # 唯一自增计数器
        self.url_map = {}                         # id → 原 URL 映射
        self.base = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        self.prefix = "http://tinyurl.com/"

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        id = self.counter
        self.url_map[id] = longUrl               # 保存映射
        self.counter += 1
        short_code = self._id_to_base62(id)     # id 转 base62
        return self.prefix + short_code

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        short_code = shortUrl.replace(self.prefix, "")
        id = self._base62_to_id(short_code)
        return self.url_map[id]
    
    # 辅助函数: id → base62 编码
    def _id_to_base62(self, id: int) -> str:
        if id == 0:
            return self.base[0]
        chars = []
        while id > 0:
            chars.append(self.base[id % 62])
            id //= 62
        return ''.join(reversed(chars))

    # 辅助函数: base62 → id
    def _base62_to_id(self, short_code: str) -> int:
        id = 0
        for c in short_code:
            id = id * 62 + self.base.index(c)
        return id
```

- 时间复杂度：
  - Encode 函数：`O(n)`，其中 `n` 是字符串 `longUrl` 的长度
    - counter++ → O(1)
    - urlMap.set(id, longUrl) → O(1) 哈希表操作（存储引用，不需要复制整个字符串，严格意义下是 O(1)）
    - idToBase62(id) → 将整数 id 转为 base62 字符串
    - id 长度大约是 log_62(counter)
    - 每次循环除 62 → O(log(counter))
    - longUrl 的长度 n 对 encode 时间几乎无影响（因为存的是引用，不是做字符串复制或哈希计算）
    - ✅ 所以 encode 时间复杂度：O(log(counter)) → 可以认为是 O(1) 级别，或者说是 与 URL 长度无关
  - Decode 函数：`O(1)`，把 `shortUrl` 当成有限长度的字符串看待
- 空间复杂度：
  - Encode 函数：`O(n)`。保存字符串 `longUrl` 需要 `O(n)` 的空间
  - Decode 函数：`O(1)`

### 思路 2: 哈希生成

Encode 函数
- 设字符串 longUrl 的长度为 n，选择两个合适的质数 k1 = 1117，k2 = 10^9 + 7，使用以下方法来计算 longUrl 的哈希值：
  ![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1e94zniqc9.webp)
- 将哈希值作为 longUrl 的 key，将键值对 (key,longUrl) 插入数据库 dataBase，然后返回带有 key 的字符串作为 shorUrl
- 发生哈希冲突时，采用`线性探测再散列`的方法，将 key 加一，直到没有冲突。相同的 longUrl 的哈希值相同，因此哈希冲突会频繁发生。为了避免这一点，`使用一个额外的哈希表记录从 longUrl 到 key 的映射`

Decode 函数
- 将 shortUrl 转换成对应的 key，然后在数据库 dataBase 中查找 key 对应的 longUrl

```python
K1, K2 = 1117, 10 ** 9 + 7
class Codec:
    def __init__(self):
        self.dataBase = {}
        self.urlToKey = {}

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        if longUrl in self.urlToKey:
            return "http://tinyurl.com/" + str(self.urlToKey[longUrl])
        key, base = 0, 1
        for c in longUrl:
            key = (key + ord(c) * base) % K2
            base = (base * K1) % K2
        while key in self.dataBase:
            key = (key + 1) % K2
        self.dataBase[key] = longUrl
        self.urlToKey[longUrl] = key
        return "http://tinyurl.com/" + str(key)

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        i = shortUrl.rfind('/')
        key = int(shortUrl[i + 1:])
        return self.dataBase[key]
```

- 时间复杂度：
  - Encode 函数：O(n)，其中 n 是字符串 longUrl 的长度。在数据量远小于 10^9+7 的情况下，发生哈希冲突的可能性十分小
  - Decode 函数：O(1)。我们当 shortUrl 当成有限长度的字符串看待
- 空间复杂度：
  - Encode 函数：O(n)。保存字符串 longUrl 需要 O(n) 的空间
  - Decode 函数：O(1)
