# 974.和可被 K 整除的子数组

题目链接：[974.和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

## 题目大意

给定一个整数数组 `nums` 和一个整数 `k`，返回其中元素之和可被 `k` 整除的非空 子数组 的数目。

子数组 是数组中 连续 的部分

```js
Example 1:
Input: nums = [4,5,0,-2,-3,1], k = 5
Output: 7
Explanation: There are 7 subarrays with a sum divisible by k = 5:
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

Example 2:
Input: nums = [5], k = 9
Output: 0
```

限制：
- 1 <= nums.length <= 3 * 10^4
- -10^4 <= nums[i] <= 10^4
- 2 <= k <= 10^4

## 解题

优化解法：前缀和 + 同余类哈希计数

观察发现：
- 如果两个前缀和 `preSum[j]` 和 `preSum[i-1]` 满足 `(preSum[j] - preSum[i-1]) % k == 0`，则说明从 `i` 到 `j` 的子数组之和可以整除 `k`
- 变形得：如果 `preSum[j] % k == preSum[i-1] % k`，就说明该子数组符合条件

因此，我们只需要统计每种`「前缀和模 k 的余数」`出现的次数

使用哈希表 `valToIndex` 来记录每种余数出现的频次

✅ 解法核心逻辑总结：
- 使用一个变量 `preSum` 维护当前的前缀和
- 每一步计算 `preSum % k`，处理负数时将其调整为非负（`Python` 中 `-1 % 5 == 4`，但其他语言可能返回负数）
- 如果该余数之前出现过，就说明存在若干个子数组满足整除条件，直接将出现次数加到结果中
- 然后更新该余数的出现次数

```js
var subarraysDivByK = function(nums, k) {
    let preSum = 0;
    let res = 0;
    // key: 余数 remainder, value: 出现次数
    const valToIndex = new Map();
    valToIndex.set(0, 1); // 初始化余数0出现一次

    for (let num of nums) {
        preSum += num;
        let cur = preSum % k;
        if (cur < 0) cur += k; // JS的%可能为负数，修正成正余数

        if (valToIndex.has(cur)) {
            res += valToIndex.get(cur);
            valToIndex.set(cur, valToIndex.get(cur) + 1);
        } else {
            valToIndex.set(cur, 1);
        }
    }

    return res;
};
```
```python
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:  
        # preSum: 当前的前缀和
        # res: 满足条件的子数组个数
        # valToIndex: 哈希表，key 为前缀和模 k 的余数，value 为该余数出现次数
        # 初始化为 {0: 1} 是因为前缀和刚好可以被 k 整除的情况也要算在内（即从头开始的子数组）
        preSum, res, valToIndex = 0, 0, {0: 1}
        for num in nums:
            # 遍历数组，同时累加当前数值到前缀和中
            preSum += num
            # cur 是当前前缀和模 k 的结果
            # 如果为负数（比如总和为 -1，-1 % 5 = -1），就加上 k 变为非负余数，以便统一处理
            cur = preSum % k
            if cur < 0:
                cur += k
            
            # 如果当前余数之前出现过，则说明存在等价前缀和，可以构成满足条件的子数组个数为 valToIndex[cur]，累加到结果里
            # 然后将当前余数的计数加一，记录这次出现
            if cur in valToIndex:
                res += valToIndex[cur]
                valToIndex[cur] += 1
            else:
                # 如果该余数第一次出现，就初始化为 1
                valToIndex[cur] = 1

        # 返回统计的总个数 
        return res

# class Solution:
#     def subarraysDivByK(self, nums: List[int], k: int) -> int:
#         n = len(nums)
#         preSum = [0] * (n + 1)
#         valToIndex = {0: 1}
#         res = 0
#         for i in range(n):
#             preSum[i + 1] = preSum[i] + nums[i]
#             cur = preSum[i + 1] % k
#             # 考虑到 preSum[i + 1] 可能是负数，根据求模的特性，-2 % 3 的结果是 -2
#             # 但实际想要正余数，所以这里需要对 cur 进行调整
#             if cur < 0:
#                 # 将负余数调整为一个对应的正余数，确保所有的余数都在 0 到 k-1 之间
#                 # 确保余数在哈希表查找和匹配过程中保持一致，避免因符号差异引起的错误匹配
#                 cur += k
#             if cur in valToIndex:
#                 res += valToIndex[cur]
#                 valToIndex[cur] += 1
#             else:
#                 valToIndex[cur] = 1
#         return res
```

- 时间复杂度：`O(n)`，其中 `n` 是数组 `nums` 的长度。只需要从前往后遍历一次数组，在遍历数组的过程中，维护哈希表的各个操作均为 `O(1)`，因此总时间复杂度为 `O(n)`
- 空间复杂度：`O(min(n,k))`，即哈希表需要的空间。当 `n≤k` 时，最多有 `n` 个前缀和，因此哈希表中最多有 `n+1` 个键值对；当 `n>k` 时，最多有 `k` 个不同的余数，因此哈希表中最多有 `k` 个键值对。即哈希表需要的空间取决于 `n` 和 `k` 中的较小值





