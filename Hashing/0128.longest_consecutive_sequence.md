# 128.最长连续序列

题目链接：[128.最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

## 题目大意

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度

请设计并实现时间复杂度为 `O(n)` 的算法解决此问题

```js
Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
```

限制：
- 0 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9

## 解题

这道题最直接的想法就是`排序`，排序后连续的序列就很容易找到。不过排序的时间复杂度是 `O(nlogn)`，而题目要求的时间复杂度为 `O(n)`

此处使用`哈希表 + 只从序列起点开始延伸`过程

核心思想：
- 将所有数字加入 `set`，使查找为 `O(1)`
- 遍历每个数字 `num`，只从 “序列起点” 开始延伸：
  - 如果 `num - 1` 不在 `set` 中，说明 `num` 是一个序列的起点
  - 向后不断查找 `num + 1`, `num + 2`, ... 直到找不到为止
  - 记录这一段连续序列长度

避免重复计算，整体复杂度 `O(n)`

> 为什么想到先把 `nums` 转成 `set`？
> - 动机：提升查找效率（`O(1)`）
>   - 在本题中，我们频繁需要判断某个数的相邻数是否存在，如：`if num + 1 in nums`
>   - 如果直接在原始的 `list` 中查找，每次 `in` 操作的时间复杂度是 `O(n)`，因为列表查找是线性的
>   - 如果将 `nums` 转为 `set`，则查找时间就变成了 `O(1)`，因为哈希表实现的是常数时间的查找
> - 还有一个 bonus：自动去重
>   - 将 `nums` 转为 `set(nums)` 的同时：所有 重复元素自动去除
>   - 这样可以防止因为重复数字导致重复扩展同一段连续序列（影响性能）
>   - 例如：`nums = [1, 2, 2, 3] -> set(nums) = {1, 2, 3}`
>   - 只需在去重后的集合中寻找起点，大大减少了无意义的操作

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function(nums) {
    const numSet = new Set(nums); 
    let res = 0;
    for (const x of numSet) { 
        if (numSet.has(x - 1)) continue;

        let y = x + 1;
        while (numSet.has(y)) { 
            y++;
        }

        res = Math.max(res, y - x); 
        if (res * 2 >= numSet.size) break;
    }
    return res;
};
```
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 将 nums 转换为 set，用于 O(1) 时间复杂度的查找，方便后续判断连续性
        nums_set = set(nums)  
        # 记录去重后的元素个数，用于后面优化（early stop）
        n = len(nums_set)
        # 初始化结果变量 res，用于记录最长连续序列长度
        res = 0

        # 遍历 set 中的每个数（去重后的），避免重复处理
        for num in nums_set:  
            # 跳过非起点：如果存在比当前数小 1 的数（即 num - 1），说明 num 不是连续序列的起点，跳过这个数
            # 例如 2 会被 1 扩展过，不再重复处理
            if num - 1 in nums_set:  
                continue
            
            # 从当前 num 开始向后扩展连续序列
            next_num = num + 1
            # 不断查找是否存在 num+1, num+2 ... 的连续数字，直到找不到为止
            while next_num in nums_set: 
                next_num += 1
            
            # 计算当前从 num 开始的连续序列长度为 next_num - num，更新最大值 res
            res = max(res, next_num - num) 

            # 提前退出优化：
            # 如果当前找到的序列长度 `* 2` 已大于等于总数（即不可能再有更长的序列），就提前退出循环
            # 因为从未访问过的点最多组成一个序列长度 `≤ n - res`，而当前已找到 `res ≥ n / 2`，就可以提前返回结果
            # 这个技巧在稀疏或集中分布的数据中尤其有效
            if res * 2 >= n:  
                break
        
        # 返回结果
        return res
```

- 时间复杂度：`O(n)`，`n` 为数组的长度，每个元素只会被遍历和检查一次
- 空间复杂度：`O(n)`，额外使用了一个 `set` 存储所有元素