# 49.字母异位词分组

题目链接：[49.字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

## 题目大意

给定一个字符串数组 `strs`，将字谜一起

可以按任意顺序返回答案

```js
Example 1:
Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]

Example 2:
Input: strs = [""]
Output: [[""]]

Example 3:
Input: strs = ["a"]
Output: [["a"]]
```

限制：
- 1 <= strs.length <= 10^4
- 0 <= strs[i].length <= 100
- strs[i] consists of lowercase English letters

## 解题

字母异位词是指，两个字符串包含的字母种类和数量完全相同，只是顺序不同

思路：
- 使用对象存储，对字符串进行编码（`ASCII`码），再判断是否存在对象中
  - 为了将所有的字母异位词归为同一组，需要一种方式对每个字符串进行“标准化”表示，这种表示能够唯一标识一个异位词组
  - 这里选择的编码方式是基于`字符频率统计`，即统计每个字母出现的次数，并将次数转换为字符串（编码）
  - 对于任意两个字符串，如果它们的字符种类和数量一致，则它们的字符频率数组完全相同，转化为字符串后也相同
- 对象存储，若对每个字符串先排序再判断，则会多一个排序的时间复杂度

### 思路 1：哈希表 + 字符串编码

核心思想：每个字符串根据其「字母频次特征」编码成一个 `key`，相同 `key` 的字符串放入同一组

使用 字母频次数组 编码而不是排序，有更好的时间复杂度

如：
- `"eat" -> [1, 0, ..., 1, ..., 1]`，代表 `e, a, t` 各出现一次
- `"tea"` 也会被编码成同一个数组

使用 `dict` 将编码后的数组作为 `key`，把所有属于同一组的字符串聚合到同一个 `list` 中

```js
var groupAnagrams = function(strs) {
    let res = [];
    let codeToGroup = new Map();
    for (let s of strs) {
        let code = encode(s);
        if(!codeToGroup.has(code)) {
            codeToGroup.set(code, []);
        }

        codeToGroup.get(code).push(s);
    }

    for(let group of codeToGroup.values()) {
        res.push(group);
    }
    return res;
};

var encode = function(s) {
    // 初始化一个长度为 26 的数组，表示 26 个字母的频率
    let count = new Array(26).fill(0);
    // 遍历字符串，更新数组中对应字母的计数
    for (let c of s) {
        let delta = c.charCodeAt() - 'a'.charCodeAt();
        count[delta]++;
    }
    return count.toString();
};
```
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # 初始化最终结果列表 res，用于存储每组异位词
        res = []

        # 建立一个哈希表 codeToGroup，用于存储：
        # key: 字母频率编码（字符串形式）
        # value: 同组异位词字符串列表
        codeToGroup = {}

        # 遍历输入数组中的每个字符串
        for s in strs:
            # 调用辅助函数 encode(s)，将字符串 s 编码为字母频率数组的字符串形式
            # 如："ate" 编码成 '[1, 0, ..., 1, ..., 1]'
            code = self.encode(s)

            # 如果该编码不存在于哈希表中，初始化一个新的 list
            if code not in codeToGroup:
                codeToGroup[code] = []
            
            # 将当前字符串 s 添加到对应编码的组中
            codeToGroup[code].append(s)
        
        # 遍历哈希表中所有的值（即一组组异位词），依次加入结果列表 res 中
        for group in codeToGroup.values():
            res.append(group)
        
        # 返回所有异位词分组结果
        return res
    
    # 辅助函数 encode
    def encode(self, s):
        # 初始化一个长度为 26 的数组，记录每个字母出现的频率
        count = [0] * 26
        for c in s:
            # 遍历字符串 s 的每个字符 c，计算其对应的索引（相对于 'a' 的偏移），并将对应位置计数加一
            delta = ord(c) - ord("a")
            count[delta] += 1
        
        # 将频次数组转换为字符串，作为哈希表的 key
        # 虽然是列表，但转成字符串就可以作为字典的 key 使用了
        return str(count)
```

- 时间复杂度：`O(n * k)`
  - `n` 是字符串列表 `strs` 中的字符串个数，`k` 是字符串的最大长度
  - 遍历每个字符串并生成编码，整体时间复杂度为 `O(n * k)`
- 空间复杂度：`O(n * k)`，使用的主要额外空间包括字典 `codeToGroup` 和结果列表 `res`，总体空间复杂度为 `O(n * k)`

### 思路 2：对每个字符串先排序再判断

```js
var groupAnagrams = function(strs) {
    const strDict = {};
    for (const s of strs) {
        const sortedStr = s.split('').sort().join('');
        if (strDict[sortedStr]) {
            strDict[sortedStr].push(s);
        } else {
            strDict[sortedStr] = [s];
        }
    }
    return Object.values(strDict);
};
```
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        strDict = {}
        res = []
        for s in strs:
            sortS = str(sorted(s))
            if sortS in strDict:
                strDict[sortS] += [s]
            else:
                strDict[sortS] = [s]
        
        for sortS in strDict:
            res += [strDict[sortS]]
        
        return res
```

- 时间复杂度：`O(n * k log k)`
  - `n` 是字符串列表 `strs` 中的字符串个数，`k` 是字符串的最大长度
  - 排序所有字符串的时间复杂度为 `O(n * k log k)`
  - 字典查找和插入的时间复杂度为 `O(n)`
  - 构建结果列表的时间复杂度为 `O(n)`
- 空间复杂度: `O(n * k)`

