# 311.稀疏矩阵的乘法

题目链接：[311.稀疏矩阵的乘法](https://leetcode.cn/problems/sparse-matrix-multiplication/)

## 题目大意

给定两个稀疏矩阵：大小为 m x k 的稀疏矩阵 mat1 和大小为 k x n 的稀疏矩阵 mat2 ，返回 mat1 x mat2 的结果。你可以假设乘法总是可能的

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2vf861hp9q.webp)

限制:
- m == mat1.length, n == mat2[i].length
- k == mat1[i].length == mat2.length
- 1 <= m, n, k <= 100
- -100 <= mat1[i][j], mat2[i][j] <= 100

## 解题

### 思路 1: 迭代 - 利用稀疏特性

只对非零元素计算：
- 对 `mat1[i][l] != 0` 才参与计算
- 对 `mat2[l][j] != 0` 才参与计算
- 减少不必要的乘法

行列映射法：
- 对 `mat1`：记录每行非零列 `(l, val)`
- 对 `mat2`：记录每列非零行 `(l, val)`
- 然后计算对应行列乘积

总结：
- 利用 稀疏矩阵特性，跳过零元素
- 减少乘法次数，提高效率
- 保留行列遍历逻辑，最终结果与普通矩阵乘法一致

```js
var multiply = function(mat1, mat2) {
    const m = mat1.length;
    const k = mat1[0].length;
    const n = mat2[0].length;

    // 初始化结果矩阵 m x n
    const res = Array.from({ length: m }, () => Array(n).fill(0));

    for (let row = 0; row < m; row++) {
        const rowElements = mat1[row];
        for (let elementIndex = 0; elementIndex < k; elementIndex++) {
            const rowElement = rowElements[elementIndex];
            if (rowElement !== 0) { // 仅处理非零元素
                const colElements = mat2[elementIndex];
                for (let col = 0; col < n; col++) {
                    res[row][col] += rowElement * colElements[col];
                }
            }
        }
    }

    return res;
};
```
```python
class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
        # 获取矩阵大小：
        # mat1：m行，k列
        # mat2：k行，n列
        m, k, n = len(mat1), len(mat1[0]), len(mat2[0])
        # 初始化结果矩阵 res 为 m × n 全零矩阵
        res = [[0] * n for _ in range(m)]  

        for row, row_elements in enumerate(mat1):
            for element_index, row_element in enumerate(row_elements):
                if row_element:
                    for col, col_element in enumerate(mat2[element_index]):
                        res[row][col] += row_element * col_element
            
        return res
```

- 时间复杂度：`O(m⋅k⋅n)`，令 `m` 和 `k` 分别表示 `mat1` 的行数和列数，令 `k` 和 `n` 分别表示 `mat2` 的行数和列数
  - 迭代矩阵 `mat1` 的所有 `m⋅k` 个元素
  - 对于矩阵 `mat1` 的每个元素，我们迭代矩阵 `mat2` 的所有 `n` 列
  - 因此，这导致了 m⋅k⋅n 的时间复杂度
- 空间复杂度：`O(1)`，使用大小为 `m×n` 的矩阵 `res` 来输出乘积结果，这不包括在辅助空间中

### 思路 2: 列表的列表

在上一个方法中，检查了矩阵 `mat1` 中的非零元素，但如果矩阵 `mat2` 是稀疏的，而 `mat1` 是密集的怎么办？ 
- 可以通过计数两个矩阵中的非零元素并在乘法之前使用一些检查来处理这种情况
- 但是，这个问题的目的不只是将数学公式转换为代码

算法
- 创建一个函数 `compressMatrix(matrix)`，输入 `matrix` 并返回 `compressedMatrix` 只含有非零元素。为了构建 `compressedMatrix`，迭代 `matrix` 的每个元素，如果元素非零,则将 `(value, col)` 对推入 `compressedMatrix` 的相应 `row` 中
- 初始化一些变量：
  - m， mat1 的行数
  - k， mat1 的列数
  - n， mat2 的列数
  - `matrix1` 和 `matrix2`，用于保存矩阵 `mat1` 和 `mat2` 的数据结构
  - `res`，大小为 `m×n` 的矩阵存储乘法结果
- 对于 `matrix1` 中的每一行，迭代所有其元素，这些代表了 `mat1` 中的非零元素
  - 对于每个元素，得到 `(value, col)` 对，并迭代在 `matrix2` 中的第 `col^th` 行的所有元素，对于每一对元素我们将他们的产品添加到 `res` 的矩阵中
- 返回 `res` 矩阵

```python
class Solution:
    def multiply(self, mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]:
        def compress_matrix(matrix: List[List[int]]) -> List[List[int]]:
            rows, cols = len(matrix), len(matrix[0])
            compressed_matrix = [[] for _ in range(rows)]
            for row in range(rows):
                for col in range(cols):
                    if matrix[row][col]:
                        compressed_matrix[row].append([matrix[row][col], col])
            return compressed_matrix
        
        m = len(mat1)
        k = len(mat1[0])
        n = len(mat2[0])
        
        # 存储每个矩阵的非零值。
        matric1 = compress_matrix(mat1)
        matric2 = compress_matrix(mat2)
        
        res = [[0] * n for _ in range(m)]
        
        for mat1_row in range(m):
            #  迭代 mat1 的所有当前“行”非零元素。
            for element1, mat1_col in matric1[mat1_row]:
                # 将 mat2 中的所有非零元素相乘并相加
                # 其中一行等于 mat1 中当前元素的 col。
                for element2, mat2_col in matric2[mat1_col]:
                    res[mat1_row][mat2_col] += element1 * element2
                    
        return res
```

- 时间复杂度：`O(m⋅k⋅n)`。令 `m` 和 `k` 分别表示 ma`t1` 的行数和列数，令 `k` 和 `n` 分别表示 `mat2` 的行数和列数
  - 迭代矩阵 `mat1` 中所有的非零元素，并对于矩阵 `mat1` 的每个非零元素，迭代矩阵 `mat2` 的一行所有元素
  - 在最坏的情况下，`mat1` 可以拥有 `m⋅k` 个元素并且 `mat2` 的每一行都能有 `n` 个元素
  - 因此，这导致了 `m⋅k⋅n` 的时间复杂度
- 空间复杂度：`O(m⋅k+k⋅n)`
  - 使用一个数据结构（数组的数组）来有效地存储元素的两个矩阵
  - 在最坏的情况下，将存储 `mat1` 的所有 `m⋅k` 个元素和 `mat2` 的所有 `k⋅n` 个元素在我们的数据结构中
  - 使用大小为 `m×n` 的矩阵 `res` 来输出乘积结果，这不包括在辅助空间中