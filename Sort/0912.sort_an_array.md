# 912.排序数组

题目链接：[912.排序数组](https://leetcode.cn/problems/sort-an-array/)

## 题目大意

给你一个整数数组 `nums`，请你将该数组升序排列

你必须在不使用任何内置函数 的情况下解决问题，时间复杂度为 `O(nlog(n))`，且空间复杂度尽可能小

```js
Example 1:
Input: nums = [5,2,3,1]
Output: [1,2,3,5]
Explanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).

Example 2:
Input: nums = [5,1,1,2,0,0]
Output: [0,0,1,1,2,5]
Explanation: Note that the values of nums are not necessairly unique.
```

限制：
- 1 <= nums.length <= 5 * 10^4
- -5 * 10^4 <= nums[i] <= 5 * 10^4

## 解题

### 思路 1: 快速排序

快速排序的主要思想是通过划分将待排序的序列分成前后两部分，其中前一部分的数据都比后一部分的数据要小，然后再递归调用函数对两部分的序列分别进行快速排序，以此使整个序列达到有序

问题：元素都相同时，`QuickSort` 退化

假设数组是：`nums = [2, 2, 2, 2, 2, 2, ..., 2]`
- 这里使用了随机选取主元的 `QuickSort`：`i = random.randint(left, right)`
- 虽然看似“随机”，但由于所有元素相等，即使随机选哪个值作为 `pivot`，`partition` 时每次都会把几乎所有元素划分到同一个子数组中（即每次 `partition` 结果都是：一边有 `n-1` 个数，一边空），不能有效减半分治，最终递归深度接近 `n`
- 每次 `partition` 要扫描整个子数组，最坏情况下总体复杂度变为 `O(n²)`

```js
// 写法 1
var sortArray = function(nums) {
    randomizedQuicksort(nums, 0, nums.length - 1);
    return nums;
};

var randomizedQuicksort = function(nums, left, right) {
    if (left < right) {
        let pos = randomizedPartition(nums, left, right);
        randomizedQuicksort(nums, left, pos - 1);
        randomizedQuicksort(nums, pos + 1, right);
    }
};

var randomizedPartition = function(nums, left, right) {
    let i = Math.floor(Math.random() * (right - left + 1)) + left; // 随机选一个作为 pivot
    swap(nums, right, i);
    return partition(nums, left, right);
};

var partition = function(nums, left, right) {
    let pivot = nums[right];
    let i = left - 1;
    for (let j = left; j <= right - 1; j++) {
        if (nums[j] <= pivot) {
            i++;
            swap(nums, i, j);
        }
    }
    swap(nums, i + 1, right);
    return i + 1;
};

var swap = function(nums, i, j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
};

// 写法 2
var sortArray = function(nums) {
    const quicksort = (left, right) => {
        if (left >= right) return;

        // 随机选择 pivot
        let pivotIndex = Math.floor(Math.random() * (right - left + 1)) + left;
        [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]];
        let pivot = nums[right];

        // 分区操作
        let i = left;
        for (let j = left; j < right; j++) {
            if (nums[j] < pivot) {
                [nums[i], nums[j]] = [nums[j], nums[i]];
                i++;
            }
        }
        [nums[i], nums[right]] = [nums[right], nums[i]];

        // 递归排序左右两侧
        quicksort(left, i - 1);
        quicksort(i + 1, right);
    };

    quicksort(0, nums.length - 1);
    return nums;
};
```
```python
# 写法 1
# 提交超时
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.randomizedQuicksort(nums, 0, len(nums) - 1)
        return nums

    def randomizedQuicksort(self, nums, left, right):
        if left < right:
            pos = self.randomizedPartition(nums, left, right)
            self.randomizedQuicksort(nums, left, pos - 1)
            self.randomizedQuicksort(nums, pos + 1, right)
    
    def randomizedPartition(self, nums, left, right):
        i = random.randint(left, right) 
        self.swap(nums, right, i)
        return self.partition(nums, left, right)
    
    def partition(self, nums, left, right):
        pivot = nums[right]
        i = left - 1
        for j in range(left, right):
            if nums[j] <= pivot:
                i += 1
                self.swap(nums, i, j)

        self.swap(nums, i + 1, right)
        return i + 1
    
    def swap(self, nums, i, j):
        nums[i], nums[j] = nums[j], nums[i]


# 写法 2
# 也会超时
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        def quicksort(left, right):
            if left >= right:
                return
            
            pivot_index = random.randint(left, right)
            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]
            pivot = nums[right]

            i = left
            for j in range(left, right):
                if nums[j] < pivot:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1

            nums[i], nums[right] = nums[right], nums[i]
            quicksort(left, i - 1)
            quicksort(i + 1, right)
            
        quicksort(0, len(nums) - 1)
        return nums
```

- 时间复杂度：基于随机选取主元的快速排序时间复杂度为期望 `O(nlogn)`，其中 `n` 为数组的长度
- 空间复杂度：`O(h)`，其中 `h` 为快速排序递归调用的层数。需要额外的 `O(h)` 的递归调用的栈空间，由于划分的结果不同导致了快速排序递归调用的层数也会不同，最坏情况下需 `O(n)` 的空间，最优情况下每次都平衡，此时整个递归树高度为 `logn`，空间复杂度为 `O(logn)`

### 思路 2: 堆排序

堆排序的思想：先将待排序的序列建成`大根堆`，使得每个父节点的元素大于等于它的子节点。此时整个序列最大值即为堆顶元素，将其与末尾元素交换，使末尾元素为最大值，然后再调整堆顶元素使得剩下的 `n−1` 个元素仍为大根堆，再重复执行以上操作即能得到一个有序的序列

堆通常使用`数组`表示，在数组中构建堆的规则（基于`完全二叉树`的性质），对于一个使用 `0-based` 数组表示的堆（即根节点是索引 `0`），对于索引 `i`：
- 左子节点：`2*i + 1`
- 右子节点：`2*i + 2`
- 父节点：`(i - 1) // 2`

如何找到最后一个非叶节点？
- 对于数组长度为 `n` 的堆，叶子节点从索引 `n // 2` 到 `n - 1`
- 因此，最后一个非叶节点的索引是：`(n // 2) - 1`

堆排序主要分两个阶段：
- 建堆（`Build Heap`）：把数组转换成大顶堆（根节点最大）
- 排序（`Heap Sort`）：每次取出最大值放到末尾，堆大小减 `1`，并重新调整堆

> 最优选择之一：堆排序（Heap Sort）
> - 能在最坏情况下保持 O(n log n)
> - 只使用常数空间（就地排序）
> - 在数据重复、正负值混杂情况下表现稳定
> - 可以展示出对堆结构的掌握（面试加分项）

```js
var sortArray = function(nums) {
    heapSort(nums);
    return nums;
};

var heapSort = function(nums) {
    buildMaxHeap(nums); // 1. 构建最大堆
    for (let i = nums.length - 1; i > 0; i--) {
        swap(nums, 0, i); // 2. 交换堆顶元素和当前最后一个元素
        maxHeapify(nums, 0, i); // 3. 重新调整堆
    }
};

var buildMaxHeap = function(nums) {
    // 从最后一个非叶子节点开始构建最大堆
    for (let i = Math.floor(nums.length / 2) - 1; i >= 0; i--) {
        maxHeapify(nums, i, nums.length);
    }
};

var maxHeapify = function(nums, root, heapSize) {
    let largest = root;
    let left = 2 * root + 1;
    let right = 2 * root + 2;

    if (left < heapSize && nums[left] > nums[largest]) {
        largest = left;
    }

    if (right < heapSize && nums[right] > nums[largest]) {
        largest = right;
    }

    if (largest !== root) {
        swap(nums, root, largest);
        maxHeapify(nums, largest, heapSize); // 递归调整子树
    }
};

var swap = function(nums, i, j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
};
``````js
var sortArray = function(nums) {
    heapSort(nums);
    return nums;
};

var heapSort = function(nums) {
    buildMaxHeap(nums); // 1. 构建最大堆
    for (let i = nums.length - 1; i > 0; i--) {
        swap(nums, 0, i); // 2. 交换堆顶元素和当前最后一个元素
        maxHeapify(nums, 0, i); // 3. 重新调整堆
    }
};

var buildMaxHeap = function(nums) {
    // 从最后一个非叶子节点开始构建最大堆
    for (let i = Math.floor(nums.length / 2) - 1; i >= 0; i--) {
        maxHeapify(nums, i, nums.length);
    }
};

var maxHeapify = function(nums, root, heapSize) {
    let largest = root;
    let left = 2 * root + 1;
    let right = 2 * root + 2;

    if (left < heapSize && nums[left] > nums[largest]) {
        largest = left;
    }

    if (right < heapSize && nums[right] > nums[largest]) {
        largest = right;
    }

    if (largest !== root) {
        swap(nums, root, largest);
        maxHeapify(nums, largest, heapSize); // 递归调整子树
    }
};

var swap = function(nums, i, j) {
    [nums[i], nums[j]] = [nums[j], nums[i]];
};
```
```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.heap_sort(nums)
        return nums
    
    # 堆排序算法
    def heap_sort(self, nums: List[int]):
        # 1. 先把整个数组构造成 大顶堆
        self.build_heap(nums) 
        # 2. 交换堆顶元素与数组末尾元素
        # 循环中从后往前遍历，每次把最大值（堆顶）交换到末尾
        for i in range(len(nums) - 1, 0, -1):
            nums[i], nums[0] = nums[0], nums[i]
            # 3. 调整堆
            # 再把剩余数组（0~i-1）重新调整为堆
            self.max_heapify(nums, 0, i) 
    
    # 构建最大堆，从最后一个非叶子节点开始向上调整
    def build_heap(self, heap: List[int]):
        # len(heap) // 2 - 1 是第一个非叶节点索引（因为叶节点不需要处理）
        # 叶子节点不需要 heapify
        # - 在构建堆时，只有非叶子节点才需调用 max_heapify，因为叶子节点本身没有子节点，不可能违反“堆”的性质
        # - 要从最后一个非叶子节点开始向上调整堆结构
        for i in range(len(heap) // 2 - 1, -1, -1):  
            # 每个节点都执行 max_heapify 保证其为堆
            self.max_heapify(heap, i, len(heap))
    
    # 维护最大堆性质，它保证以 root 为根的子树满足大顶堆条件
    # 从根往下遍历，不断将当前节点与其最大子节点交换，直到堆性质恢复
    def max_heapify(self, heap: List[int], root: int, heap_len: int):
        p = root
        # 若左子节点存在
        while p * 2 + 1 < heap_len:
            # 左右子节点索引
            l, r = p * 2 + 1, p * 2 + 2
            # 默认较大的子节点是左子节点
            nex = l 

            # 选较大的子节点
            # 若右子节点存在且更大
            if r < heap_len and heap[r] > heap[l]:
                nex = r
            
            # 如果当前节点小于较大的子节点，则交换
            if heap[p] < heap[nex]:
                heap[p], heap[nex] = heap[nex], heap[p]
                p = nex  # 继续向下调整
            else:
                # 当前已经满足堆性质
                break
```

- 时间复杂度：`O(nlogn)`
  - 初始化建堆的时间复杂度为 `O(n)`，建完堆以后需进行 `n−1` 次调整，一次调整（即 `maxHeapify`） 的时间复杂度为 `O(logn)`，则 `n−1` 次调整即需要 `O(nlogn)` 的时间复杂度
  - 因此，总时间复杂度为 `O(n+nlogn)=O(nlogn)`
- 空间复杂度：`O(1)`，只需要常数的空间存放若干变量

### 思路 3: 归并排序

归并排序是典型的分治法，即：
- 不断将数组从中间分成左右两半，递归处理
- 然后将排好序的左右数组合并成一个整体

优点：
- 时间复杂度永远是 `O(n log n)`（最坏也如此）
- 排序稳定
- 可优化为仅用一个共享辅助数组，避免频繁复制（你当前的版本已做优化）
- 不易受到数据分布影响，适合大数据量场景

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # 创建一个长度相同的辅助数组，避免每次 merge 时重复分配内存
        tmp = [0] * n 
        # 对整个数组进行归并排序
        self.mergeSort(nums, 0, n - 1, tmp)
        # 排序后直接返回原数组（原地修改）
        return nums
    
    # 归并排序主逻辑（分治）
    def mergeSort(self, nums, left, right, tmp):
        # 递归终止条件：当 left >= right，说明区间只有 1 个或 0 个元素，不需排序
        if left >= right:
            return
        
        # 将区间 [left, right] 拆成左右两半：左半部分是 [left, mid]；右半部分是 [mid+1, right]
        mid = (left + right) // 2
        # 分别对左右两半递归归并排序
        self.mergeSort(nums, left, mid, tmp)
        self.mergeSort(nums, mid + 1, right, tmp)
        # 最后使用 merge() 函数合并两个有序部分
        self.merge(nums, left, mid, right, tmp)
    
    # 合并两个有序子数组
    def merge(self, nums, left, mid, right, tmp):
        # 将当前处理区间 [left, right] 的数据复制到辅助数组 tmp 中
        # 这样可以在合并时放心从 tmp 中读、往 nums 中写，避免覆盖
        for i in range(left, right + 1):
            tmp[i] = nums[i]
        
        # 初始化左右指针 i 和 j，分别指向两个有序子数组的起点
        i, j = left, mid + 1 
        # 用 k 表示当前应该写入 nums 的位置
        k = left     

        # 比较左右子数组的当前元素大小，把更小的写入 nums[k]
        # 指针 i/j 和 k 相应地移动
        # 因为 tmp 是辅助数组，nums 是实际排序结果，写入不会覆盖未读取的数据
        while i <= mid and j <= right:
            if tmp[i] <= tmp[j]:
                nums[k] = tmp[i]
                i += 1
            else:
                nums[k] = tmp[j]
                j += 1
            k += 1
        
        # 如果右边先合并完，左边还有剩余，就把剩下的左边元素依次复制过来
        # 右边剩余部分不用处理，因为它们已经在 nums 的正确位置
        while i <= mid:
            nums[k] = tmp[i]
            i += 1
            k += 1
```

- 时间复杂度：`O(n log n)`，稳定，不会退化
- 空间复杂度：`O(n)`，辅助数组