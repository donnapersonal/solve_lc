# 164.最大间距

题目链接：[164.最大间距](https://leetcode.cn/problems/maximum-gap/)

## 题目大意

给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 

您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法

```js
Example 1:
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.

Example 2:
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
```

限制：
- 1 <= nums.length <= 10^5
- 0 <= nums[i] <= 10^9
  
## 解题

暴力思路
- 排序后遍历相邻元素
- 先用 O(n log n) 排序数组，然后计算 nums[i+1] - nums[i]，返回最大值
- 复杂度：O(n log n) 时间，O(1) 或 O(n) 空间（取决于排序方法）
- 缺点：题目要求 时间复杂度优于 O(n log n)，所以这个方法不够优
  
优化思路：桶排序 / 基数排序（Radix Sort）
- 目标：用 线性时间排序
- 因为输入是整数，可以用 基数排序（Radix Sort） 或 桶排序（Bucket Sort）
- 基数排序：
  - 按位（个位、十位、百位…）排序，逐位稳定排序
  - 最终数组有序，计算相邻元素差值即可
- 优势：
  - 时间复杂度接近 O(n)
  - 空间复杂度 O(n)
  - 可处理整数范围较大的情况

### 思路 1: 基数排序

为什么选择基数排序？
- 输入整数可能很大（如 0 ~ 10^9），用桶排序需要确定桶间距和最大值，复杂度略微复杂
- 基数排序按位处理，直接对数组排序，稳定、线性，适合面试

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function(nums) {
    const n = nums.length;
    if (n < 2) {
        return 0;
    }
    let exp = 1;
    const buf = new Array(n).fill(0);
    const maxVal = Math.max(...nums);

    while (maxVal >= exp) {
        const cnt = new Array(10).fill(0);
        for (let i = 0; i < n; i++) {
            let digit = Math.floor(nums[i] / exp) % 10;
            cnt[digit]++;
        }
        for (let i = 1; i < 10; i++) {
            cnt[i] += cnt[i - 1];
        }
        for (let i = n - 1; i >= 0; i--) {
            let digit = Math.floor(nums[i] / exp) % 10;
            buf[cnt[digit] - 1] = nums[i];
            cnt[digit]--;
        }
        nums.splice(0, n, ...buf);
        exp *= 10;
    }
    
    let ret = 0;
    for (let i = 1; i < n; i++) {
        ret = Math.max(ret, nums[i] - nums[i - 1]);
    }
    return ret;
};
```
```python
class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        n = len(nums)
        # 如果元素不足两个，返回 0，因为没有相邻元素
        if n < 2:
            return 0
        
        # exp：当前基数位置（1 = 个位，10 = 十位，100 = 百位…）
        exp = 1  
        # maxVal：数组最大值，用于判断基数排序结束的条件
        maxVal = max(nums)
        # buf：临时数组，存储排序过程中结果
        buf = [0] * n

        # 遍历每一位数，从低位到高位
        # 当当前位超过最大值时，排序结束
        while maxVal >= exp:
            # count 数组统计 每个数字 0~9 出现的次数
            # 对应当前 exp 位上的数字
            count = [0] * 10  

            # 遍历数组每个元素
            for i in range(n):
                # (nums[i] // exp) % 10：取当前位数字
                # count[digit]++：统计当前数字出现次数
                digit = (nums[i] // exp) % 10
                count[digit] += 1
            
            # 将 count 转为 前缀和，用于确定每个数字在输出数组中的位置
            # 核心是保证 排序稳定
            for i in range(1, 10):
                count[i] += count[i - 1]
            
            # 从后往前遍历数组，保证稳定性（同位数字顺序不变）
            # buf[count[digit]-1] = nums[i]：将数字放到正确位置
            # count[digit] -= 1：下一个相同数字放置位置向前移动
            for i in range(n - 1, -1, -1):
                digit = (nums[i] // exp) % 10
                buf[count[digit] - 1] = nums[i]
                count[digit] -= 1
            
            # 将 buf 排序结果写回 nums
            # 下一轮基数排序继续在 nums 上操作
            nums[:] = buf[:]
            # 移动到下一位（个位 → 十位 → 百位 ……）
            exp *= 10
        
        # 数组排序完成后，计算 相邻元素差值
        # 返回最大差值
        res = 0
        for i in range(1, n):
            res = max(res, nums[i] - nums[i - 1])
        
        # 返回最终答案
        return res
```

- 时间复杂度：`O(n)`，其中 `n` 是数组的长度
- 空间复杂度：`O(n)`，其中 `n` 是数组的长度

### 思路 2: 桶排序

```python
class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        n = len(nums)
        min_num = min(nums)
        max_num = max(nums)
        if n < 2:
            return 0

        if max_num - min_num <= 1:
            return max_num - min_num

        res = d = (max_num - min_num + n - 2) // (n - 1)  
        buckets = [[inf, -inf] for _ in range((max_num - min_num) // d + 1)]
        for x in nums:
            b = buckets[(x - min_num) // d]
            b[0] = min(b[0], x)  
            b[1] = max(b[1], x)

        pre_max = inf
        for mn, mx in buckets:
            if mn != inf:  
                res = max(res, mn - pre_max)
                pre_max = mx

        return res
```

- 时间复杂度：`O(n)`，其中 `n` 为 `nums` 的长度
- 空间复杂度：`O(n)`

