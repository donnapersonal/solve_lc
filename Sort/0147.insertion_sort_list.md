# 147.对链表进行插入排序

题目链接：[147.对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

## 题目大意

给定单个链表的头 `head`，使用 插入排序 对链表进行排序，并返回 排序后链表的头 

插入排序 算法的步骤:
- 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表
- 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入
- 重复直到所有输入数据插入完为止
  
对链表进行插入排序。

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1zifh0rkqa.webp)

限制：
- The number of nodes in the list is in the range [1, 5000].
- -5000 <= Node.val <= 5000

## 解题

初始想法：用数组辅助排序（不推荐）
- 遍历链表，将节点值保存到数组中
- 对数组进行排序
- 构建一个新的排序链表
- 问题：这会使用额外空间 `O(n)`，不满足题目对“链表插入排序”的原意，也不是真正对链表结构进行操作

正确思路：模拟插入排序过程，原地操作链表 - 我们要对链表本身做插入排序，不能借助额外数组
- 维护一个已排序的链表部分（从头开始），每次从未排序部分拿出一个节点 `cur`
- 如果当前节点比已排序的最后一个节点大，说明它已经在正确位置了，直接继续
- 如果当前节点比已排序的部分中某些节点小，就从头找到它应该插入的位置，并插入
- 这里用一个 `dummy` 头节点辅助操作，便于在头部插入新节点

```js
var insertionSortList = function(head) {

    if (head === null) return head;
    const dummy = new ListNode(0);
    dummy.next = head;
    let lastSorted = head, cur = head.next;
    while (cur) {
        if (lastSorted.val <= cur.val) {
            lastSorted = lastSorted.next;
        } else {
            let prev = dummy;
            while (prev.next.val <= cur.val) {
                prev = prev.next;
            }
            lastSorted.next = cur.next;
            cur.next = prev.next;
            prev.next = cur;
        }
        cur = lastSorted.next;
    }
    return dummy.next;
};
```
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 边界处理：空链表直接返回
        if not head:
            return head
        
        # 创建哑节点 dummy，指向排序链表的头部，便于插入操作（尤其是头部插入）
        dummy = ListNode(0)
        dummy.next = head
        # lastSorted 表示当前已排序部分的最后一个节点
        lastSorted = head
        # cur 是当前待插入的节点（即未排序的第一个节点）
        cur = head.next

        # 开始遍历未排序部分
        while cur:
            # 如果当前节点值 >= 已排序最后一个节点值，说明它已经在正确位置，无需移动
            if lastSorted.val <= cur.val:
                lastSorted = lastSorted.next
            else:
                # 否则，cur 需要插入到前面的某个位置
                # 从 dummy 开始遍历已排序部分，找插入点
                prev = dummy
                while prev.next.val <= cur.val:
                    prev = prev.next
                
                # 断开并重新链接节点：将 lastSorted 的 next 指向 cur 的 next（即跳过 cur）
                lastSorted.next = cur.next
                # 将 cur 插入到 prev 和 prev.next 之间
                cur.next = prev.next
                prev.next = cur
            # 更新 cur，指向新的未排序部分的第一个节点（lastSorted.next）
            cur = lastSorted.next
        
        # 返回排序后的链表（dummy.next 是真实头节点）
        return dummy.next
```

- 时间复杂度：`O(n^2)`，其中 `n` 是链表的长度，每个节点在最坏情况下都需要向前查找插入位置
- 空间复杂度：`O(1)`，只使用了常数指针