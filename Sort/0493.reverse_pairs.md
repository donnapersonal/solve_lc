# 493.翻转对

题目链接：[493.翻转对](https://leetcode.cn/problems/reverse-pairs/)

## 题目大意

给定一个数组 `nums`，如果 `i < j` 且 `nums[i] > 2 * nums[j]` 我们就将 `(i, j)` 称作一个重要翻转对

需要返回给定数组中的重要翻转对的数量

```js
Example 1:
Input: nums = [1,3,2,3,1]
Output: 2
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1

Example 2:
Input: nums = [2,4,3,5,1]
Output: 3
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1
(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1
```

限制：
- 1 <= nums.length <= 5 * 10^4
- -2^31 <= nums[i] <= 2^31 - 1

## 解题

暴力解法：枚举所有对
- 最直接的方法是双层循环：
  ```python
  for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if nums[i] > 2 * nums[j]:
            count += 1
  ```
- 时间复杂度：`O(n²)`
- 在大数据量下会超时

最优解法：`归并排序 + 统计逆序对变形`
- 将 `nums[i] > 2 * nums[j] 且 i < j` 抽象为：`区间左边的值大于右边一半`的问题，可以在归并排序的过程中统计这种跨越两个子数组的反转对

> 为什么使用归并排序：
> - 归并排序天然是「分治」+「有序合并」，适合在合并过程中统计跨区间的逆序对
> - 在排序过程中可以做到：
>   - 一边排序
>   - 一边统计符合条件的反转对

核心流程：
- 递归拆分数组：分成左右两个部分
- 统计跨越左右边界的逆序对：当左边的 `i` 与右边的 `j` 满足 `nums[i] > 2 * nums[j]`
- 归并两个有序数组：保持数组有序，为后续统计提供基础

关键点：由于归并排序左右部分都是已经排好序的，所以可以用双指针一次遍历，统计每个 `i` 对应多少个 `j` 满足条件

```js
var reversePairs = function(nums) {
    const mergeSort = (start, end) => {
        if (start >= end) return 0;
        let mid = Math.floor((start + end) / 2);
        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);

        // Count reverse pairs
        let j = mid + 1;
        for (let i = start; i <= mid; i++) {
            while (j <= end && nums[i] > 2 * nums[j]) {
                j++;
            }
            count += j - (mid + 1);
        }

        // Merge step
        let temp = [];
        let i = start;
        j = mid + 1;
        while (i <= mid && j <= end) {
            if (nums[i] <= nums[j]) {
                temp.push(nums[i++]);
            } else {
                temp.push(nums[j++]);
            }
        }
        while (i <= mid) temp.push(nums[i++]);
        while (j <= end) temp.push(nums[j++]);

        // Copy sorted temp back into nums
        for (let k = 0; k < temp.length; k++) {
            nums[start + k] = temp[k];
        }

        return count;
    };

    return mergeSort(0, nums.length - 1);
};
```
```python
class Solution:
    def reversePairs(self, nums: List[int]) -> int:
        def merge_sort(start, end):
            # 递归终止条件：当区间只剩一个或零个元素时，直接返回 0
            # 因为没有可能形成反转对
            if start >= end:
                return 0
            
            # 将数组分为左右两个区间 [start, mid] 和   `[mid+1, end]
            mid = (start + end) // 2
            # 分别递归处理左右部分，并累加左右子问题的反转对数
            count = merge_sort(start, mid) + merge_sort(mid + 1, end)

            # 关键逻辑：在合并前统计「跨区间」的反转对
            # 对于每个 i ∈ [start, mid]，我们寻找最小的 j ∈ [mid+1, end]，使得：nums[i] <= 2 * nums[j] → 不满足题意，所以之前的所有 j（从 mid+1 到当前 j-1）都满足 nums[i] > 2 * nums[j]
            j = mid + 1
            for i in range(start, mid + 1):
                while j <= end and nums[i] > 2 * nums[j]:
                    j += 1
                
                # i 从左半边依次遍历 [start, mid]，j 从右半边开始，找出所有满足 nums[i] > 2 * nums[j] 的 j
                # 注意：j 不需回退，因为左右两边是有序的，之后的 i 肯定不会小于当前的 j
                # 设 j 最终停在了 right + 1 或某个位置：[mid+1, j-1] 这段区间中的每一个 nums[j'] 都满足 nums[i] > 2 * nums[j']
                # 因为是从 mid+1 开始数的，所以这段区间长度就是：j - (mid + 1)
                # 这就表示：对于当前的 i，我们找到了 j - (mid + 1) 个合法的 j
                count += j - (mid + 1)
            
            # 正常的归并排序 merge 过程：将两个有序数组合并为一个有序数组
            temp = []
            i, j = start, mid + 1
            while i <= mid and j <= end:
                # nums[i] <= nums[j]：说明左边更小，先放入 temp
                if nums[i] <= nums[j]:
                    temp.append(nums[i])
                    i += 1
                else:
                    # 否则右边更小，放入 temp
                    temp.append(nums[j])
                    j += 1
                # temp 最终是 [start, end] 区间排序后的结果
            
            # 把剩余的左半部分或右半部分补上（因为另一边已合并完）
            while i <= mid:
                temp.append(nums[i])
                i += 1

            while j <= end:
                temp.append(nums[j])
                j += 1
            
            # 将 [start, end] 区间替换为排序后的结果
            nums[start:end + 1] = temp
            # 返回当前区间的反转对数量
            return count
        
        # 从整个数组区间 [0, n-1] 开始归并排序+统计反转对
        return merge_sort(0, len(nums) - 1)
```

- 时间复杂度：`O(nlogn)`，其中 `n` 为数组的长度
- 空间复杂度：`O(n)`，其中 `n` 为数组的长度