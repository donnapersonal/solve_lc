# 252.会议室

题目链接：[252.会议室](https://leetcode.cn/problems/meeting-rooms/)

## 题目大意

给定一个会议时间安排的数组 `intervals`，每个会议时间都会包括开始和结束的时间 `intervals[i] = [start_i, end_i]`，请判断一个人是否能够参加这里面的全部会议

```js
Example 1：
Input：intervals = [[0,30],[5,10],[15,20]]
Output：false

Example 2：
Input：intervals = [[7,10],[2,4]]
Output：true
```

限制：
- 0 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti < endi <= 10^6

## 解题

最直观的思路是：检查每两个会议是否重叠，即两两比较

```python
for i in range(n):
    for j in range(i+1, n):
        if intervals[i][0] < intervals[j][1] and intervals[j][0] < intervals[i][1]:
            return False
```

- 缺点：
  - 时间复杂度是 `O(n^2)`，当会议数量大时效率很差
  - 实际面试中大概率被指出“优化空间大”

最优解思路（排序 + 一次遍历）
- 观察本质：两个会议不能重叠 → 即当前会议的 `start` 不能小于前一个会议的 `end`
- 我们将所有会议按照起始时间升序排序，然后只需比较相邻的会议，就能判断是否有重叠

为什么能比较相邻会议就行？
- 因为排好序后，若有重叠，一定发生在当前会议与前一个会议之间
- 若它们不重叠，后面的会议也不会跟前一个会议重叠

```js
var canAttendMeetings = function(intervals) {
    // 按照会议的开始时间排序
    intervals.sort((a, b) => a[0] - b[0]);
    let len = intervals.length;
    for (let i = 1; i < len; i++) {
        if (intervals[i][0] < intervals[i - 1][1]) {
            return false;
        }
    }
    return true;
};
```
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        # 将所有会议按照开始时间从小到大排序
        # lambda x: x[0] 表示按每个会议的开始时间作为排序关键字
        intervals.sort(key=lambda x: x[0])
        n = len(intervals)
        # 从第 2 个会议开始遍历（因为我们要比较当前会议和上一个会议）
        for i in range(1, n):
            # 判断当前会议的开始时间是否早于前一个会议的结束时间，如果是，则说明会议有重叠
            if intervals[i][0] < intervals[i-1][1]:
                # 有冲突，立即返回 False，表示不能参加所有会
                return False
        
        # 若没有发现任何重叠，返回 True，表示可以参加所有会议
        return True
```

- 时间复杂度：`O(nlogn)`
- 空间复杂度：
  - 若忽略排序算法的内部实现（即假设为原地排序，如堆排序），其空间复杂度可以视为 `O(1)`
  - 若考虑排序的实际实现，特别是基于 `Timsort` 的实现，其空间复杂度可以是 `O(n)`