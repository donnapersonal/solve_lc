# 179.最大数

题目链接：[179.最大数](https://leetcode.cn/problems/largest-number/)

## 题目大意

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数

```js
Example 1:
Input: nums = [10,2]
Output: "210"

Example 2:
Input: nums = [3,30,34,5,9]
Output: "9534330"
```

限制：
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 10^9

## 解题

初始错思路：直接按数值大小排序

```python
nums = [3, 30, 34, 5, 9]
排序结果：9, 5, 34, 30, 3
结果拼接："9534303"
```
- 但这并不是最大的数，如 `30` 和 `3` 排序顺序很关键：`330 > 303`，所以 `3` 应该在 `30` 前面
- 这说明：不能只按数值大小排序，需考虑两个数字拼接起来的大小顺序

正确思路：自定义比较规则进行排序
- 对于任意两个数字 `x` 和 `y`，比较：`x + y` 和 `y + x` 的大小
  - 如果 `x + y > y + x`，则 `x` 应排在 `y` 前面
  - 否则相反

例如比较 `3` 和 `30`：
- `330 > 303` ⇒ `3` 在前

使用这个规则对所有数字进行排序后，拼接结果即为最大数

> `cmp_to_key()` 的工作方式遵循 “三值比较函数”的传统标准：
> compare(x, y) 返回：
> - `-1 → x < y → x` 排在 `y` 前
> - `0 → x == y`
> - `1 → x > y → x` 排在 `y` 后
> 这是 `Python` 对比较函数的约定（和 `C++`、`Java` 类似）：所以必须返回 `-1、0、1` 这样的比较结果值
>
> 从功能上来说，在 `Python` 的 `cmp_to_key()` 中，只要返回值的正负号正确就行
> - `return -100` 和 `return -1` 效果是一样的，都会让 `x` 排在 `y` 前
> - `return 100` 和 `return 1` 一样，表示 `x` 排在 `y` 后
> 但是：建议始终使用标准返回值 `-1/0/1`
>
> 原因：
> - 可读性：更容易让人理解你用的是比较函数约定
> - 兼容性：虽然 Python 不强制必须是 -1/0/1，但很多系统内部依赖这一约定
> - 实测中：`sort()+cmp_to_key()` 在一些 `edge case` 或兼容老版本时更稳妥

```js
// 写法 1
var largestNumber = function(nums) {
    nums.sort((x, y) => {
        let sx = 10, sy = 10;
        while (sx <= x) {
            sx *= 10;
        }
        while (sy <= y) {
            sy *= 10;
        }
        return '' + (sx * y + x) - ('' + (sy * x + y));
    })
    if (nums[0] === 0) return '0';
    return nums.join('');
};

// 写法 2
var largestNumber = function(nums) {
    nums = nums.map(String);
    nums.sort((a, b) => (b + a) - (a + b));
    let res = nums.join('');
    return res[0] === '0' ? '0' : res;
};
```
```python
# 写法 1
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        # 自定义排序规则，使用字符串拼接
        # 这里的 x 和 y 是字符串，如 "3" 和 "30"
        # 比较拼接结果 x + y 和 y + x 的字典序（因为数越大，拼接值越大）
        # 比较 x + y 和 y + x："330" > "303" → 3 应该排在 30 前面
        def compare(x, y):
            if x + y > y + x:
                # x 应该排在 y 前面
                return -1
            elif x + y < y + x:
                # y 应该排在 x 前面
                return 1 
            else:
                # 相等
                return 0
        
        # 将整数数组转换成字符串数组，因为需进行字符串拼接比较，如比较 "3" + "30" 和 "30" + "3"
        # map(str, nums)：将所有整数转换为字符串
        nums = list(map(str, nums))

        # 使用 Python 的内置 sort 方法 + cmp_to_key 工具，将自定义的比较函数 compare 转换为排序键
        # 按照设定的拼接规则从大到小排序
        nums.sort(key=cmp_to_key(compare))  

        # 特殊处理：处理全 0 的特殊情况
        # 若排序后最大数字是 "0"（即所有数字都是 0），应返回 "0" 而非 "0000..."
        if nums[0] == "0":
            return "0"
        
        return "".join(nums)

# 写法 2
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def compare(x, y): 
            # 如果 x+y < y+x，交换顺序
            return 1 if x + y < y + x else -1 
        
        # 转换为字符串并排序
        nums = list(map(str, nums))
        # 自定义排序
        nums.sort(key=cmp_to_key(compare))
        # 拼接结果并去除前导 0
        res = ''.join(nums)
        # 处理 "000" 变成 "0"
        return '0' if res[0] == '0' else res 
```

- 时间复杂度：`O(nlogn * logm)`
  - `O(n log n)` 来自排序，`O(log m)` 来自字符串比较（`x + y` 和 `y + x` 是两个字符串，最长的长度为 `O(log m)`（其中 `m` 是 3`2` 位整数的最大值 `10^9`，`log(10^9) ≈ 10`）
  - 如果优化比较函数，可降至 `O(n log n)`，但会增加 `O(n)` 额外空间
- 空间复杂度：`O(nlogm)+O(logn) ≈ O(nlogm)`
  - `O(n log m)` 来自存储 `n` 个字符串
  - `O(log n)` 来自排序的递归调用栈空间