# 148.排序链表

题目链接：[148.排序链表](https://leetcode.cn/problems/sort-list/)

## 题目大意

给你链表的头结点 `head`，请将其按`升序`排列并返回排序后的链表 

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.361vm7m7xu.webp)

限制：
- The number of nodes in the list is in the range [0, 5 * 10^4].
- -10^5 <= Node.val <= 10^5

## 解题

```js
var sortList = function(head) {
    if (!head || !head.next) return head;
    // Step 1: Split the list into two halves using fast and slow pointers
    let slow = head, fast = head.next;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    let mid = slow.next;
    slow.next = null;  // Break the list into two halves
    // Step 2: Recursively sort each half
    let left = sortList(head);
    let right = sortList(mid);
    // Step 3: Merge the two sorted halves
    return merge(left, right);
};

var merge = function(l1, l2) {
    let dummy = new ListNode(0);
    let cur = dummy;
    // Merge two sorted lists
    while (l1 && l2) {
        if (l1.val < l2.val) {
            cur.next = l1;
            l1 = l1.next;
        } else {
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }

    // Attach the remaining part
    if (l1) cur.next = l1;
    if (l2) cur.next = l2;

    return dummy.next;
};
```
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        mid = slow.next
        slow.next = None
        left = self.sortList(head)
        right = self.sortList(mid)
        return self.merge(left, right)
    
    def merge(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        cur = dummy
        while l1 and l2:
            if l1.val < l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        
        return dummy.next
```

- 时间复杂度：`O(n log n)`
  - 使用归并排序算法
  - 每一层的合并操作需要 `O(n)` 时间
  - 总共有 `log n` 层（因为每次都将链表分成两半）
  - 因此总时间复杂度为 `O(n log n)`
- 空间复杂度：`O(log n)`
  - 递归调用栈的深度为 `log n`
  - 虽然在合并过程中只需要常数额外空间
  - 但递归调用会使用系统栈空间，深度为 `log n`