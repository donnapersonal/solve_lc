# 315.计算右侧小于当前元素的个数

题目链接：[315.计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

## 题目大意

给你一个整数数组 `nums`，按要求返回一个新数组 `counts`。数组 `counts` 有该性质：`counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量

```js
Example 1:
Input: nums = [5,2,6,1]
Output: [2,1,1,0]
Explanation:
To the right of 5 there are 2 smaller elements (2 and 1).
To the right of 2 there is only 1 smaller element (1).
To the right of 6 there is 1 smaller element (1).
To the right of 1 there is 0 smaller element.

Example 2:
Input: nums = [-1]
Output: [0]

Example 3:
Input: nums = [-1,-1]
Output: [0,0]
```

限制：
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4

## 解题

暴力解法：
- 对于每个元素 `nums[i]`，向后遍历 `nums[i+1:]`，统计比它小的数
  ```python
  res = []
  for i in range(len(nums)):
      count = 0
      for j in range(i+1, len(nums)):
          if nums[j] < nums[i]:
              count += 1
      res.append(count)
  ```
- 缺点：
  - 时间复杂度为 `O(n^2`，当数组较大时会超时
  - 无法通过面试中的大规模测试用例
  
最优解：`归并排序 + 索引追踪`（O(n log n)）`
- 核心思想：在归并排序的过程中，统计右边比当前元素小的数量

技巧：
- 使用 `enumerate` 对元素加上索引，把原数组用 `(index, value)` 形式保存，排序过程中保留索引，以便追踪原始位置
- 归并时，当`左边元素 <= 右边元素`时，右边已有的 `j` 个元素比它小，累加到其索引对应的 `res[i]` 中

本质类似 `“逆序对统计”` 的变种

```js
var countSmaller = function(nums) {
    const n = nums.length;
    const res = new Array(n).fill(0);
    const enumNums = nums.map((val, idx) => [val, idx]);

    const mergeSort = (arr) => {
        if (arr.length <= 1) return arr;
        const mid = Math.floor(arr.length / 2);
        const left = mergeSort(arr.slice(0, mid));
        const right = mergeSort(arr.slice(mid));
        const merged = [];
        let i = 0, j = 0;
        while (i < left.length || j < right.length) {
            if (j === right.length || (i < left.length && left[i][0] <= right[j][0])) {
                res[left[i][1]] += j;
                merged.push(left[i]);
                i++;
            } else {
                merged.push(right[j]);
                j++;
            }
        }
        return merged;
    };

    mergeSort(enumNums);
    return res;
};
```
```python
# 写法 1
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        n = len(nums)
        # res：结果数组，初始化为全 0，后续将逐步填入每个位置的结果
        # res[i] 表示 nums[i] 右边比它小的数的个数
        res = [0] * n  
        # 将 nums 编号：[(0, 5), (1, 2), (2, 6), (3, 1)]
        # 每个元素是 (原始索引, 数值)，用于排序后还能找回其在 res 中对应的位置
        enum = list(enumerate(nums)) 

        # 定义归并排序函数，对包含 (index, value) 的数组进行排序，同时在排序过程中计算逆序个数
        def merge_sort(arr):
            n = len(arr)
            # 递归终止条件：长度为 0 或 1 的数组不需要排序，直接返回
            if n <= 1:
                return arr
            
            # 将数组一分为二，对每部分分别归并排序
            mid = n // 2
            left = merge_sort(arr[:mid])
            right = merge_sort(arr[mid:])
            # 初始化合并结果数组 merged
            # i、j 分别是左右两个数组的指针
            merged = []
            i = j = 0
            # 进入合并排序循环，直到两个子数组都处理完
            while i < len(left) or j < len(right):
                # 如果右边用完了，或者左边元素小于等于右边当前值，则合并左边的元素（左边这个元素要放进 merged 数组（标准归并排序逻辑））
                # 说明左边的这个数比当前右边的所有 j 个数都大或相等 ⇒ 这些 j 个数就是它右边比它小的个数
                if j == len(right) or (i < len(left) and left[i][1] <= right[j][1]):
                    # j 是已经从右边合并到 merged 中的元素个数
                    # 这些元素一定是比 left[i] 小的（因为此时是按从小到大合并的）
                    # 所以可以对 left[i] 对应的原始位置，加上这些小的右边元素数量
                    # left[i][0] 是原始索引

                    # 当我们正在合并左边的元素 left[i]，此时右边已经有 j 个更小的元素放进了结果，它们都是 left[i] 右边且小于它的数 ⇒ 所以 res[left[i][0]] += j
                    res[left[i][0]] += j 
                    # 将左边当前元素合入结果，并移动指针
                    merged.append(left[i])
                    i += 1
                else:
                    # 若右边元素更小或相等，将其合并进结果，j++
                    # 不更新任何 res 值，因为右边元素不会被左边的人“统计”
                    merged.append(right[j])
                    j += 1
            
            # 返回当前合并后的有序列表，供上层使用
            return merged
        
        # 初始调用归并排序函数
        merge_sort(enum)
        return res

# 写法 2
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        n = len(nums)
        index = list(range(n))  
        temp = [0] * n          
        tempIndex = [0] * n    
        res = [0] * n        

        def merge_sort(a, l, r):
            if l >= r:
                return
            mid = (l + r) // 2
            merge_sort(a, l, mid)
            merge_sort(a, mid + 1, r)
            merge(a, l, mid, r)

        def merge(a, l, mid, r):
            i, j, p = l, mid + 1, l
            while i <= mid and j <= r:
                if a[i] <= a[j]:
                    temp[p] = a[i]
                    tempIndex[p] = index[i]
                    res[index[i]] += (j - mid - 1)
                    i += 1
                else:
                    temp[p] = a[j]
                    tempIndex[p] = index[j]
                    j += 1
                p += 1

            while i <= mid:
                temp[p] = a[i]
                tempIndex[p] = index[i]
                res[index[i]] += (j - mid - 1)
                i += 1
                p += 1

            while j <= r:
                temp[p] = a[j]
                tempIndex[p] = index[j]
                j += 1
                p += 1

            for k in range(l, r + 1):
                a[k] = temp[k]
                index[k] = tempIndex[k]

        merge_sort(nums, 0, n - 1)
        return res
```

- 时间复杂度：`O(nlogn)`，即归并排序的时间复杂度
- 空间复杂度：`O(n)`，这里归并排序的临时数组、下标映射数组以及答案数组的空间代价均为 `O(n)`