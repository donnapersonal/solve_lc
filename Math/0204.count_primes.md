# 204.计数质数

题目链接：[204.计数质数](https://leetcode.cn/problems/count-primes/)

## 题目大意

给定整数 `n`，返回所有小于非负整数 `n` 的质数的数量 

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

```js
Example 1:
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.

Example 2:
Input: n = 0
Output: 0

Example 3:
Input: n = 1
Output: 0
```

限制：
- 0 <= n <= 5 * 10^6

## 解题

直观的思路是枚举每个数判断其是不是质数

考虑质数的定义：在大于 `1` 的自然数中，除了 `1` 和它本身以外不再有其他因数的自然数
- 因此对于每个数 `x`，可以从小到大枚举 `[2, x−1]` 中的每个数 `y`，判断 `y` 是否为 `x` 的因数
- 但这样判断一个数是否为质数的时间复杂度最差情况下会到 `O(n)`，无法通过所有测试数据

考虑到如果 `y` 是 `x` 的因数，那么 `y/x` 也必然是 `x` 的因数，因此只要校验 `y` 或 `y/x` 即可。而如果每次选择校验两者中的较小数，则不难发现较小数一定落在 `[2, √x]` 的区间中，因此只需枚举 `[2, √x]` 中的所有数即可

> 超出时间限制

```python
class Solution:
    def countPrimes(self, n: int) -> int:
        res = 0

        # 遍历区间 [2, n)，因为 0 和 1 不是质数
        for i in range(2, n):
            # 对每个数 i 调用 self.isPrime(i)
            # 若返回 True，说明 i 是质数，累加计数器
            if self.isPrime(i):
                res += 1

        return res
    
    # 质数的判断规则：如果 x 存在除了 1 和自身以外的因数，则不是质数
    def isPrime(self, x):
        # 遍历从 2 到 √x：
        # - 为什么到 √x？因为如果 x 有因数，必定在 √x 之前就会出现成对因数
        for i in range(2, int(x**0.5) + 1):
            # 如果在循环中找到能整除 x 的数，立即返回 False
            if x % i == 0:
                return False
      
        # 如果循环结束没有找到因数，则返回 True，说明 x 是质数
        return True
```

- 时间复杂度：`O(n√n)`。单个数检查的时间复杂度为 `O(√n)`，一共要检查 `O(n)` 个数，因此总时间复杂度为 `O(n√n)`
- 空间复杂度：`O(1)`

### 思路 1: 埃拉托色尼筛法（埃氏筛）

计算质数时，有一个著名算法：`埃拉托斯特尼筛法 (Sieve of Eratosthenes)`（经典算法，适用于快速筛选出一段区间内的所有质数）

思路：从 `2` 开始，将每个质数的倍数标记为非质数，剩下的未标记的就是质数

埃氏筛优化
- 创建一个布尔数组 `isPrime`，长度为 `n`，初始都标记为 `True`（假设都是质数）
- 从 `2` 开始往后：
  - 如果 `isPrime[i]` 为 `True`，说明 `i` 是质数，计数 `+1`
  - 然后把 `i` 的倍数都标记为 `False`（因为它们一定不是质数）`
- 为什么从 `i*i` 开始标记？
  - 因为小于 `i*i` 的倍数，在之前的筛选过程中已经被更小的质数标记过了
  - 从 `i*i` 开始，可以减少冗余操作

```js
var countPrimes = function(n) {
    if (n < 2) return 0;

    let isPrime = new Array(n).fill(true);
    isPrime[0] = isPrime[1] = false;

    for (let i = 2; i * i < n; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }

    return isPrime.filter(Boolean).length;
};
```
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        # 小于 2 没有质数，直接返回 0
        if n < 2:
            return 0
        
        # 创建布尔数组 isPrime，大小为 n，每个元素初始化为 True
        # isPrime[i] = True 表示 i 目前被认为是质数
        isPrime = [True] * n
        # 初始化计数器 res，用来统计质数数量
        res = 0
        # 遍历从 2 到 n-1 的每个数 i
        # 因为我们只统计小于 n 的质数
        for i in range(2, n):
            # 如果 i 当前仍然标记为 True，说明 i 是质数
            if isPrime[i]:
                # 发现一个质数，计数器加 1
                res += 1
                # 从 i*i 开始，以步长 i 标记 j：
                # - isPrime[j] = False 表示 j 不是质数
                # 为何从 i*i 开始？因为 i*(i-1)、i*(i-2) … 这些更小的倍数早已在之前的循环中被标记过
                for j in range(i * i, n, i):
                    isPrime[j] = False

        # 循环结束后，res 中保存了小于 n 的质数个数，返回结果
        return res

# 写法 2
class Solution:
    def countPrimes(self, n: int) -> int:
        if n < 2:
            return 0

        isPrime = [True] * n
        isPrime[0] = isPrime[1] = False

        # 外层循环：遍历从 2 到 √n
        # 为什么只遍历到 √n？因为对于合数来说，最小的质因数不会超过它的平方根，超过的部分已经被之前的质数筛掉
        for i in range(2, int(n**0.5) + 1):
            # 如果当前数 i 仍是质数（isPrime[i] == True），就将它的所有倍数标记为非质数（False
            if isPrime[i]:
                # 从 i * i 开始标记：因为小于 i * i 的倍数已经被更小的质数标记过了，避免重复操作
                # 举例：当 i = 3 时，3 * 2 = 6 已经被 i = 2 标记过了
                for j in range(i * i, n, i):
                    isPrime[j] = False
        
        # 最终统计数组中 True 的数量，即质数的个数
        return sum(isPrime)
```

- 时间复杂度：`O(nloglogn)`
  - 本质上是要求解 `∑_p n/p` 的和，其中 `p` 为质数
  - 可以了解这个算法一个比较松的上界 `O(nlogn)` 怎么计算，这个等价于考虑 `∑_i=1^n n/i` 的和，而 `O(∑_i=1^n n/i) = O(n∑_i=1^n 1/i)`，而 `1` 到 `n` 中所有数的倒数和趋近于 `logn`，因此 `O(n∑_i=1^n 1/i)=O(nlogn)`
- 空间复杂度：`O(n)`，需 `O(n)` 的空间记录每个数是否为质数

### 思路 2: 欧拉筛法（线性筛）

埃氏筛存在冗余标记
- 埃氏筛中，一个合数可能会被多个质数重复标记，如 `30` 会被 `2、3、5` 都标记一次
- 思考能否做到：每个合数只被它的最小质因数标记一次？

欧拉筛法是对埃氏筛法的优化，能将时间复杂度降到 `O(n)`

线性筛（欧拉筛）
- 在扫描过程中维护一个 `primes` 列表，记录已经找到的质数
- 当处理当前数 `i` 时，遍历所有已知质数 `p`：
  - 标记 `i * p` 为合数
  - 如果 `p` 是 `i` 的最小质因数，就停止继续（避免重复标记）
- 这样可以保证 每个合数只被标记一次，所以整体时间复杂度 `O(n)`

✅ 结果：线性筛比普通筛法更快，尤其在大量标记时能显著减少操作

> 为什么要标记合数？
> - 合数 ≠ 质数，合数是不符合条件的数
> - 我们不可能“直接找出质数”，所以反过来：
>   - 先假设所有数字都是质数
>   - 然后用规则去排除掉合数
>   - 最终未被排除的，就是质数

```js
var countPrimes = function(n) {
    if (n < 2) return 0;

    let isPrime = new Array(n).fill(true);
    let primes = [];

    for (let i = 2; i < n; i++) {
        if (isPrime[i]) {
            primes.push(i);
        }
        for (let p of primes) {
            if (i * p >= n) break;
            isPrime[i * p] = false;
            if (i % p === 0) break;
        }
    }

    return primes.length;
};
```
```python
class Solution:
    def countPrimes(self, n: int) -> int:
        # 小于 2 的情况没有质数，直接返回 0
        if n < 2:
            return 0
        
        # 创建一个布尔数组 isPrime，长度为 n，初始值全是 True，表示默认都认为是质数
        isPrime = [True] * n
        # 用来存储已经找到的质数
        primes = []
        # 从 2 遍历到 n-1，依次判断每个数 i
        for i in range(2, n):
            # 如果 i 还没有被标记为合数，说明它是质数
            if isPrime[i]:
                # 将 i 加入质数列表 primes
                primes.append(i)
            
            # 遍历之前找到的每一个质数 p，用来标记 i 的倍数
            for p in primes:
                # 如果 i * p 超出了范围，就停止标记，避免越界
                if i * p >= n:
                    break
                
                # 把 i * p 标记为合数（False）
                isPrime[i * p] = False
                # 如果 p 是 i 的 最小质因数，那么 i * p2、i * p3 等等会在以后由别的数去标记
                # 为了保证 每个合数只被标记一次，这里立刻 break，不继续用其他质数去标记
                if i % p == 0:
                    break
        
        # 返回质数列表的长度，即小于 n 的质数个数
        return len(primes)
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`