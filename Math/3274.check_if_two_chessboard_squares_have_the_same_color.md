# 3274.检查棋盘方格颜色是否相同

题目链接：[3274.检查棋盘方格颜色是否相同](https://leetcode.cn/problems/check-if-two-chessboard-squares-have-the-same-color/)

## 题目大意

给你两个字符串 `coordinate1` 和 `coordinate2`，代表 `8 x 8` 国际象棋棋盘上的两个方格的坐标

以下是棋盘的参考图

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.4ub63c2in1.webp)

如果这两个方格颜色相同，返回 `true`，否则返回 `false`

坐标总是表示有效的棋盘方格。坐标的格式总是先字母（表示列），再数字（表示行）

```js
Example 1:
Input: coordinate1 = "a1", coordinate2 = "c3"
Output: true
Explanation: Both squares are black.

Example 2:
Input: coordinate1 = "a1", coordinate2 = "h3"
Output: false
Explanation: Square "a1" is black and "h3" is white.
```

限制：
- coordinate1.length == coordinate2.length == 2
- 'a' <= coordinate1[0], coordinate2[0] <= 'h'
- '1' <= coordinate1[1], coordinate2[1] <= '8'

## 解题

最初直觉（暴力理解）
- 棋盘上每个位置的颜色是固定的：如 `a1` 黑，`a2` 白，`b1` 白，`b2` 黑，依次交替
- 可以写一个包含 `64` 个位置和颜色的表，然后查表比较两个位置的颜色
- 缺点：太复杂，需要手动构建映射，既不优雅也不通用

进一步观察 - 棋盘颜色是交替的，棋盘的坐标是 "列字母 + 行数字"，如 `"a1"`，可以用坐标的奇偶性来判断：
- 设 `(col, row)` 表示列和行，`col` 从 `0` 开始，`row` 从 `1` 开始
- 如果 `(col + row)` 的和是偶数，颜色相同；是奇数，颜色相反
- 因为棋盘是黑白交错，颜色取决于 `(列索引 + 行索引)` 的奇偶
- 结论：判断 `(col + row) % 2` 就能得到颜色信息

最优思路 - 不需预先存储棋盘，只需：
- 把列字母 `a~h` 转为数字索引 `0~7`
- 读取行号，转成整数
- 计算 `(col + row) % 2` 得到颜色
- 比较两个坐标的颜色是否相等

### 思路 1

```js
var checkTwoChessboards = function(coordinate1, coordinate2) {
    const color = coord => {
        const col = coord.charCodeAt(0) - 'a'.charCodeAt(0);
        const row = parseInt(coord[1]);
        return (col + row) % 2;
    };

    return color(coordinate1) === color(coordinate2);
};
```
```python
class Solution:
    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:
        # 根据传入的坐标字符串 coord 计算颜色（0/1）
        def color(coord):
            # coord[0] 是列字母，如 'a'、'c'
            # ord('a') 是 'a' 的 ASCII 值，ord(coord[0]) 得到当前字母的 ASCII
            # 两者相减得到从 0 开始的列索引：a→0, b→1, …, h→7
            col = ord(coord[0]) - ord('a')
            # coord[1] 是行号字符（'1'~'8'），int() 转为整数
            row = int(coord[1])
            # 计算 (列索引 + 行号) 的奇偶性：
            # - 结果为 0 → 一种颜色（比如黑）
            # - 结果为 1 → 另一种颜色（比如白）
            return (col + row) % 2
        
        # 调用 color() 分别计算两个坐标的颜色值
        # 比较是否相等：
        # - 如果颜色值相等 → 返回 True
        # - 否则 → 返回 False
        return color(coordinate1) == color(coordinate2)
```

- 时间复杂度：`O(1)`，仅 2 个字符操作
- 空间复杂度：`O(1)`，不使用额外空间

### 思路 2

由于棋盘上的黑白格是间隔排列的，因此：
- 当行数变化 `1` 时，格子的颜色会发生变化
- 当列数变化 `1` 时，格子的颜色会发生变化

我们不需要分别算两个格子的颜色后再比较，也可直接比较它们之间的差值（利用了字符编码值之间的`奇偶性差值`来判断两个坐标是否颜色相同）：
- 两个格子的 `(col + row)` 奇偶性相同 → 颜色相同
- 两个格子的 `(col + row)` 奇偶性不同 → 颜色不同
- 如果两个格子之间行数的差值，与列数的差值，二者的和为偶数，就说明它们的颜色相同，否则颜色不同
- 因此可以写成：`[(c1_ col + c1_row) − (c2_col + c2_row)] mod 2 = 0` => 进一步展开成：`(ord(c1[0]) − ord(c2[0]) + ord(c1[1]) − ord(c2[1])) mod2 = 0`

这样就可以直接一行判断，无需定义子函数，更简洁

```js
var checkTwoChessboards = function(coordinate1, coordinate2) {
    return (coordinate1.charCodeAt(0) - coordinate2.charCodeAt(0) + coordinate1.charCodeAt(1) - coordinate2.charCodeAt(1)) % 2 === 0;
};
```
```python
class Solution:
    def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool: 
        # ord(coordinate1[0])：取第一个坐标的列字母（如 'a'）的 ASCII 值，如 'a' → 97, 'b' → 98, 依此类推
        # ord(coordinate2[0])：取第二个坐标的列字母 ASCII 值
        # ord(coordinate1[0]) - ord(coordinate2[0])：计算两个列字母在 ASCII 上的差值，相当于列索引的差

        # ord(coordinate1[1])：取第一个坐标的行数字字符 ASCII 值（如 '1' → 49， '3' → 51）
        # ord(coordinate2[1])：取第二个坐标的行数字字符 ASCII 值
        # ord(coordinate1[1]) - ord(coordinate2[1])：计算两个行数字在 ASCII 上的差值，相当于行号的差（因为 '1'、'2'、'3' ASCII 差值等于数字差值）
        
        # 把列差和行差相加，得到 (col1 - col2) + (row1 - row2)
        # (...) % 2 == 0
        # - 如果总和对 2 取模等于 0，说明 (col1 + row1) 和 (col2 + row2) 奇偶性相同 → 同色 → 返回 True
        # - 否则返回 False
        return (ord(coordinate1[0]) - ord(coordinate2[0]) + ord(coordinate1[1]) - ord(coordinate2[1])) % 2 == 0
```

- 时间复杂度：`O(1)`
- 空间复杂度：`O(1)`