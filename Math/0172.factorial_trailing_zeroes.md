# 172.阶乘后的零

题目链接：[172.阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)

## 题目大意

给定一个整数 `n`，返回 `n!` 结果中尾随零的数量

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

```js
Example 1:
Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.

Example 2:
Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.

Example 3:
Input: n = 0
Output: 0
```

限制：
- 0 <= n <= 10^4

## 解题

最直观的暴力思路
- 先算出 `n!`，然后不断整除 `10`，数出能整除多少次
- 但是：`n!` 的值非常大，计算和存储都不现实（如 `100!` 已经是极大整数）

为什么阶乘会产生尾随零？
- 一个尾随 `0` 代表 `n!` 中多了一个因子 `10`
- `10 = 2 × 5`，所以尾随 `0` 的数量取决于质因子 `2` 和 `5` 配对的数量，则问题转化为：**`n!` 最多可以分解出多少个因子 `2` 和 `5`？**
- 在 `n!` 中，因为每个偶数都能分解出因子 `2`，`2` 的数量远多于 `5` 的数量（因为偶数多），所以尾随 `0` 的数量取决于 `5` 出现的次数，问题转化为：**`n!` 最多可以分解出多少个因子 `5`？**

计算 `5` 的因子数量：
- 对于 `1~n`，每 `5` 个数就会贡献一个 `5`，但还要考虑 `25`、`125` 这些数，因为它们能贡献多个 `5`
- 一个 `5` 贡献一个 `0`，如 `5`, `10`, `15`, `20`, ...
- 一个 `25` 贡献两个 `5`（因为 `25 = 5 × 5`）
- 一个 `125` 贡献三个 `5`（因为 `125 = 5 × 5 × 5`）
- 通用公式：`zeros= n/5 + n/5^2 + n/5^3 + …`
- 直到 `n / 5^k == 0`，无需继续计算
- 如何快速统计 `5` 的因子个数？解决办法：不断用 `n // 5`、`n // 25`、`n // 125` … 直到除尽

最优解的思路：
- 用一个 `while` 循环，每次让 `n //= 5`，累加到 `count`
- 时间复杂度 `O(log₅ n)`，不需要真的计算 `n!`，非常高效

```js
var trailingZeroes = function(n) {
    let count = 0;
    while (n >= 5) {
        n = Math.floor(n / 5);
        count += n;
    }
    return count;
};
```
```python
# 写法 1
class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        while n >= 5:
            n //= 5
            count += n
        
        return count

# 写法 2
class Solution:
    def trailingZeroes(self, n: int) -> int:
        # 初始化计数器 count 为 0，用于累计 5 的因子个数
        count = 0
        # 当 n 大于 0 时循环执行
        # 每一轮都会统计当前 n 中含有的 5 的倍数贡献
        while n:
            # 将 n 整除 5，得到 n 中有多少个数至少包含一个 5 因子
            # 例如 n=25 时，25//5 = 5（包含5,10,15,20,25）
            # 下一轮循环 n 变成 n//5，继续统计 25、125 等高次幂的贡献
            n //= 5
            # 把当前这一轮的贡献累加到 count
            # 多轮叠加后，count 就是 5、25、125 等所有贡献的总和
            count += n
        
        # 返回最终统计的 count，即 n! 的尾随 0 个数
        return count 
```

- 时间复杂度：`O(logn)`
- 空间复杂度：`O(1)`
