# 7.整数反转

题目链接：[7.整数反转](https://leetcode.cn/problems/reverse-integer/)

## 题目大意

给你一个 `32` 位的有符号整数 `x`，返回将 `x` 中的数字部分反转后的结果

如果反转后整数超过 `32` 位的有符号整数的范围 `[−2^31, 2~31 − 1]`，就返回 `0`

假设环境不允许存储 `64` 位整数（有符号或无符号）

```js
Example 1:
Input: x = 123
Output: 321

Example 2:
Input: x = -123
Output: -321

Example 3:
Input: x = 120
Output: 21
```

限制：
- -2^31 <= x <= 2^31 - 1

## 解题

最初直觉 - 想把数字 `x` 反转，最直观的做法：
- 转成字符串，反转，再转回数字
- 但要注意：需要处理负号和溢出问题

暴力实现（字符串法）：
- `str_x = str(x)` → 处理负号 → 反转 → 转回整数
- 再判断是否溢出
- 虽然能做，但不够优雅，而且面试时往往期望你用数学方法，不依赖字符串

尝试用数学方法提取每一位：
- 通过 `%10` 得到最后一位，通过 `//10` 去掉最后一位
- 不断将结果 `res = res * 10 + digit`
- 处理负数时要小心，因为 `Python` 中 `%` 和 `//` 对负数的行为可能出乎意料
- 同时每次更新 `res` 前要检查是否会溢出

关键点
- 如何正确从 `x` 提取出最后一位数字 `digit`？- `digit = x % 10`，但在 `Python` 中负数 `%` 会返回非负余数，需调整
- 如何去掉最后一位？- `x = (x - digit) // 10`，这样对负数和正数都能得到正确的整除效果
- 如何防止溢出？在更新 `res` 之前，先检查 `res` 是否已经超出 `INT_MAX//10` 或 `INT_MIN//10` 的安全范围

采用纯数学方法：
- 通过 `%10` 和 `//10` 逐位反转
- 处理负数 `%` 的问题
- 每一步判断是否即将溢出，提前返回 `0`

```js
var reverse = function(x) {
    const INT_MAX = Math.pow(2, 31) - 1, INT_MIN = -Math.pow(2, 31);
    let rev = 0;
    while (x !== 0) {
        let digit = x % 10;
        x = (x / 10) | 0;  // 使用按位或 0 去除小数部分，模拟整数除法

        if (rev > INT_MAX / 10 || (rev === INT_MAX / 10 && digit > 7)) return 0;
        if (rev < INT_MIN / 10 || (rev === INT_MIN / 10 && digit < -8)) return 0;

        rev = rev * 10 + digit;
    }
    return rev;
};
```
```python
class Solution:
    def reverse(self, x: int) -> int:
        # 定义 32 位整数的上下限：
        # - INT_MAX = 2147483647
        # - INT_MIN = -2147483648
        # 后续需要用来判断是否溢出
        INT_MAX, INT_MIN = 2**31 - 1, -2**31
        # 初始化结果 res 为 0，用来逐位累积反转后的数字
        res = 0
        # 当 x 不等于 0 时，持续提取 x 的最后一位数字，累积到 res 中
        while x != 0:
            # 在更新 res 之前，判断是否已经接近溢出：
            # - 如果 res > INT_MAX // 10，再乘 10 就必溢出
            # - 如果 res < INT_MIN // 10 + 1，再乘 10 也会溢出
            # 若有溢出风险，直接返回 0
            # 为什么是 INT_MIN // 10 + 1？
            # - 因为 rev * 10 + digit 最小会减去 9（digit 最多为 -9），所以提前预留安全区间
            if res < INT_MIN // 10 + 1 or res > INT_MAX // 10:
                return 0
            
            # 提取当前最低位数字
            # 注意：在 Python 中，负数取模会得到正值。例如：-123 % 10 == 7，所以对于负数，需要额外处理
            digit = x % 10

            # Python3 的取模运算在 x 为负数时也会返回 [0, 9) 以内的结果，因此这里需要进行特殊判断
            # 如果 x 是负数，但取模结果为正，说明取模存在偏差，需手动调整，使得 digit 保持与原始数字相符的负数
            # 举例说明：x = -123
            # - 第一次：digit = -123 % 10 = 7
            # - 实际上想要的是 -3，所以需 7 - 10 = -3
            # 通过 digit -= 10，把它调整为真正的负数位
            if x < 0 and digit > 0:
                digit -= 10
            
            # 同理，Python3 的整数除法在 x 为负数时会向下（更小的负数）取整，因此不能写成 x //= 10
            # 更新 x，去掉刚刚提取的最后一位：
            # - x - digit 去掉余数部分，再 //10 得到新的 x
            # 这样既能处理正数，也能正确处理负数
            x = (x - digit) // 10

            # 拼接到结果上，完成当前位的反转
            res = res * 10 + digit
        
        # 循环结束后，返回最终的 res
        # 如果中途遇到溢出风险，前面已经 return 0 了
        return res
```

- 时间复杂度：`O(log∣x∣)`，每次循环去掉一位数字，翻转的次数即 `x` 十进制的位数
- 空间复杂度：`O(1)`