# 50.Pow(x, n)

题目链接：[50.Pow(x, n)](https://leetcode.cn/problems/powx-n/)

## 题目大意

实现 `pow(x, n)`，即计算 `x` 的整数 `n` 次幂函数（即，`x^n` ）

```js
Example 1:
Input: x = 2.00000, n = 10
Output: 1024.00000

Example 2:
Input: x = 2.10000, n = 3
Output: 9.26100

Example 3:
Input: x = 2.00000, n = -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
```

限制：
- -100.0 < x < 100.0
- -2^31 <= n <= 2^31-1
- n is an integer.
- Either x is not zero or n > 0.
- -10^4 <= x^n <= 10^4

## 解题

根据数学定义，x^n=x·x·x·x…（重复 `n` 次），所以最简单的写法就是：
```python
res = 1
for i in range(n):
    res *= x
return res
```

问题：
- 时间复杂度：`O(n)`，如果 `n` 很大（如 `2^31`），会非常慢
- 当 `n` 是负数时，需先转换为正数，或处理 `1/x`
- 暴力法结论：简单，但无法应对大 n，必须优化

优化思路：`快速幂（分治思想）`

观察：
- 当 `n` 为偶数：`x^n = (x^(n/2))^2`，如 `2^10 = (2^5)^2`
- 当 `n` 为奇数：`x^n = x * x^(n−1)`，如 `2^9 = 2 × (2^8) = 2 × (2^4)^2`

如果把 `n` 持续二分，可以减少乘法次数

> 快速幂原理：
> - `n` 每次除以 `2`（折半），计算过程中不断平方底数 `x`
> - 当 `n` 为奇数时，额外乘一次当前的 `x`
>
> 为什么这样做：
> - 每次二分 `n`，时间复杂度从 `O(n)` 降到 `O(logn)`
> - 用位运算/除法判断 `n` 的奇偶，灵活高效

特殊情况：`n < 0` 时，转换为：`x^(−n) = 1/x^n`

```js
var myPow = function(x, n) {
    if (n === 0) return 1;
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }

    let res = 1;
    while (n) {
        if (n % 2 !== 0) {
            res *= x;
        }

        x *= x;
        n = Math.floor(n / 2);
    }

    return res;
};
```
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        # 特判 n=0 的情况
        # - 任何数的 0 次方都等于 1
        # - 提前返回，减少后续逻辑处理
        if n == 0:
            return 1
        
        # 处理负指数，如果 n 是负数：
        # - 将底数 x 取倒数 (1/x)
        # - 将指数 n 转为正数 (-n)
        # 这样后续逻辑只需处理正指数
        if n < 0:
            x = 1 / x
            n = -n
        
        # 初始化结果：用 res 来累乘结果，初始值为 1（乘法的单位元）
        res = 1
        # 循环直到 n 变为 0
        # 每次迭代处理 n 的最低位（奇偶性）
        # 同时不断缩小 n（右移/整除 2）
        while n:
            # 如果当前 n 是奇数
            # - 说明当前的 x 对应的这一位要计入结果
            # - 将 res 乘上当前的 x
            # 逻辑：快速幂在二进制拆分 n，当前位是 1 时就累乘
            if n % 2:
                res *= x
            
            # 底数自乘，准备处理下一位
            # 因为 n 已经要右移（除 2），所以底数要提前平方
            # 如：x^(8) = (x^2)^4 = (x^4)^2 … 逐步平方
            x *= x
            # 指数整除 2
            # 把 n 右移一位
            # 不断缩小问题规模，直到 n 变为 0
            # 用于每次将 n 减半，从而减少计算次数，最终 n 变为 0 结束循环
            n //= 2
        
        return res
```

- 时间复杂度：`O(log n)`，通过指数不断减半，加速计算
- 空间复杂度：`O(1)`，仅使用常数变量，无额外存储