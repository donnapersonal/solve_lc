# 2413.最小偶倍数

题目链接：[2413.最小偶倍数](https://leetcode.cn/problems/smallest-even-multiple/)

## 题目大意

给你一个正整数 `n`，返回 `2` 和 `n` 的最小公倍数（正整数）

```js
Example 1:
Input: n = 5
Output: 10
Explanation: The smallest multiple of both 5 and 2 is 10.

Example 2:
Input: n = 6
Output: 6
Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself.
```

限制：
- 1 <= n <= 150

## 解题

要找到一个数，它既是 `n` 的倍数，也是 `2` 的倍数，这本质就是找 `n` 和 `2` 的最小公倍数（`LCM`）

不需要一个个去试，可以直接分析：
- 如果 `n` 本身就是偶数，那么 `n` 自己就是一个偶数倍（`n × 1` 就是 `n` 本身，且偶数），所以答案就是 `n`
- 如果 `n` 是奇数，那么 `n × 1` 是奇数，不行；`n × 2` 一定是偶数（因为奇数 × 2 = 偶数），且这是最小的倍数

结论 - 只需判断 `n` 是否为偶数：
- 偶数：直接返回 `n`
- 奇数：返回 `n * 2`

位运算优化写法
- 判断奇偶：`n & 1`
  - 当 `n` 是偶数，末位二进制是 `0`，`n & 1 = 0`
  - 当 `n` 是奇数，末位二进制是 `1`，`n & 1 = 1`
- 根据奇偶做选择：
  - 如果 `n & 1 = 0 (偶数)`：返回 `n << 0 = n`
  - 如果 `n & 1 = 1 (奇数)`：返回 `n << 1 = n * 2`

> 利用位移：
> - `n << k` 表示把 `n` 左移 `k` 位，相当于 `n * (2^k)`
> - 当 `k=0`：`n << 0 = n`
> - 当 `k=1`：`n << 1 = n * 2`

因此可以直接写成：`return n << (n & 1)`
> 优点：
> - 不用 `if/else`，简洁且具有位运算的巧妙性
> - 时间复杂度依然 `O(1)`

```js
var smallestEvenMultiple = function(n) {
    return n % 2 === 0 ? n : n * 2;
};
```
```python
class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        # 核心逻辑：三元运算符（条件表达式）
        # n % 2 == 0：判断 n 是否为偶数
        # - 若为真（n 是偶数），直接返回 n
        # - 若为假（n 是奇数），返回 n * 2，因为奇数乘 2 就是最小的偶数倍
        # 这一行同时完成了判断与返回，非常简洁高效
        return n if n % 2 == 0 else n * 2
        # 可写成：return (n % 2 + 1) * n

# 写法 2
# 可以看成是 n 为奇数时，n 左移一位，否则不变，因此可以用位运算解决
class Solution:
    def smallestEvenMultiple(self, n: int) -> int:
        # n & 1：按位与运算，取出 n 的最低位（奇偶判断）
        # - 若 n 是偶数，二进制最低位为 0，结果是 0
        # - 若 n 是奇数，二进制最低位为 1，结果是 1
        # n << (n & 1)：把 n 左移 (n & 1) 位
        # - 如果 (n & 1) = 0：左移 0 位 → 结果是 n 本身
        # - 如果 (n & 1) = 1：左移 1 位 → 结果是 n * 2
        return n << (n & 1)
```

- 时间复杂度：`O(1)`，仅需要判断一次 `n` 的奇偶性
- 空间复杂度：`O(1)`