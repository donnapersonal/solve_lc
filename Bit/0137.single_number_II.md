# 137.只出现一次的数字 II

题目链接：[137.只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

## 题目大意

给你一个整数数组 `nums`，除某个元素仅出现一次外，其余每个元素都恰出现三次，请找出并返回那个只出现了一次的元素

必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题

```js
Example 1:
Input: nums = [2,2,3,2]
Output: 3

Example 2:
Input: nums = [0,1,0,1,0,1,99]
Output: 99
```

限制：
- 1 <= nums.length <= 3 * 10^4
- -2^31 <= nums[i] <= 2^31 - 1
- Each element in nums appears exactly three times except for one element which appears once.

## 解题

初始思路：使用哈希表计数
- 使用 `collections.Counter` 或字典统计每个数字出现的次数，返回 `count == 1` 的那个数
  ```python
  from collections import Counter
    counts = Counter(nums)
    for num, count in counts.items():
        if count == 1:
            return num
  ```
- 缺点：
  - 虽然时间复杂度是 `O(n)`，但空间复杂度是 `O(n)`
  - 不符合题目要求的 `O(1)` 空间

### 思路 1

对 `32` 位整数的每一位进行如下操作：
- 遍历所有数字，对每一位进行右移与 `&1` 操作来统计该位 `1` 出现次数
- 如果该位的 `1` 出现次数不是 `3` 的倍数，说明只出现一次的数在该位为 `1`
- 最后将这些位重新拼成结果

注意：负数在 `Python` 中的表现，需额外处理最高位（第 `31` 位，符号位）

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化结果变量 res，用来存储最终的只出现一次的数字
        res = 0
        # 循环处理 32 位整数的每一位（第 0 位到第 31 位）：对于每一位 i，我们都要统计 nums 中该位为 1 的总次数
        for i in range(32):
            # 对所有数字 num，右移 i 位 (num >> i)，再取最低位 & 1，就得到该数字在第 i 位上的值（0 或 1）
            # 然后将所有数在第 i 位的 1 总次数累加得到 total
            total = sum((num >> i) & 1 for num in nums)
            # 如果该位上的 1 出现次数 mod 3 ≠ 0，说明只出现一次的数字在这一位上是 1
            # 所以需把这一位设置到 res 上
            if total % 3:
                # 关键处理！第 31 位是符号位（Python 整数没有固定长度，但这里模拟 32 位补码）：
                # - 如果只出现一次的数字在第 31 位上是 1，说明它是负数
                # - Python 中没有直接的有符号位表示，因此要手动用减法将 res 转换为负数形式（相当于加上负权值 -2^31）
                if i == 31:
                    res -= (1 << i)
                else:
                    # 如果是非符号位，正常设置第 i 位为 1（使用按位或 |）
                    res |= (1 << i)
        
        # 最终返回结果 res，即只出现一次的数字
        return res
```

- 时间复杂度：`O(nlogC)`，其中 `n` 是数组的长度，`C` 是元素的数据范围，在本题中 `logC=log32 = 32`，即需遍历第 `0∼31` 个二进制位
- 空间复杂度：`O(1)`


### 思路 2

最优解：`状态机 + 位运算模拟三进制计数`
- 可以使用两个整数 `ones` 和 `twos` 模拟二进制计数器的状态机：
  - `ones` 记录当前位出现了一次的数字
  - `twos` 记录当前位出现了两次的数字
  - 当某个数出现了三次，应该从 `ones` 和 `twos` 中移除
- 核心逻辑：
  - 第一次出现：保存在 `ones`
  - 第二次出现：从 `ones` 移到 `twos`
  - 第三次出现：从 `twos` 删除
- 这样最后 `ones` 中就只剩下那个只出现一次的数字

```js
var singleNumber = function(nums) {
    let ones = 0, twos = 0;
    for (let num of nums) {
        ones = (ones ^ num) & ~twos;  // 更新 ones
        twos = (twos ^ num) & ~ones;  // 更新 twos
    }
    return ones;  // 最后剩下的就是只出现一次的数字
};
```
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化两个变量 ones 和 twos，都为 0
        # 它们将作为位掩码（bit mask）：
        # - ones：记录当前位上出现一次的状态
        # - twos：记录当前位上出现两次的状态
        ones, twos = 0, 0
        # 遍历数组中每一个数字 num
        for num in nums:
            # 更新 ones 和 twos
            # ones ^ num：如果 num 在 ones 里没有，则加入；如果已经有了，则移除（模拟位翻转）
            # 如果 num 第 i 位是 1，且 ones 中该位原本是 0 → 就会变成 1（意味着“出现一次”）
            # 但要排除那些已经出现在 twos 中的位（即出现了第二次），如果某个位在 twos 里已经出现两次，就不允许 ones 记录它，所以我们：
            # - & ~twos：把已经进入 twos 的位清零，不允许保留在 ones
            # 这行的作用是：将 num 加入 ones，并清除那些已经在 twos 中的位
            ones = (ones ^ num) & ~twos
            # twos ^ num：尝试把 num 加入 twos
            # & ~ones：把已经进入 ones 的位清零，防止冲突
            # 这行的作用是：将 num 加入 twos，并清除那些已经在 ones 中的新位（避免重复）
            twos = (twos ^ num) & ~ones
        
        # 遍历结束后，只有那个只出现一次的数的位还留在 ones 中
        # 直接返回 ones
        return ones
```

- 时间复杂度：`O(n)`，只遍历了数组一次，处理每个数字需要常数时间
- 空间复杂度：`O(1)`，只使用了常数空间来保存 `ones` 和 `twos` 变量

