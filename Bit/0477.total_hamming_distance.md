# 477.汉明距离总和

题目链接：[477.汉明距离总和](https://leetcode.cn/problems/total-hamming-distance/)

## 题目大意

两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量

给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间 汉明距离的总和 

```js
Example 1:
Input: nums = [4,14,2]
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

Example 2:
Input: nums = [4,14,4]
Output: 4
```

限制:
- 1 <= nums.length <= 10^4
- 0 <= nums[i] <= 10^9
- The answer for the given input will fit in a 32-bit integer.

## 解题

**暴力解法**
- 两重循环遍历数组所有 `(i, j)` 对：
  ```js
  for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        ans += hamming_distance(nums[i], nums[j])
  ```
- 计算 `Hamming Distance`：对每对数进行异或再统计 `1` 的个数：`bin(nums[i] ^ nums[j]).count('1')`
- 时间复杂度：`O(n^2 × 32)` → 对大数组效率低

### 写法 1

**思路**
- 关键点：Hamming Distance 是 按位累加的：
  - 对每一位（0–31），统计该位 `0` 的数量 `s0` 和 `1` 的数量 `s1`
  - 该位贡献的 `Hamming Distance = s0 × s1`
- 原因：每个 `0` 与每个 `1` 对应都会产生 `Hamming Distance 1`
- `总和 = 所有 32 位贡献的和`

具体地，若长度为 `n` 的数组 `nums` 的所有元素二进制的第 `i` 位共有 `c` 个 `1`，`n−c `个 `0`，则些元素在二进制的第 `i` 位上的汉明距离之和为 `c⋅(n−c)`

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var totalHammingDistance = function(nums) {
    let res = 0;
    for (let x = 31; x >= 0; x--) {
        let s0 = 0, s1 = 0;
        for (const u of nums) {
            if (((u >> x) & 1) === 1) {
                s1++;
            } else {
                s0++;
            }
        }
        res += s0 * s1;
    }
    return res;
};
```
```python
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        res = 0

        # 遍历整数的每一位（假设 32 位整数，x 从 31 到 0）
        # 原因：按位统计 Hamming Distance，逐位处理比两两对比更高效。=
        for x in range(31, -1, -1):
            # 统计当前位上 0 的数量 s0 和 1 的数量 s1
            s0, s1 = 0, 0

            # 遍历数组每个数字 u：
            for u in nums:
                # u >> x → 将数字右移 x 位，让目标位在最右边
                # & 1 → 取最低位
                # 如果为 1 → s1 += 1，否则 s0 += 1
                if ((u >> x) & 1) == 1:
                    s1 += 1
                else:
                    s0 += 1
          
            # 计算该位贡献的 Hamming Distance：每个 0 位与每个 1 位配对
            # 累加到总答案 res
            res += s0 * s1
        
        # 返回最终总 Hamming Distance
        return res

# 写法 2
class Solution:
    def totalHammingDistance(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0
        for i in range(30):
            c = sum(((val >> i) & 1) for val in nums)
            res += c * (n - c)
            
        return res
```

- 时间复杂度：`O(C∗n)`，`C` 固定为 `32`
- 空间复杂度：`O(1)`