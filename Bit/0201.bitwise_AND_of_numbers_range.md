# 201.数字范围按位与

题目链接：[201.数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

## 题目大意

给你两个整数 `left` 和 `right`，表示区间 `[left, right]`，返回此区间内所有数字`按位与`的结果（包含 `left`、`right` 端点）

```js
Example 1:
Input: left = 5, right = 7
Output: 4

Example 2:
Input: left = 0, right = 0
Output: 0

Example 3:
Input: left = 1, right = 2147483647
Output: 0
```

限制：
- 0 <= left <= right <= 2^31 - 1

## 解题

初始思路：暴力按位与（TLE）
- 最直观的做法是从 `left` 到 `right` 逐个数字进行按位与：
  ```python
  res = left
  for i in range(left + 1, right + 1):
      res &= i
  ```
- 问题：
  - 时间复杂度为 `O(right - left)`，当区间跨度很大（如 `0` 到 `2^31`），会超时
  - 且一旦某一位变成 `0`，就不可能恢复成 `1`，没有必要继续下去

观察按位与操作的特点：
- 如果某一位在 `[left, right]` 中至少出现过一个 `0`，则结果该位一定是 `0`
- 所以只保留所有数的公共高位前缀，其余位数一律为 `0`

举例：
```python
left  = 26 = 11010
right = 30 = 11110

从 26 到 30 的按位与为：
11010
11011
11100
11101
11110

结果是 11000 => 即公共前缀为 110，后面两位变成 0
```

### 思路 1: 位移 - 找公共前缀（Prefix Trick）

思路：`右移找前缀 + 左移还原`
- 不断将 `left` 和 `right` 同时右移，直到它们相等（意味着找到了公共前缀）
- 然后再将结果左移回来（恢复原本位数）
  
```js
var rangeBitwiseAnd = function(left, right) {
    let shift = 0;
    while (left < right) {  // 找到公共前缀
        left >>= 1;
        right >>= 1;
        shift++;
    }

    return left << shift;  // 补回低位
};
```
```python
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:
        # 初始化右移次数 shift = 0，用于记录公共前缀后要左移回去的位数
        shift = 0
        # 当 left 和 right 还不相等时，表示还没有找到公共前缀
        while left < right:  
            # 将 left 和 right 同时右移一位，相当于去掉末尾不同的位
            left >>= 1
            right >>= 1
            # 每移一次，就记录一次 shift，最后再左移回来
            shift += 1
        
        # 当 left == right 时，我们已经找到公共前缀
        # 把它左移回原来的位数，即得到最终结果
        return left << shift
```

- 时间复杂度：`O(logn)`，算法的时间复杂度取决于 `m` 和 `n` 的二进制位数，由于 `m≤n`，因此时间复杂度取决于 `n` 的二进制位数
- 间复杂度：`O(1)`，只需常数空间存放若干变量

### 思路 2: Brian Kernighan 算法

思路（二进制消除低位变化）
- 换一种方式，从 `right` 出发，每次把 `right` 的最低位 `1` 消除，直到它小于等于 `left`，此时非公共前缀部分的 `1` 均被消去，因此最后返回 `n` 即可
- 原因：只要还有某一位在 `left` 和 `right` 之间变化过（从 `0` 到 `1` 或 `1` 到 `0`），该位就不能保留，最终会变成 `0`

这种做法不断把 `right` 向下“对齐”到 `left` 能接受的公共前缀

```js
var rangeBitwiseAnd = function(left, right) {
    while (left < right) {
        // 抹去最右边的 1
        right = right & (right - 1);
    }

    return right;
};
```
```python
class Solution:
    def rangeBitwiseAnd(self, left: int, right: int) -> int:  
        # 当 right 大于 left 时：意味着 right 还有不确定的变化位，需要继续处理
        while left < right:
            # 这是一个经典的位运算技巧，用来清除 right 的最低位的 1
            # 例：right = 11010 → right - 1 = 11001 → right & (right - 1) = 11000
            # 每次清掉一个最低的 1，意味着缩小区间，去除不必要的干扰位
            right = right & (right - 1)
            
        # 此时 left >= right，两者的公共前缀已经找出
        # 返回 right 即为 [left, right] 范围内所有数的按位与结果
        return right
```

- 时间复杂度：`O(logn)`，和位移方法类似，算法的时间复杂度取决于 `m` 和 `n` 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 `Brian Kernighan` 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位
- 空间复杂度：`O(1)`，只需要常数空间存放若干变量