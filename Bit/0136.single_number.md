# 136.只出现一次的数字

题目链接：[136.只出现一次的数字](https://leetcode.cn/problems/single-number/)

## 题目大意

给一个非空整数数组 `nums`，除了某个元素只出现一次以外，其余每个元素均出现两次，找出那个只出现了一次的元素

必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间

```js
Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1
```

限制：
- 1 <= nums.length <= 3 * 10^4
- -3 * 10^4 <= nums[i] <= 3 * 10^4
- Each element in the array appears twice except for one element which appears only once.

## 解题

暴力解法 - 使用哈希表计数
- 用一个字典 `count` 统计每个数出现的次数，最后返回那个只出现 `1` 次的数

```python
from collections import Counter
count = Counter(nums)
for num in count:
    if count[num] == 1:
        return num
```
- 时间复杂度：`O(n)`，空间复杂度：`O(n)`
- 缺点：虽然时间复杂度满足要求，但空间复杂度为 `O(n)`，不满足题目“常数空间”的要求

最优解：位运算（异或）
- 关键点：利用`异或`运算的性质，可以在线性时间 + 常数空间下解决问题

位运算的关键性质

| 表达式 | 结果说明 |
| --- | --- |
| `a ^ 0 = a` | 任意数与 `0` 异或仍为它本身 |
| `a ^ a = 0` | 相同的两个数异或为 `0` |
| `a ^ b ^ a = b` | 可以交换顺序，`a` 被抵消 |

推理过程：
- 所有成对的数字异或为 `0`（因为 `a ^ a = 0`）
- `0` 再与唯一的数字异或 ⇒ 得到这个唯一的数字

```js
var singleNumber = function(nums) {
    let res = 0;
    for (let num of nums) {
        res ^= num;
    }
    return res;
};
```
```python
# 写法 1
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 初始化变量 res 为 0，这是异或操作的“单位元”
        res = 0
        # 遍历数组中的每一个数字 num
        for num in nums:
            # 对 res 与当前数字进行异或操作
            # 因为成对的数字会互相抵消（a ^ a = 0），最终 res 就会留下唯一的那个数
            res ^= num
        
        # 返回结果，即数组中只出现一次的那个数字
        return res

# 写法 2
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 将 nums 中的所有元素依次进行按位异或运算。它的具体工作方式如下：
        # - 初始值：reduce 先将 nums 的第一个元素作为初始值
        # - 运算过程：依次将列表中的每个元素与初始值进行异或操作，并将结果作为新的初始值
        # - 最终结果：reduce 返回所有元素依次异或后的结果
        return reduce(lambda x, y: x ^ y, nums)
```

- 时间复杂度：`O(n)`，`n` 是数组长度，只需对数组遍历一次
- 空间复杂度：`O(1)`