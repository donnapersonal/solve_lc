# 191.位 1 的个数

题目链接：[191.位 1 的个数](https://leetcode.cn/problems/number-of-1-bits/)

## 题目大意

给定一个正整数 `n`，编写一个函数，获取一个正整数的二进制形式并返回其二进制表达式中`设置位`的个数（也被称为汉明重量）

```js
Example 1:
Input: n = 11
Output: 3
Explanation: The input binary string 1011 has a total of three set bits.

Example 2:
Input: n = 128
Output: 1
Explanation: The input binary string 10000000 has a total of one set bit.

Example 3:
Input: n = 2147483645
Output: 30
Explanation: The input binary string 1111111111111111111111111111101 has a total of thirty set bits.
```

限制：
- 1 <= n <= 2^31 - 1

## 解题

暴力解：转换为二进制字符串
- 使用 `Python` 内置函数 `bin(n)` 将整数转换为二进制字符串
- 统计字符串中 `'1'` 出现的次数
  ```python
  return bin(n).count('1')
  ```
- 优点：实现简单，`1` 行代码
- 缺点：
  - 依赖字符串转换，开销不小
  - 不够底层、算法性较弱，不利于面试展示能力

### 思路 1: 逐位检查（位掩码法）

核心思想：
- 每次检查 `n` 的每一位是否为 `1`
- 利用`按位与运算 (&)` 与`位移操作`
- 优点：
  - 不需要转换为字符串，时间复杂度 `O(1)`
  - 展示了位运算能力，更适合面试


```js
var hammingWeight = function(n) {
    let res = 0;
    for (let i = 0; i < 32; i++) {
        if ((n & (1 << i)) !== 0) {
            res++;
        }
    }
    return res;
};
```
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # for i in range(32)：遍历 0~31，即从最低位到最高位，总共 32 位（适用于标准 32 位无符号整数）
        # 1 << i：表示将 1 向左移动 i 位，得到第 i 位为 1 的掩码，比如：
        # - i=0 → 000...0001（最低位）
        # - i=1 → 000...0010
        # n & (1 << i)：检查 n 的第 i 位是否为 1 - 如果为 1，结果非零；否则为零
        # sum(1 for ...)：对所有满足条件的位（即 n & (1 << i) 为真），累加 1
        # 最终结果就是 n 中所有 1 的个数
        # ✅ 整体作用：统计 n 的二进制中一共有多少个 1
        res = sum(1 for i in range(32) if n & (1 << i)) 
        return res
```

- 时间复杂度：`O(k)`，其中 `k` 是 `int` 型的二进制位数，`k=32`。需检查 `n` 的二进制位的每一位，一共需检查 `32` 位
- 空间复杂度：`O(1)`，只需要常数的空间保存若干变量

### 思路 2: Brian Kernighan 算法

核心思想：
- 每次将 `n` 的最低位的 `1` 消掉
- 每执行一次 `n &= (n - 1)`，就相当于删掉一个 `1`
- 循环次数 `= n` 的二进制中 `1` 的数量

优点：
- `执行次数 = 1 的数量`，效率极高
- 更适合用于`稀疏二进制数（1 少）`的情况

```js
var hammingWeight = function(n) {
    let count = 0;
    while (n !== 0) {
        n &= (n - 1); // 消除最低位的 1
        count++;
    }
    return count;
};
```
```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 初始化计数器 count，用于统计 1 的个数
        count = 0

        # 当 n 不为 0 时循环
        # 每次循环会消除 n 中一个最低位的 1，直到变成 0
        while n:
            # 将 n 的最低位的 1 置为 0
            # 举例说明：
            # - n = 12 (1100)
            # - n - 1 = 11 (1011)
            # n & (n - 1) = 1100 & 1011 = 1000（最低位的 1 被清除了）
            # 所以每执行一次这行语句，相当于消掉一个 1
            n &= (n - 1)
            # 每次成功清除一个 1，count 加一
            count += 1
        
        # 当所有的 1 被清除完后，返回计数结果
        return count
```

- 时间复杂度：`O(logn)`
  - `n` 在二进制中最多有 `log₂(n) + 1` 位
  - 循环次数等于 `n` 的二进制位中 `1` 的个数
  - 最坏情况下 `n` 的二进制位全部为 `1`，需要循环 `logn` 次
- 空间复杂度：`O(1)`，只需常数的空间保存若干变量