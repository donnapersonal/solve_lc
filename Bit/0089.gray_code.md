# 89.格雷编码

题目链接：[89.格雷编码](https://leetcode.cn/problems/gray-code/)

## 题目大意

`n` 位格雷码序列是一个由 `2^n` 个整数组成的序列，其中：
- 每个整数都在范围 `[0, 2^n - 1]` 内（含 `0` 和 `2^n - 1`）
- 第一个整数是 `0`
- 一个整数在序列中出现 不超过一次
- 每对相邻整数的二进制表示恰好一位不同 ，且
- 第一个和最后一个整数的二进制表示恰好一位不同

给你一个整数 `n`，返回任一有效的 `n` 位格雷码序列 

```js
Example 1:
Input: n = 2
Output: [0,1,3,2]
Explanation:
The binary representation of [0,1,3,2] is [00,01,11,10].
- 00 and 01 differ by one bit
- 01 and 11 differ by one bit
- 11 and 10 differ by one bit
- 10 and 00 differ by one bit
[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].
- 00 and 10 differ by one bit
- 10 and 11 differ by one bit
- 11 and 01 differ by one bit
- 01 and 00 differ by one bit

Example 2:
Input: n = 1
Output: [0,1]
```

限制：
- 1 <= n <= 16

## 解题

暴力思路（回溯生成 + 检查）
- 最直接的想法是用回溯法，从 `0` 开始，每次尝试变换一位（翻转某一位），生成下一个未出现过的数
- 缺点是：
  - 需要维护已访问集合
  - 生成效率低
  - 时间复杂度高达 `O(n × 2^n)`，会超时

格雷码的定义：
- 第一个格雷码位 = 二进制的第一位
- 后续每一位 = 当前位 ^ 前一位

对于 `n` 位格雷码，第 `i` 个格雷码的生成公式为：`Gray(i) = i ^ (i >> 1)`
- `^` 是按位异或
- `i >> 1` 是 `i` 右移一位

这个公式生成 `Gray Code`，且满足所有题目要求！

为什么这个公式成立？
- 设 `i` 是普通二进制数，其格雷码 `G(i)` 的定义为：
  - `G[0] = B[0]`（最高位不变）
  - `G[i] = B[i] ^ B[i-1]`（其余位是当前位异或上一位）
- 这个规律转换成代码就是 `G = i ^ (i >> 1)`

> 异或运算还可用于“检测差异”
> - `A ^ B = 1` 代表两个值在该位不同
> - 所以 `i ^ (i >> 1)` 实际上是在构造出每位相对于前一位是否变化的标志位

这个公式天然满足格雷码的性质：
- 每相邻两个数只有一位不同（`Hamming Distance = 1`）
- 因为这个异或操作确保每一位从前一位到当前位最多只改变一个 `bit`，从而满足 `Gray Code` 的定义（相邻值只差一位）
- 从 `0` 到 `2^n - 1` 顺序遍历 `i`，就能构造出完整序列

```js
var grayCode = function(n) {
    const res = [];
    const total = 1 << n;  // 2^n
    for (let i = 0; i < total; i++) {
        res.push(i ^ (i >> 1));
    }
    return res;
};
```
```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        # 初始化结果列表，用于存储格雷码序列
        res = []
        # 遍历 i 从 0 到 2^n - 1：1 << n 表示 2^n，相当于有 2^n 个格雷码
        for i in range(1 << n): 
            # 使用格雷码构造公式 G(i) = i ^ (i >> 1)，将每个生成的格雷码添加到结果列表
            # i：当前的普通整数（十进制）
            # ^ 是 按位异或，即相同为 0，不同为 1
            # >> 是 右移一位，相当于把 i 的高位信息下传一位
            # i ^ (i >> 1) 的结果，就是第 i 个 Gray Code 的值 
            res.append(i ^ (i >> 1))
        
        # 返回完整的格雷码序列
        return res
```

- 时间复杂度：`O(2^n)`，每一个格雷码生成的时间为 `O(1)`，总时间为 `O(2^n)`
- 空间复杂度：`O(1)`，这里返回值不计入空间复杂度