# 52.N 皇后 II

题目链接：[52.N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)

## 题目大意

`n` 皇后问题研究的是如何将 `n` 个皇后放置在 `n × n` 的棋盘上，且使皇后彼此之间不能相互攻击

给一个整数 `n`，返回 `n` 皇后问题不同的解决方案的数量

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.60ukm7m1cr.webp)

限制：
- 1 <= n <= 9

## 解题

### 思路 1: 回溯

回溯法（Backtracking）
- 核心思路：一行一行尝试摆放皇后，每次选择一个安全的列进行尝试，递归进入下一行
- 遇到非法放置直接剪枝，回溯上一步尝试其他可能

**写法 1：**

优化方向：
- 使用一个 `board` 记录当前皇后摆放状态
- 加入 `isValid` 函数判断当前位置是否安全
- 通过不断尝试、回溯和剪枝，统计所有合法摆放的次数

**写法 2：状态压缩优化**

为了加快冲突检测，用三个布尔数组代替 `board`：
- `col`：记录某列是否已有皇后	
- `diag1`：`↘` 主对角线（`r + c`）是否冲突	
- `diag2`：`↙` 副对角线（`r - c`）是否冲突

这种方式避免了用二维棋盘判断冲突，大大提升了速度和内存效率

```js
var totalNQueens = function(n) {
    let res = 0;
    let board = Array.from({length: n}, () => '.'.repeat(n));

    const backtrack = function(board, row) {
        if (row == n) {
            res++;
            return;
        }

        for(let col = 0; col < n; col++) {
            if (!isValue(board, row, col)) continue;
            board[row] = board[row].slice(0, col) + "Q" + board[row].slice(col + 1);
            backtrack(board, row + 1);
            board[row] = board[row].slice(0, col) + '.' + board[row].slice(col + 1);
        }
    };

    const isValue = function(board, row, col) {
        for (let i = 0; i <= row; i++) {
            if (board[i][col] === 'Q') return false;
        }

        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] == "Q") return false;
        }

        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if(board[i][j] == "Q") return false;
        }

        return true;
    };
    
    backtrack(board, 0);
    return res;
};
```
```python
# 写法 1
class Solution:
    def totalNQueens(self, n: int) -> int:
        self.res = 0
        # 初始化 n×n 棋盘，"." 表示空位
        board = [["." for _ in range(n)] for _ in range(n)]

        # 从第 0 行开始回溯搜索
        self.backtrack(board, 0)
        return self.res
    
    # 回溯函数参数：
    # - board：当前棋盘状态
    # - row：当前尝试摆放皇后的行
    def backtrack(self, board, row):
        # 若当前行等于 n，说明已经成功摆放 n 个皇后，记录一个解法并返回
        if row == len(board):
            self.res += 1
            return 
        
        # 遍历当前行的每一列，尝试将皇后放入 (row, col)
        for col in range(len(board[row])):
            # 判断当前位置是否合法（不与已有皇后冲突），非法就跳过
            if not self.isValid(board, row, col):
                continue
            
            # 尝试放置皇后
            board[row][col] = "Q"
            # 递归尝试下一行
            self.backtrack(board, row + 1)
            # 回溯，将当前位置恢复为空，尝试下一列
            board[row][col] = "."
    
    # 判断 (row, col) 处是否可以放皇后
    def isValid(self, board, row, col):
        # 检查同一列是否有皇后
        for i in range(row + 1):
            if board[i][col] == "Q":
                return False
        
        # 检查右上方斜线（↗）是否有皇后
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, len(board))):
            if board[i][j] == "Q":
                return False
        
        # 检查左上方斜线（↖）是否有皇后
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == "Q":
                return False
        
        return True

# 写法 2
class Solution:
    def totalNQueens(self, n: int) -> int:
        res = 0
        # 布尔数组 col：用于记录每一列是否已有皇后
        col = [False] * n
        # 布尔数组 diag1：记录主对角线（↘）是否有皇后。索引为 row + col，范围是 [0, 2n-2]
        diag1 = [False] * (n * 2 - 1)
        # 布尔数组 diag2：记录副对角线（↙）是否有皇后。索引为 row - col，但由于可能为负数，直接使用原值做索引是错误的，这里其实应该做偏移，但 Python 支持负索引，此处默认负数表示另一端的数组空间
        diag2 = [False] * (n * 2 - 1)

        # 定义内部递归函数 dfs(r)，表示当前正在处理第 r 行
        def dfs(r: int) -> None:
            # 递归终止条件：成功放置 n 个皇后，计数加 1
            if r == n:
                nonlocal res
                res += 1  
                return
            
            # 遍历第 r 行中的所有列 c，ok 表示当前列是否已有皇后
            for c, ok in enumerate(col):
                # 检查当前位置 (r, c) 是否安全：
                # 当前列 c 没有皇后
                # 主对角线 r + c 没有皇后
                # 副对角线 r - c 没有皇后（利用负索引）
                if not ok and not diag1[r + c] and not diag2[r - c]:
                    # 标记当前位置已经放置皇后，更新状态数组
                    col[c] = diag1[r + c] = diag2[r - c] = True
                    # 递归尝试下一行
                    dfs(r + 1)
                    # 回溯：撤销当前位置的皇后放置，恢复状态
                    col[c] = diag1[r + c] = diag2[r - c] = False  

        # 从第 0 行开始回溯搜索
        dfs(0)
        # 返回最终找到的合法解法数量
        return res
```

- 时间复杂度：近似为 `O(n!)`，其中 `n` 是皇后数量
- 空间复杂度：`O(n)`，其中 `n` 是皇后数量，递归调用层数不会超过 `n`，每个棋盘的空间复杂度为 `O(n^2)`

### 思路 2: 位运算 - bitmask

利用位运算进行状态压缩，将列、主对角线、副对角线都用整数的 `bit` 位 表示，显著提升性能
- 每一位代表一列或一条对角线
- 用 `1` 表示“该位上已有皇后”，`0` 表示“可以放”
- 每层递归通过 `bit` 操作筛选合法位置并递归

```python
class Solution:
    def totalNQueens(self, n: int) -> int:
        # 这是核心的递归函数，负责尝试在第 row 行放置皇后
        # row：当前正在放置皇后的行数
        # col：当前哪些列被占用（二进制位为1表示被占）
        # diag1：主对角线 ↘ 被占用的状态（r + c）
        # diag2：副对角线 ↙ 被占用的状态（r - c）
        def solve(row: int, col: int, diag1: int, diag2: int) -> int:
            # 递归终止条件：已放置完 n 行，说明找到了一个合法方案，返回 1
            if row == n:
                return 1
            else:
                # 初始化当前路径下的解法数量
                count = 0
                # 找出当前行中所有可以放皇后的位置
                # (1 << n) - 1：构造一个 n 位的掩码，全为 1（如 n=4 → 0b1111），表示所有列
                # col | diag1 | diag2：将当前所有被占用的位置整合
                # ~(col | diag1 | diag2)：取反得到所有可用位置
                # & ((1 << n) - 1)：确保只有低 n 位有效，避免干扰高位
                # 得到 availablePositions：当前行所有可尝试的位置（bit 为 1 的位置表示可以放皇后）
                availablePositions = ((1 << n) - 1) & (~(col | diag1 | diag2))
                # 枚举所有可放的位置（Low Bit Trick）
                # 只要还有位置可放皇后，就继续尝试
                while availablePositions:
                    # 取出 availablePositions 中最低位的1，即当前可用的最右边一列（这是经典的 low-bit trick，用于提取最低有效位）
                    # 例如：
                    # - availablePositions = 0b10100
                    # - position = 0b00100（右数第3列）
                    position = availablePositions & (-availablePositions)
                    # 清除掉刚刚尝试过的位置，避免重复
                    availablePositions = availablePositions & (availablePositions - 1)
                    # 进入下一行递归
                    # 递归调用说明：
                    # row + 1：下一行
                    # col | position：更新列状态 → 将当前列标记为已占
                    # (diag1 | position) << 1：主对角线需要向左移一位，因为下一行的 ↘ 位置会向左偏
                    # (diag2 | position) >> 1：副对角线向右偏移一位（↙）
                    count += solve(row + 1, col | position, (diag1 | position) << 1, (diag2 | position) >> 1)

                # 返回当前分支下找到的合法解数量
                return count
        
        # 从第 0 行开始，所有状态均为空（即未占用）
        return solve(0, 0, 0, 0)
```