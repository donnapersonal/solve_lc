# 784.字母大小写全排列

题目链接：[784.字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/)

## 题目大意

给定一个字符串 `s`，通过将字符串 `s` 中的每个字母转变大小写，可以获得一个新的字符串

返回所有可能得到的字符串集合，以任意顺序返回输出

```js
Example 1:
Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]

Example 2:
Input: s = "3z4"
Output: ["3z4","3Z4"]
```

限制：
- 1 <= s.length <= 12
- s consists of lowercase English letters, uppercase English letters, and digits.

## 解题

朴素想法：枚举全部再过滤（不实际）
- 对每个字符：如果是字母就有两种选择（原样/大小写翻转），如果是数字就只有一种
- 直接递归/迭代生成全部，再过滤非法情况
- 实际上不用“过滤”，因为规则很明确：数字只有 `1` 条分支，字母有 `2` 条分支，直接生成即可

### 思路 1: 回溯/DFS

思路：
- 从左到右构造答案串 `path`：
  - 若 `s[i]` 是数字：只能走一条分支：把该数字加上去，继续
  - 若 `s[i]` 是字母：走两条分支：`加原样 + 递归`；`加翻转大小写 + 递归`
- 走到末尾（`i == len(s)`）就把 `path` 加入结果
- 时间由字母个数 `m` 决定，分支数为 `2^m`，这是题目的天然下界，方法是最优级别

```js
var letterCasePermutation = function(s) {
    let track = "", res = [];

    const backtrack = function(s, index) {
        if (index == s.length) {
            res.push(track);
            return;
        }

        if ("0" <= s[index] && s.charAt(index) <= "9") {
            // s[index] 是数字
            track += s[index];
            backtrack(s, index + 1);
            track = track.slice(0, -1);
        } else {
            // s[index] 是字母
            // 小写字母，做选择
            track += s[index].toLowerCase();
            backtrack(s, index + 1);
            // 撤销选择
            track = track.slice(0, -1);

            // 大写字母，做选择
            track += s[index].toUpperCase();
            backtrack(s, index + 1);
            // 撤销选择
            track = track.slice(0, -1);
        }
    };

    backtrack(s, 0);
    return res;
};
```
```python
# 写法 1
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        self.track = []
        self.res = []
        self.backtrack(s, 0)
        return self.res
    
    def backtrack(self, s, index):
        if index == len(s):
            self.res.append("".join(self.track))
            return
        
        if "0" <= s[index] <= "9":
            # s[index] 是数字
            self.track.append(s[index])
            self.backtrack(s, index + 1)
            self.track.pop()
        else:
            # s[index] 是字母
            # 小写字母，做选择
            self.track.append(s[index].lower())
            self.backtrack(s, index + 1)
            self.track.pop()
            
            # 大写字母，做选择
            self.track.append(s[index].upper())
            self.backtrack(s, index + 1)
            # 撤销选择
            self.track.pop()

# 写法 2
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        # path：当前构造中的字符串（这里用不可变的字符串，每次递归用拼接生成新串，简单直观）
        res, path = [], ""
        # 从索引 0 开始深度优先搜索构造答案
        self.dfs(s, path, 0, res)
        return res
    
    # 递归函数：
    # - s：原始字符串
    # - path：当前已构造的前缀字符串
    # - i：当前处理到的索引
    # - ans：结果容器（与 res 指向同一对象）
    def dfs(self, s, path, i, ans):
        # 递归终止条件：索引走到末尾，说明一个完整方案生成完毕
        if i == len(s):
            # 把当前构造的字符串加入结果
            ans.append(path)
            # 结束该条递归路径
            return
        
        # 第一条分支：不改变当前字符（无论是数字还是字母，原样加入）
        # 继续处理下一个位置 i+1
        self.dfs(s, path + s[i], i + 1, ans)
        # 如果当前字符是小写字母（利用 ASCII 范围判断，'a'~'z'）
        if ord('a') <= ord(s[i]) <= ord('z'):
            # 第二条分支（字母时才有）：把该小写字母转为大写再加入，并继续递归
            self.dfs(s, path + s[i].upper(), i + 1, ans)
        # 如果当前字符是大写字母（'A'~'Z'）
        elif ord('A') <= ord(s[i]) <= ord('Z'):
            # 第二条分支（字母时才有）：把该大写字母转为小写再加入，并继续递归
            self.dfs(s, path + s[i].lower(), i + 1, ans)
```

- 时间复杂度：`O(n * 2^m)`，`n` 为字符串的长度，其中 `m` 个是字母，`n-m` 个是数字
  - 如果是字母，有两种选择（大写和小写），如果是数字，只有一种选择
  - 每个字母 `2` 种可能 → `O(2^m)`
  - 每次生成一个排列时，需要 `O(n)` 的时间来构建字符串（"".join(self.track)）
- 空间复杂度：`O(n)`，不计入结果空间
  - `O(n)` 递归栈
  - `self.track` 列表在任何时候最多包含 `n` 个字符，占用 `O(n)` 的空间
  - 最终结果 `self.res` 包含所有可能的排列。在最坏情况下（所有字符都是字母），会有 `2^n` 个排列，每个长度为 `n`。因此，`self.res` 占用 `O(n * 2^m)` 的空间

### 思路 2: 位运算

位运算枚举所有组合

观察发现：只有字母会产生分支，每个字母有两个选择（小写或大写）

所以可以：
- 找出字符串中所有是字母的位置
- 用一个整数 `i` 从 `0` 到 `2^k - 1`，每一位的二进制位控制一个字母是小写还是大写
- 每个 `i` 对应一种大小写组合

这种写法是非递归的、常量控制的位掩码枚举法，时间复杂度与 DFS 等价但更直接、可读性强、无栈空间浪费

```python
# 写法 1
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        # 用列表推导式找出所有是字母的位置索引
        # char.isalpha() 判断是否为英文字母（排除数字）
        # 举例：s = "a1b2" → letters = [0, 2]（只关心 'a' 和 'b' 的位置）
        letters = [i for i, char in enumerate(s) if char.isalpha()]
        # 记录字母的数量，后续将枚举 2^n 种大小写组合
        n = len(letters)
        res = []

        # 枚举 0 到 2^n - 1 的所有整数（1 << n 相当于 2^n）
        # 每个整数 i 的二进制位将控制字母的大小写（如：01 表示第一个字母小写，第二个字母大写）
        for i in range(1 << n):
            # 将原始字符串转为字符列表 word，方便后续逐位修改
            # 字符串是不可变的，用列表改写效率更高
            word = list(s)
            # 遍历每个字母的位置（第 j 个字母）
            for j in range(n):
                # 如果 i 的第 j 位是 1：该字母设为大写
                # 用 1 << j 取出第 j 位；与 i 做按位与，判断该位是否为 1
                if i & (1 << j):
                    word[letters[j]] = word[letters[j]].upper()
                else:
                    # 否则（该位为 0）：该字母设为小写
                    word[letters[j]] = word[letters[j]].lower()
            
            # 将修改后的字符列表拼接回字符串，加入结果列表
            res.append(''.join(word))
        
        return res

# 写法 2
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        res = []
        m = sum(c.isalpha() for c in s)
        for mask in range(1 << m):
            t, k = [], 0
            for c in s:
                if c.isalpha():
                    t.append(c.upper() if mask >> k & 1 else c.lower())
                    k += 1
                else:
                    t.append(c)
            res.append(''.join(t))

        return res
```