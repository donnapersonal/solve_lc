# 489.扫地机器人

题目链接：[489.扫地机器人](https://leetcode.cn/problems/robot-room-cleaner/)

## 题目大意

房间中的某个位置上有一个机器人，你需要控制它清扫房间。房间被建模为一个 m x n 的二进制网格，其中 0 表示单元格中有障碍物，1 表示空单元格

机器人从一个未知的空单元格开始出发，并且你无法访问网格，但你可以使用给定的 API Robot 控制机器人

你的任务是使用机器人清扫整个房间（即清理房间中的每个空单元格）。机器人具有四个给定的API，可以前进、向左转或向右转。每次转弯 90 度

当机器人试图移动到一个存在障碍物的单元格时，它的碰撞传感器会检测到障碍物，并停留在当前单元格

设计一个算法，使用下述 API 清扫整个房间：

```js
interface Robot {
  // 若下一个单元格为空，则返回 true ，并移动至该单元格。
  // 若下一个单元格为障碍物，则返回 false ，并停留在当前单元格。
  boolean move();

  // 在调用 turnLeft/turnRight 后机器人会停留在当前单元格。
  // 每次转弯 90 度。
  void turnLeft();
  void turnRight();

  // 清理当前单元格。
  void clean();
}
```

注意 扫地机器人的初始方向向上。你可以假定网格的四周都被墙包围

自定义测试：输入只用于初始化房间和机器人的位置。你需要「盲解」这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用 4 个给出的 API 解决问题

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1ovwxgl32o.webp)

限制:
- m == room.length, n == room[i].length
- 1 <= m <= 100, 1 <= n <= 200
- room[i][j] is either 0 or 1.
- 0 <= row < m, 0 <= col < n
- room[row][col] == 1
- All the empty cells can be visited from the starting position.

## 解题

可以使用`深度优先搜索`来模拟机器人的扫地过程，即顺着当前机器人的朝向一直清扫下去，如果遇到障碍（清扫过的格子也算障碍）则向右转向，直到找到一个没有障碍的朝向（继续进行搜索）或所有的朝向都有障碍（回溯）

整个算法的框架：
- 从起始位置开始，记录当前的位置为 `cell = (0, 0)`，以及机器人的朝向 `direction = 0`
- 将起始位置进行清扫，并进行标记（即清扫过的格子也算作障碍）
- 依次选择四个朝向 `up，right，down，left` 进行深度优先搜索，相邻的两个朝向仅差一次向右旋转的操作
- 对于选择的朝向，检查下一个格子是否有障碍，如果没有则向对应朝向移动一格，并开始新的搜索；如果有则向右旋转
- 如果四个朝向都搜索完毕，则回溯到上一次搜索

```js
```
```python
# """
# This is the robot's control interface.
# You should not implement it, or speculate about its implementation
# """
#class Robot:
#    def move(self):
#        """
#        Returns true if the cell in front is open and robot moves into the cell.
#        Returns false if the cell in front is blocked and robot stays in the current cell.
#        :rtype bool
#        """
#
#    def turnLeft(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def turnRight(self):
#        """
#        Robot will stay in the same cell after calling turnLeft/turnRight.
#        Each turn will be 90 degrees.
#        :rtype void
#        """
#
#    def clean(self):
#        """
#        Clean the current cell.
#        :rtype void
#        """

class Solution:
    def cleanRoom(self, robot):
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        visited = set()

        def go_back():
            robot.turnRight()
            robot.turnRight()
            robot.move()
            robot.turnRight()
            robot.turnRight()

        def backtrack(cell = (0, 0), d = 0):
            visited.add(cell)
            robot.clean()
            # going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'
            for i in range(4):
                new_d = (d + i) % 4
                new_cell = (cell[0] + dirs[new_d][0], cell[1] + dirs[new_d][1])
                
                if not new_cell in visited and robot.move():
                    backtrack(new_cell, new_d)
                    go_back()
                # turn the robot following chosen direction : clockwise
                robot.turnRight()

        backtrack()
```

- 时间复杂度：`O(4^N−M)`，其中 `N` 是房间的大小，`M` 是障碍物的数量
- 空间复杂度：`O(N−M)`