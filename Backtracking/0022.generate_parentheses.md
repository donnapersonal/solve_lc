# 22.括号生成

题目链接：[22.括号生成](https://leetcode.cn/problems/generate-parentheses/)

## 题目大意

数字 `n` 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且有效的括号组合

```js
Example 1:
Input: n = 3
Output: ["((()))","(()())","(())()","()(())","()()()"]

Example 2:
Input: n = 1
Output: ["()"]
```

限制：
- 1 <= n <= 8

## 解题

本题可以改写为：**现在有 `2n` 个位置，每个位置可以放置字符 `(` 或 `)`，组成的所有括号组合中，有多少个是合法的？**

初始思路：暴力枚举所有 `2n` 长度的括号组合
- 枚举出所有长度为 `2n` 的由 `'('` 和 `')'` 构成的字符串，总共是 `2^2n` 种组合
- 再用栈判断哪些组合是合法的
- 问题：时间复杂度太高，很多无效组合白白生成又被过滤，浪费资源

### 思路 1：枚举当前位置填左括号还是右括号

> 本质是「选或不选」的思想，可以把填左括号视作「选」，填右括号视作「不选」

优化思路：使用`回溯 + 剪枝`

关键剪枝条件：
- 左括号的数量不能超过 `n`（因为总共就 `n` 对）
- 右括号的数量不能超过左括号（否则提前闭合了，变成非法）

思路：
- 从空字符串开始，每次选择加入 `(` 或 `)`
- 用两个变量 `left` 和 `right` 表示当前加入的左右括号数
- 当 `len(s) == 2 * n` 时，说明达到了完整的一组括号，加入结果集

```js
var generateParenthesis = function(n) {
    let res = [];
    const backtrack = function(s = '', left = 0, right = 0) {
        if (s.length === 2 * n) {
            res.push(s);
            return;
        }
        if (left < n) backtrack(s + '(', left + 1, right);
        if (right < left) backtrack(s + ')', left, right + 1);
    };
    backtrack();
    return res;
};
```
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 初始化结果列表 res，用于存储所有合法的括号组合
        res = []

        # 定义一个递归函数 dfs，表示当前正在构建的字符串 s，left 是迄今为止使用的左括号的数量、right 是迄今为止使用的右括号的数量
        def dfs(s: str, left: int, right: int) -> None:
            # 检查当前字符串是否已达到长度
            # 因为 n 对括号的有效字符串始终有 2 * n 个字符：n 个左括号和 n 个右括号
            # 当当前字符串长度已经达到 2n，说明已经构建完成一组括号组合，加入结果集
            if len(s) == 2 * n:  
                res.append(s)
                return
            
            # 若仍有左括号可用（left < n），则该函数将左括号添加到当前字符串 s，增加 left 的计数，并递归调用 dfs
            # left + 1，因为增加了一个 (
            if left < n:
                dfs(s + "(", left + 1, right)
          
            # 若到目前为止使用的右括号（右）的数量小于左括号（左）的数量，则该函数将右括号添加到 s，增加右侧计数，并递归调用 dfs
            if right < left:  
                dfs(s + ")", left, right + 1)
        
        # 从空串 "" 开始，初始状态下左右括号都是 0，启动递归
        dfs("", 0, 0) 
        return res
```

- 时间复杂度：`O(4^n / √n)`，有 `4^n / √n` 个叶子节点，每个需要 `O(n)` 时间来处理
  - 递归深度最多达到 `2n`（因为 `n` 对括号，总共 `2n` 个字符）
  - 递归调用次数：
    - 在最坏情况下，算法会生成所有可能的括号组合
    - 卡特兰数 `Cn` 给出了 `n` 对括号的合法组合数
    - `Cn` 的一个上界是 `4^n / (n^(3/2))`
  - 每次递归调用的操作：
    - 添加/删除括号和检查条件的操作是 `O(1)`
    - 但在叶子节点（即找到一个有效组合时），需要 `O(n)` 时间来复制结果
  
  ![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.70anhyge9f.webp)

- 空间复杂度：`O(n)`，返回值的空间不计入
  - 递归栈深度：最大深度为 `2n`，因为最多添加 `n` 个左括号和 `n` 个右括号
  - `track` 列表：在任何时候，`track` 的最大长度为 `2n`
  - 结果列表：存储所有有效组合，每个长度为 `2n`；组合数量为 `Cn`，上界是 `4^n / (n^(3/2))`

### 思路 2

从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的

用 `left` 记录还可以使用多少个左括号，用 `right` 记录还可以使用多少个右括号，就可以直接套用`回溯算法`了

```js
var generateParenthesis = function(n) {
    if (n === 0) return [];
    // 记录所有合法的括号组合
    let res = [];
    // 回溯过程中的路径
    let track = [];

    // 可用的左括号数量为 left 个，可用的右括号数量为 right 个
    const backtrack = function(left, right) {
        // 若左括号剩下的多，说明不合法
        if (right < left) return;
        // 数量小于 0 肯定是不合法的
        if (left < 0 || right < 0) return;
        // 当所有括号都恰好用完时，得到一个合法的括号组合
        if (left === 0 && right === 0) {
            res.push(track.join(''));
            return;
        }

        // 尝试放一个左括号
        // 选择
        track.push('(');
        backtrack(left - 1, right);
        // 撤消选择
        track.pop();

        // 尝试放一个右括号
        // 选择
        track.push(')');
        backtrack(left, right - 1);
        // 撤消选择
        track.pop();
    };

    // 可用的左括号和右括号数量初始化为 n
    backtrack(n, n);
    return res;
};
```
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 特殊处理：当 n = 0 时，应该返回空列表 []，没有括号可以生成
        if n == 0:
            return []
        
        self.res, self.track = [], []
        self.backtrack(n, n)
        return self.res

    def backtrack(self, left, right):
        # 剪枝
        # 若左括号剩下的多，说明不合法
        # 也说明 ) 的数量比 ( 少（即右括号过早出现），导致 ")(" 这种不合法的情况
        if right < left:
            return
        
        # 数量小于 0 肯定是不合法的
        if left < 0 or right < 0:
            return 
        
        # 当所有括号都恰好用完时，得到一个合法的括号组合
        if left == 0 and right == 0:
            self.res.append("".join(self.track))
            return
        
        # 尝试放一个左括号
        # 选择
        # 只有当 left > 0 时，我们才能放 (，代表使用一个左括号
        self.track.append('(')
        # 相当于继续放置下一个括号
        self.backtrack(left - 1, right)
        # 撤消选择
        # 相当于把 ( 撤销，尝试其他选择
        self.track.pop()
        
        # 尝试放一个右括号
        # 选择
        self.track.append(')')
        self.backtrack(left, right - 1)
        # 撤消选择
        self.track.pop()
```

