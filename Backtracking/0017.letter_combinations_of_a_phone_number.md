# 17.电话号码的字母组合

题目链接：[17.电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

## 题目大意

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合，答案可以按`任意顺序`返回

给出数字到字母的映射如下（与电话按键相同），注意 `1` 不对应任何字母

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.58hohcskz8.webp)

```js
Example 1:
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

Example 2:
Input: digits = ""
Output: []

Example 3:
Input: digits = "2"
Output: ["a","b","c"]
```

限制：
- 0 <= digits.length <= 4
- digits[i] is a digit in the range ['2', '9'].

## 解题

回溯是一种尝试所有可能组合的算法，尤其适合生成排列、组合、子集等问题。

回溯核心思想：
- 从左到右“拼接字符串”
- 每一位数字都对应一个字母集合（如 `2 → abc`）
- 每次选择一个字母，递归到下一位
- 若长度等于输入长度，加入结果集
- 回溯一位，再尝试下一个字母

```js
var letterCombinations = function(digits) {
    // 每个数字到字母的映射
    const mapping = [
        "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    ];
    let res = [], str = "";
    if (digits === "") return res;

    const backtrack = function(digits, start) {
        if (str.length === digits.length) {
            res.push(str);
            return;
        }

        let digit = digits.charCodeAt(start) - '0'.charCodeAt(0);
        for (let c of mapping[digit].split("")) {
            str += c;
            backtrack(digits, start + 1);
            str = str.slice(0, -1);
        }
    };

    backtrack(digits, 0);
    return res;
};
```
```python
# 写法 1
class Solution:
    # 静态变量 mapping 是手机键盘数字与字母的对应表：
    # 索引 0、1 不映射任何字符
    # 2–9 映射对应的字母组合
    mapping = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    def __init__(self):  
        # 构造函数中初始化两个变量：
        # - res：用于存储所有有效组合结果
        # - str：当前正在构建的字符串（使用列表比字符串拼接更高效）
        self.res = []
        self.str = []

    def letterCombinations(self, digits: str) -> List[str]:
        # 边界处理：空输入直接返回空列表
        if not digits:
            return self.res
        
        # 调用回溯函数，从索引 0 开始
        self.backtrack(digits, 0)
        # 返回结果集
        return self.res
    
    # 递归回溯函数，用于构建所有组合：参数 digits 是原始字符串；start 表示当前处理第几位数字
    def backtrack(self, digits: str, start: int) -> None:  
        # 递归终止条件：
        # - 如果当前组合的长度已经等于输入数字的长度，说明是一个完整组合
        # - 将当前拼接结果加入结果集并返回
        if len(self.str) == len(digits):
            self.res.append(''.join(self.str))
            return
        
        # 将字符 '2' ~ '9' 转换成对应整数，如 '2' → 2
        # ord 返回字符的 ASCII 编码
        # 差值即为对应数字
        digit = ord(digits[start]) - ord('0')
        # 遍历当前数字对应的所有字母，例如 digit = 2，遍历 "abc"
        for c in self.mapping[digit]:
            # 选择当前字母，加到构建中的组合里
            self.str.append(c)
            # 递归处理下一个数字（下一位）
            self.backtrack(digits, start + 1)
            # 回溯：撤销当前选择，尝试下一个字母
            self.str.pop()

# 写法 2
class Solution:
    def __init__(self):
        self.mapping = [
            "",     # 0
            "",     # 1
            "abc",  # 2
            "def",  # 3
            "ghi",  # 4
            "jkl",  # 5
            "mno",  # 6
            "pqrs", # 7
            "tuv",  # 8
            "wxyz"  # 9
        ]

        self.res = []
    
    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits) == 0:
            return self.res

        self.backtracking(digits, 0, "")
        return self.res
    
    def backtracking(self, digits, index, str):
        if index == len(digits):
            self.res.append(str)
            return

        digit = int(digits[index])
        letters = self.mapping[digit]
        for letter in letters:
            self.backtracking(digits, index + 1, str + letter) 
```

- 时间复杂度：`O(3^m * 4^n)`
  - 其中 `m` 是 `digits` 中对应 `3` 个字母的数字个数，`n` 是 `digits` 中对应 `4` 个字母的数字个数
  - 每个解长度 `O(L)`，存储 `O(3^m * 4^n)` 个解，时间复杂度乘 `O(L)`；但 `L` 是常数级（`≤ 4`），所以常省略
- 空间复杂度：`O(m + n)`
  - 若仅考虑递归栈：`O(m + n)`
  - 完整分析包含 `res` 存储，需 `O(L * 3^m * 4^n)`

**直接覆盖写法**

优化空间的 `DFS` 回溯，该实现是一种更节省内存的方式：
- 使用定长列表 `path = [''] * n` 预分配空间
- 避免使用 `.append() / .pop()`，而是通过覆盖 `path[i] = c` 实现路径更新
- 构建完成后，使用 `''.join(path)` 添加到结果集

> 这是一种更高效的回溯写法，通过预分配字符数组并在原地修改，避免了频繁的 `push/pop` 操作，同时保留了回溯算法的完整性与可读性，是空间友好型的 `DFS` 模板

```python
# 定义手机数字键盘上的数字与字母映射：
# MAPPING[2] = "abc", ..., MAPPING[9] = "wxyz"
# MAPPING[0] 和 MAPPING[1] 是空字符串（无对应字母）
MAPPING = "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        n = len(digits)
        # 获取输入长度 n，如果输入为空，直接返回空列表（无组合可构造）
        if n == 0:
            return []
        
        # 初始化结果列表 res，用于存放所有合法的字母组合
        res = []
        # 预分配一个长度为 n 的字符数组 path，用于构建每个组合
        # 与使用 path = [] + .append()/.pop() 相比，节省内存和函数调用时的复制开销
        path = [''] * n  # 注意 path 长度一开始就是 n，不是空列表

        def dfs(i: int) -> None:
            # 递归终止条件：
            # - 如果已经处理完所有位（i == n），说明构造了一个完整组合
            # - 使用 ''.join(path) 把字符列表转换为字符串，加入结果集
            if i == n:
                res.append(''.join(path))
                return
            
            # 获取当前数字 digits[i] 映射的所有字母，对每个字母进行循环递归处理
            for c in MAPPING[int(digits[i])]:
                # 将当前位填入字符 c
                path[i] = c  # 直接覆盖
                # 递归进入下一位
                dfs(i + 1)
        
        # 从索引 0（第一位数字）开始进行深度优先搜索
        dfs(0)
        return res
```

- 时间复杂度：`O(n4^n)`，其中 `n` 为 `digits` 的长度
  - 最坏情况下每次需要枚举 `4` 个字母，递归次数为一个满四叉树的节点个数，一共会递归 O(4^n) 次（等比数列和）
  - 再算上加入答案时复制 `path` 需要 `O(n)` 的时间，所以时间复杂度为 `O(n4^n)`
  > 另种解释：每一个数字都有（`3−4`）个字符选择，可以算成 `4`；总共有 `n` 个字符，因此有 `4^n` 种选择(状态)， 对于每一种选择（状态），都需要 `O(n)` 的时间 `append` 到 `res`， 因此是 `O(n*4^n)`
- 空间复杂度：`O(n)`，返回值的空间不计
  - 递归栈深度最多为 `n`
  - `path` 长度固定为 `n`
