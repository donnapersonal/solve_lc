# 47.全排列 II

题目链接：[47.全排列 II](https://leetcode.cn/problems/permutations-ii/)

## 题目大意

给定一个可包含重复数字的序列 `nums`，按任意顺序返回所有不重复的全排列`

```js
Example 1:
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]

Example 2:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

限制：
- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10

## 解题

暴力法
- 对 `nums` 做全排列（`n!` 个），再用集合去重
- 问题：重复值会导致重复排列被反复生成，效率糟糕，且需要集合大空间。

回溯 + 访问标记（基础版）
- 用 `used[i]` 标记位置 `i` 的元素是否被用过，构造一条路径 `track`
-0 仍然会生成重复路径（当有相同数字时），需进一步剪枝

`回溯 + 排序 + 本层去重剪枝`
- 先排序，让相同数字相邻
- 回溯时遍历同一层候选时，如果 `nums[i] == nums[i-1]` 且 `nums[i-1]` 在本层未被使用`（!used[i-1]）`，就跳过 `nums[i]`，避免同层重复选择相同的数
- 这条剪枝规则可保证每一层不会因为相同元素而产生重复分支，从源头上杜绝重复排列

解释剪枝条件：
- 在同一层里，如果前一个相同元素 `nums[i-1]` 还没被用，说明“以 `nums[i-1]` 作为本层选择”的那条分支还没被选上，现在直接跳到用 `nums[i]` 会得到相同结构的排列，属于重复
- 只有当 `nums[i-1]` 已被使用（意味着它是在更深层被选走了），再选 `nums[i]` 才不会构成同层重复

> 这个去重策略不会让相同的数字完全被跳过，而是确保相同数字的使用顺序一致，从而避免生成重复的排列

```js
var permuteUnique = function(nums) {
    let res = [], track = []
    let used = new Array(nums.length).fill(false);
    // 先排序，让相同的元素靠在一起
    nums.sort((a, b) => a - b);

    const backtrack = function(nums) {
        if (track.length == nums.length) {
            res.push([...track]);
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue;
            track.push(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.pop();
            used[i] = false;
        }
    };

    backtrack(nums);
    return res;
};
```
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        self.res, self.track = [], []
        # 这是一个与 nums 等长的布尔数组，标记每个元素是否在当前的排列路径中已经被使用，避免重复使用同一个元素
        self.used = [False] * len(nums)

        # 先排序，让相同的元素靠在一起
        # 排序的目的是为了在后续的回溯过程中方便进行剪枝操作，确保相同的元素按照顺序处理，避免重复的排列
        nums.sort()
        # 启动回溯
        self.backtrack(nums)
        # 返回所有不重复排列
        return self.res
    
    def backtrack(self, nums):
        # 当当前路径 self.track 的长度等于 nums 的长度时，说明一个完整的排列已经生成
        if len(nums) == len(self.track):
            self.res.append(self.track[:])
            return
        
        # # 尝试选择每一个位置 i 的元素                 
        for i in range(len(nums)):
            # 如果 nums[i] 在当前的路径中已经被使用过（即 self.used[i] 为 True），就跳过它，避免重复使用同一个元素
            if self.used[i]:
                continue
            
            # 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            # 保证相同元素在排列中的相对位置保持不变
            # 这个剪枝逻辑是关键，用于处理 重复元素 的情况
            # 因为 nums 是有序的，若当前元素与前一个相同且前一个相同的元素还没有被使用过，则说明已经处理过该排列组合（从前一个相同元素开始的排列），因此跳过当前元素，避免生成重复排列
            # 当前的 nums[i] 和前面的 nums[i-1] 相同，但 nums[i-1] 还没有被用过，说明 nums[i-1] 还在列表中，nums[i] 也不应该被用（否则会形成重复排列）
            # 只有当 nums[i-1] 已经被使用时，才允许 nums[i] 被选入路径
            # 核心思想：保证相同的元素按顺序被选取，防止相同的元素在不同递归层次被重新选择，导致重复结果
            if i > 0 and nums[i] == nums[i - 1] and not self.used[i - 1]:
                continue
            
            self.track.append(nums[i])
            self.used[i] = True
            self.backtrack(nums)
            self.track.pop()
            self.used[i] = False

# 写法 2
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        res = []
        track = [0] * n  # 所有排列的长度都是 n
        used = [False] * n  # on_path[j] 表示 nums[j] 是否已经填入排列

        # i 表示当前要填排列的第几个数
        def backtrack(i: int) -> None:
            if i == n:  # 填完了
                res.append(track.copy())  # 也可以写 track[:]
                return
            # 枚举 nums[j] 填入 path[i]
            for j, on in enumerate(used):
                # 如果 nums[j] 已填入排列，continue
                # 如果 nums[j] 和前一个数 nums[j-1] 相等，且 nums[j-1] 没填入排列，continue
                if on or j > 0 and nums[j] == nums[j - 1] and not used[j - 1]:
                    continue
                track[i] = nums[j]  # 填入排列
                used[j] = True  # nums[j] 已填入排列（注意标记的是下标，不是值）
                backtrack(i + 1)  # 填排列的下一个数
                used[j] = False  # 恢复现场
                # 注意 track 无需恢复现场，因为排列长度固定，直接覆盖就行

        backtrack(0)
        return res
```

- 时间复杂度：`O(n * n!)`，生成所有排列所需的时间，包含每次递归遍历的 `O(n)` 时间，通过剪枝减少了无效的递归分支，实际运行时间会因为剪枝而小于这个上界
- s空间复杂度：`O(n)`
  - 需 `O(n)` 的标记数组，同时在递归的时候栈深度会达到 `O(n)`，因此总空间复杂度为 `O(n+n)=O(2n)=O(n)`