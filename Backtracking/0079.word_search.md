# 79.单词搜索

题目链接：[79.单词搜索](https://leetcode.cn/problems/word-search/)

## 题目大意

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.5j4ikmbv96.webp)

限制：
- m == board.length, n = board[i].length
- 1 <= m, n <= 6
- 1 <= word.length <= 15
- board and word consists of only lowercase and uppercase English letters.

## 解题

暴力法
- 可以从每个格子出发，尝试构造出所有可能的路径，看是否能组成目标字符串 `word`
- 但这样效率太低：
  - 每个格子最多能往 `4` 个方向走
  - 每条路径可能重复、冗余
  - 无剪枝机制
- 时间复杂度最差是 `O(4^L * m * n)`，不可接受

回溯法（`Backtracking`）
- 从每个起点出发，尝试一步步匹配字符串的每一个字符
- 若当前字符匹配成功，就尝试四个方向继续搜索下一个字符
- 如果匹配失败，撤销选择（回溯），继续尝试其他路径
- 每个格子只能使用一次，用特殊符号（如 `'#'`）标记访问过的位置，回溯时再还原

```js
var exist = function(board, word) {
    if (!board || board.length === 0 || board[0].length === 0) return false;
    const rows = board.length, cols = board[0].length;

    const backtrack = (r, c, index) => {
        // 如果当前匹配的字符索引等于单词长度，表示找到该单词
        if (index === word.length) return true;

        // 检查是否越界或字符不匹配
        if(r < 0 || c < 0 || r >= rows || c >= cols || board[r][c] !== word[index]) return false;

        // 标记该单元格已被访问
        let tmp = board[r][c];
        board[r][c] = '#';

        // 向四个方向探索
        let found = (backtrack(r + 1, c, index + 1) || // 向下
                     backtrack(r - 1, c, index + 1) || // 向上
                     backtrack(r, c + 1, index + 1) || // 向右
                     backtrack(r, c - 1, index + 1));  // 向左
                     
        // 恢复当前单元格的值（撤销标记）
        board[r][c] = tmp;
        return found;
    };

    // 遍历网格寻找起点
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (backtrack(i, j, 0)) return true;
        }
    }
    return false;
};
```
```python
### 写法 1
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 边界处理：如果 board 是空的，或其中一行为空，则无法搜索，直接返回 False
        if not board or not board[0]:
            return False

        # 保存网格的行数和列数，方便后续判断边界
        self.rows, self.cols = len(board), len(board[0])

        # 定义一个回溯函数，r, c 表示当前搜索位置的行列索引，index 表示当前正在匹配的 word 中第几个字符
        def backtrack(r, c, index):
            # 递归出口：如果已经匹配到了字符串的最后一个字符之后（index == len(word)），说明找到了完整路径，返回 True
            if index == len(word):
                return True
            
            # 剪枝逻辑：
            # - 当前坐标越界，或当前格子的字母与 word[index] 不一致
            # - 则剪枝返回 False
            if r < 0 or c < 0 or r >= self.rows or c >= self.cols or board[r][c] != word[index]:
                return False
          
            # 记录当前字符 tmp，然后将该格子临时标记为 '#'，表示该格子已被访问，防止后续重复使用
            tmp, board[r][c] = board[r][c], '#'
            # 尝试从当前格子的四个方向继续匹配下一个字符，任意一个方向成功即可（用 or）
            res = (backtrack(r + 1, c, index + 1) or  # 向下
                      backtrack(r - 1, c, index + 1) or  # 向上
                      backtrack(r, c + 1, index + 1) or  # 向右
                      backtrack(r, c - 1, index + 1))    # 向左

            # 恢复当前单元格的原始值（撤销标记）
            # 因为要恢复原网格的状态。对于每一个起始点的探索，需要一个全新的、未被修改的原始网格
            board[r][c] = tmp
            # 返回当前路径是否成功找到完整的单词
            return res

        # 从每个起点开始尝试回溯
        # 双重循环，遍历网格中每一个格子，把每个格子都当作起点进行搜索
        # 只要有一个起点可以成功匹配出 word，就立即返回 True
        for i in range(self.rows):
            for j in range(self.cols):
                if backtrack(i, j, 0):
                    return True
        
        # 如果所有起点都试过了，仍然没有找到匹配路径，返回 False
        return False

### 写法 2
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 获取网格的行数 m 和列数 n，用于边界判断
        m, n = len(board), len(board[0])
        # 定义方向数组 dires，表示上下左右四个方向的移动（右、下、左、上）
        # 这有助于简化 DFS 中的方向扩展逻辑
        dires = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # 定义 DFS 函数，从坐标 (i, j) 开始，尝试匹配 word[k:]，返回是否可以匹配成功
        def dfs(i: int, j: int, k: int) -> bool:
            # 终止条件1：当匹配到字符串末尾，说明整个 word 已完全匹配 → 返回 True
            if k == len(word):
                return True
            
            # 终止条件2（剪枝）：
            # - 越界
            # - 当前格子字符 ≠ 目标字符串当前字符
            # 任一情况成立就直接返回 False，表示该路径不合法
            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]:
                return False
            
            # 保存当前格子的值，然后将其标记为 '#' 表示已经访问过，防止走回头路
            temp = board[i][j]
            board[i][j] = '#'  # Mark as visited

            # 从当前格子出发，尝试上下左右四个方向搜索下一个字符（word[k+1]）
            for dx, dy in dires:
                # 只要有一个方向能成功匹配，立即返回 True
                if dfs(i + dx, j + dy, k + 1):
                    return True
            
            # 回溯：如果所有方向都尝试失败了，需要撤销当前选择，把该格子的字符还原为原来的 temp
            board[i][j] = temp 
            # 若四个方向都找不到有效路径，说明当前路径不通，返回 False
            return False
        
        # 使用 any(...)：
        # 对于网格中每一个格子 (i, j) 都尝试作为起点，调用 dfs(i, j, 0) 开始搜索
        # 只要有一个起点可以匹配成功，整体返回 True
        # 如果所有起点都失败 → False
        # 这是 Python 中非常简洁高效的一种写法
        return any(dfs(i, j, 0) for i in range(m) for j in range(n))
```

- 时间复杂度：`O(mn3^k)`，其中 `m` 和 `n` 分别为 `grid` 的行数和列数，`k` 是 `word` 的长度
  - 除了递归入口，其余递归至多有 `3` 个分支（因为至少有一个方向是之前走过的），所以每次递归（回溯）的时间复杂度为 `O(3^k)`，一共回溯 `O(mn)` 次，所以时间复杂度为 `O(mn3^k)`
- 空间复杂度：`O(∣Σ∣+k)`
  - 其中 `∣Σ∣=52` 是字符集合的大小
  - 递归需 `O(k)` 的栈空间
  - 部分语言用的数组代替哈希表，可以视作 `∣Σ∣=128`