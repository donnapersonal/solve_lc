# 491.非递减子序列

题目链接：[491.非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

## 题目大意

给一个整数数组 `nums`，找出并返回所有该数组中不同的递增子序列，递增子序列中`至少有两个元素`，可以按任意顺序返回答案

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况

```js
Example 1:
Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

Example 2:
Input: nums = [4,4,3,2,1]
Output: [[4,4]]
```

限制：
- 1 <= nums.length <= 15
- -100 <= nums[i] <= 100

## 解题

初始暴力解法
- 枚举所有子序列（`2^n` 个），判断每个是否为递增，再用集合去重
- 时间复杂度高达 `O(2ⁿ × n)`，对于数组长度为 `15` 左右就会超时

思路：回溯法 + 去重
- 使用 `回溯/DFS` 枚举所有可能的递增子序列
- 需满足两个条件：
  - 子序列是递增的（当前元素 ≥ 上一个元素）
  - 子序列长度 `≥ 2`
- 同一层使用 `set` 去重，避免在同一递归层中重复选择相同数字

```js
var findSubsequences = function(nums) {
    const res = [], path = [];

    const dfs = (start) => {
        let n = path.length;
        if (n >= 2) res.push([...path]);
        const used = new Set();
        for (let i = start; i < nums.length; i++) {
            if ((n && nums[i] < path[n - 1]) || used.has(nums[i])) continue;
            used.add(nums[i]);
            path.push(nums[i]);
            dfs(i + 1);
            path.pop(); // 回溯
        }
    };

    dfs(0);
    return res;
};
```
```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        # res: 用于保存最终所有合法子序列的结果集
        # path: 当前正在构建的递增子序列路径
        res, path = [], []

        # 定义回溯函数 dfs(start)，表示从 nums[start] 开始尝试构建递增子序列
        def dfs(start):
            n = len(path)
            # 如果当前路径 path 的长度 ≥ 2，则将它复制一份加入结果集（用切片复制避免引用问题）
            if n >= 2:
                res.append(path[:])
            
            # 用于当前递归层去重：避免在同一层（即同一父节点下）选择重复的数字
            used = set() 
            # 遍历当前层的所有候选数字，从 start 到数组末尾
            for i in range(start, len(nums)):
                # 过滤掉不合法的选择：
                # - nums[i] < path[-1]：不是递增序列
                # - nums[i] in used：该层已经选过该数字，避免重复子序列s
                if (path and nums[i] < path[-1]) or nums[i] in used:
                    continue
                
                # 标记当前数字已经被本层使用过
                used.add(nums[i])
                # 做选择：将当前数字加入路径
                path.append(nums[i])
                # 递归进入下一层：从下一个位置开始选择
                dfs(i+1)
                # 回溯：撤销选择，为了尝试其他分支
                path.pop() 

        # 从索引 0 开始执行回溯  
        dfs(0)
        # 返回最终结果集
        return res
```

- 时间复杂度：`O(2^n * n)`，仍然需对子序列做二进制枚举，枚举出的序列虽然省去了判断合法性和哈希的过程，但仍然需 `O(n)` 的时间添加到答案中
- 空间复杂度：`O(n)`，这里临时数组的空间代价是 `O(n)`，递归使用的栈空间的空间代价也是 `O(n)`