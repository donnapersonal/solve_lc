# 473.火柴拼正方形

题目链接：[473.火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)

## 题目大意

你将得到一个整数数组 `matchsticks`，其中 `matchsticks[i]` 是第 `i` 个火柴棒的长度。你要用所有的火柴棍拼成一个正方形

你不能折断任何一根火柴棒，但你可以把它们连在一起，且每根火柴棒必须使用一次 

如果你能使这个正方形，则返回 `true`，否则返回 `false` 

```js
Example 1:
Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

Example 2:
Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
```

限制：
- 1 <= matchsticks.length <= 15
- 1 <= matchsticks[i] <= 10^8

## 解题

目标：
- 正方形有 `4` 条边，所有火柴的总长度 `sum` 必须是 `4` 的倍数，否则直接返回 `False`
- 目标就是把火柴分成 `4` 组子集，每组的总和都等于 `sum // 4`

初始思路：子集枚举（NP 问题）
- 枚举所有分组方式，分成 `4` 组，看每组是否等于 `target`
- 时间复杂度指数级，`TLE`

改进思路：回溯 + 剪枝 + 优化排序
- 把火柴按从大到小排序，依次尝试把第 `i` 根火柴放到 `4` 条边的某一条上，只要不超过 `target` 就可以放，然后继续递归

关键优化点：
- 排序：先放最长火柴，能更快触发剪枝，减少搜索量
- 剪枝 1：如果某一边为 `0`，还失败了，说明这个分支无解，直接 `break`
- 剪枝 2：如果当前边放不下当前火柴，就跳过

```js
var makesquare = function(matchsticks) {
    const total = matchsticks.reduce((a, b) => a + b, 0);
    if (total % 4 !== 0) return false;

    const target = total / 4;
    matchsticks.sort((a, b) => b - a); // 优化：从长到短
    const sides = new Array(4).fill(0);

    const dfs = (index) => {
        if (index === matchsticks.length) {
            return sides.every(side => side === target);
        }

        for (let i = 0; i < 4; i++) {
            if (sides[i] + matchsticks[index] <= target) {
                sides[i] += matchsticks[index];
                if (dfs(index + 1)) return true;
                sides[i] -= matchsticks[index];
            }

            // 剪枝：如果当前边是空的，试一次失败后不再试其他空边
            if (sides[i] === 0) break;
        }

        return false;
    };

    return dfs(0);
};
```
```python
class Solution:
    def makesquare(self, matchsticks: List[int]) -> bool:
        total = sum(matchsticks)
        # 预处理：如果所有火柴总长度不是 4 的倍数，肯定拼不出正方形，直接返回 False
        if total % 4 != 0:
            return False
        
        # 计算每条边的目标长度
        target = total // 4
        # 优化点 1：先放大的火柴，更容易早早失败从而剪枝加速
        matchsticks.sort(reverse=True)
        # 用于保存当前 4 条边的长度，初始为 0
        sides = [0] * 4 

        # 定义递归函数 dfs(index)，表示当前正在处理第 index 根火柴
        def dfs(index):
            # 递归出口：当所有火柴都放完了，检查每条边是否都等于 target
            if index == len(matchsticks):
                return all(side == target for side in sides)
            
            # 尝试将当前火柴放入四条边中的一条
            for i in range(4):
                # 只考虑可以放下的边（当前边长 + 火柴长度 ≤ target）
                if sides[i] + matchsticks[index] <= target:
                    # 放入这条边
                    sides[i] += matchsticks[index]
                    # 递归处理下一根火柴。如果后续成功，就立即返回 True
                    if dfs(index + 1):
                        return True
                    # 撤销选择，回溯  
                    sides[i] -= matchsticks[index]
                
                # 剪枝优化点：如果当前边是 0（还没放过火柴），却失败了，就别尝试其它同为 0 的边了，因为等价
                if sides[i] == 0:
                    break
            
            # 如果所有边都试了仍然无法拼出正方形，返回 False
            return False
        # 从第 0 根火柴开始 dfs
        return dfs(0)
```

- 时间复杂度：`O(4^n)`，其中 `n` 是火柴的数目
  - 每根火柴都可以选择放在 `4` 条边上，因此时间复杂度为 `O(4^n)`
  - 实际复杂度在剪枝后远小于 `4^n`
- 空间复杂度：`O(n)`，递归栈需要占用 `O(n)` 的空间