# 93.复原 IP 地址

题目链接：[93.复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

## 题目大意

有效 `IP` 地址正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔

例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是有效 `IP` 地址，但 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 无效 `IP` 地址

给定一个只包含数字的字符串 `s`，用以表示一个 `IP` 地址，返回所有可能的有效 `IP` 地址，这些地址可以通过在 `s` 中插入 `'.'` 来形成，你不能重新排序或删除 `s` 中的任何数字，你可以按`任何`顺序返回答案

```js
Example 1:
Input: s = "25525511135"
Output: ["255.255.11.135","255.255.111.35"]

Example 2:
Input: s = "0000"
Output: ["0.0.0.0"]

Example 3:
Input: s = "101023"
Output: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

限制：
- 1 <= s.length <= 20
- s consists of digits only.

## 解题

暴力尝试：
- 枚举所有可能分割的三处位置，把字符串分成四段，判断每段是否合法
- 复杂度高，代码冗长，不易扩展

### 思路 1

回溯法 + 剪枝优化：
- 将问题转化为在字符串中寻找 `3` 个切割点，使得分成的四段是合法的 `IP` 段
- 优化策略：
  - 使用 `回溯法` 枚举所有可能的切割路径
  - 利用 `isValid` 函数对每个切出来的 `IP` 段进行判断
  - 当路径中已有 `4` 段，若字符串也刚好用完，就加入结果；否则剪枝

```js
var restoreIpAddresses = function(s) {
    let res = [], track = [];
    const backtrack = function(s, start) {
        if (start == s.length && track.length == 4) {
            res.push(track.join("."));
            return;
        }
        for (let i = start; i < s.length; i++) {
            if (!isValid(s, start, i)) continue;
            // 已经分解成 4 部分了，不能再分解了
            if (track.length >= 4) break;
            track.push(s.substring(start, i + 1));
            backtrack(s, i + 1);
            track.pop();
        }
    };

    const isValid = function(s, start, end) {
        let len = end - start + 1;
        if (len === 0 || len > 3) return false;
        if (len === 1) return true;
        if (s[start] === '0') return false;
        if (len <= 2) return true;

        // 现在输入的一定是三位数
        if (parseInt(s.substring(start, start + len)) > 255) {
            // 不可能大于 255
            return false;
        } else {
            return true;
        }
    };

    backtrack(s, 0);
    return res;
};
```
```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        # res: 最终结果列表，保存所有合法 IP
        # track: 当前递归路径下形成的 IP 段
        res, track = [], []

        def backtrack(s, start):
            # 获取 s 长度与当前路径中段的数量（便于剪枝）
            slen = len(s)
            trackLen = len(track)

            # 终止条件：
            # 当前刚好切到了字符串末尾，且路径上已有 4 段
            # 把当前路径组合成 IP 地址并加入结果
            if start == slen and trackLen == 4:
                res.append('.'.join(track))
            
            # 尝试从当前位置开始往后切 1~3 位字符
            for i in range(start, slen):
                # 剪枝：如果当前段不合法，则跳过
                if not self.isValid(s, start, i):
                    continue

                # 剪枝：若已有 4 段，就不能再往路径中添加新段
                if trackLen >= 4:
                    break
                
                # 选择：将 s[start:i+1] 这一段加入路径
                track.append(s[start:i + 1])
                # 递归：继续从下一个位置开始尝试切割
                backtrack(s, i + 1)
                # 回溯：撤销刚才的选择
                track.pop()
        
        # 从字符串的起点 0 开始进行回溯
        backtrack(s, 0)
        # 返回所有合法 IP 组成的结果列表
        return res
    
    # IP 段合法性判断函数
    # 检查从 s[start:end+1] 这一段是否构成合法 IP 段
    def isValid(self, s: str, start: int, end: int) -> bool:
        length = end - start + 1
        # 空段或长度 >3，非法
        if length == 0 or length > 3:
            return False
        
        # 长度为 1：合法
        if length == 1:
            return True
        
        # 多位数不能以 '0' 开头，如 "01", "00" 等非法
        if s[start] == '0':
            return False
        
        # 长度为 2 的非 0 开头是合法的
        if length <= 2:
            return True
        
        # 长度为 3 时，数值不能超过 255
        if int(s[start:start + length]) > 255:
            return False
        
        # 其余情况合法
        return True
```

- 时间复杂度: `O(3^4 * |s|)`，其中 `|s|` 是字符串 `s` 的长度
  - 由于 `IP` 地址的每一子段位数不会超过 `3`，因此在递归时，最多只会深入到下一层中的 `3` 种情况
  - 而 `IP` 地址由 `4` 个子段构成，所以递归的最大层数为 `4` 层，则递归的时间复杂度为 `O(3^4)`
  - 而每次将有效的 `IP` 地址添加到答案数组的时间复杂度为 `|s|`
  - 所以总的时间复杂度为 `3^4 * |s|`
- 空间复杂度: `O(|s|)`，只记录除了用来存储答案数组之外的空间复杂度

### 思路 2

核心想法：
- 从左到右尝试切分字符串，切成 `4` 段
- 每一段可以是长度 `1` 到 `3` 的子串
- 若当前切出的子串不是合法 `IP` 段（例如大于 `255` 或有前导 `0`），就剪枝
- 若正好切出 `4` 段，且用了所有字符，就加入结果

```js
var restoreIpAddresses = function(s) {
    const res = [];
    const backtrack = (start = 0, track = []) => {
        if (track.length === 4) {
            if (start === s.length) {
                res.push(track.join('.'));
            }
            return;
        }

        for (let i = 1; i <= 3; i++) {
            if (start + i > s.length) break;

            const part = s.substring(start, start + i);

            if ((part.startsWith('0') && part.length > 1) || Number(part) > 255) {
                continue;
            }

            backtrack(start + i, [...track, part]);
        }
    };
    backtrack();
    return res;
};
```
```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []

        def backtrack(start=0, track=[]):
            # 终止条件：如果已经有 4 个段
            # - 如果 start 已到字符串末尾，说明正好分完 → 组合成 IP 地址加入结果
            # - 否则说明字符没用完但段数已满 → 非法 → 返回
            if len(track) == 4:
                if start == len(s):
                    res.append('.'.join(track))
                return
            
            # 每次尝试从 start 开始切 1 到 3 个字符作为当前段
            for i in range(1, 4):
                # 越界判断：避免 s[start:start+i] 索引越界
                if start + i > len(s):
                    break
                
                # 当前尝试的子字符串 part
                part = s[start:start+i]
                # 合法性判断（剪枝）：
                # - "01"、"00" 这类带前导 0 的段非法
                # - part > 255 超出合法 IP 范围，也非法
                # 不合法就 continue 跳过该切割方案
                if (part.startswith("0") and len(part) > 1) or int(part) > 255:
                    continue
                
                # 核心递归：
                # - 向前推进 i 位
                # - track + [part] 是一种 不破坏原路径的方式 来添加新段（相比 append/pop 更安全）
                # 回溯自动在每层函数结束时销毁局部 track，无需手动 pop
                backtrack(start + i, track + [part])
        
        # 从索引 0 开始递归；返回最终所有合法 IP 地址结果
        backtrack()
        return res
```

