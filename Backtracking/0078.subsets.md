# 78.子集

题目链接：[78.子集](https://leetcode.cn/problems/subsets/)

## 题目大意

给一个整数数组 `nums`，数组中的元素互不相同，返回该数组所有可能的子集（幂集）

解集不能包含重复的子集，可以按`任意顺序`返回解集s

```js
Example 1:
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

Example 2:
Input: nums = [0]
Output: [[],[0]]
```

限制：
- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10
- All the numbers of nums are unique.

## 解题

暴力枚举所有组合（二进制映射）
- 数组长度为 `n`，子集总共有 `2^n` 种
- 使用位掩码枚举所有子集（共 `2^n` 个），将每个子集映射为一个 `n` 位的二进制数，`0` 表示不选，`1` 表示选
- 对于每个 `0` 到 `2^n - 1` 的数字，将其转换为子集
- 缺点：实现复杂；可读性差；不适合处理有约束的问题（如组合和、去重、大小限制）

每个元素都有两个选择：`选它/不选它`

用`递归`从头到尾扫描整个数组，对于每个元素做这两个决策，每个分支都是一个有效子集，直到递归结束就将当前路径加入结果集

这个思路等价于一棵二叉决策树，总共有 `2^n` 条路径，刚好是所有子集

优点：
- 更具通用性，可以适用于组合、排列、子集等变体题
- 便于剪枝和扩展逻辑

### 思路 1: 枚举选哪个（答案的视角）

```js
var subsets = function(nums) {
    let res = [], track = [];
    const backTrack = function(nums, start) {
        res.push([...track]);
        for (let i = start; i < nums.length; i++) {
            track.push(nums[i]);
            backTrack(nums, i+1);
            track.pop();
        }
    };
    backTrack(nums, 0);
    return res;
};
```
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # self.res 用来存放最终的所有子集
        # self.track 是当前路径（表示某一个子集）
        self.res, self.track = [], []
        # 从索引 0 开始，递归选择每个元素是否加入当前路径
        self.backtrack(nums, 0)
        return self.res
    
    def backtrack(self, nums, start):
        # 将当前路径上的子集添加到结果中（注意是复制的方式）
        # 这是因为在 Python 中，列表是可变对象（mutable object），如果直接将列表 self.track 添加到结果列表 self.res 中（例如：self.res.append(self.track)）
        # 则在后续对 self.track 的任何修改都会影响到 self.res 中已经存储的结果
        self.res.append(self.track[:])
        n = len(nums)
        # 没有 return 的递归终止条件是因为 for 循环控制了范围，start > n 其实不会发生（最多是 start == n）
        if start > n:
            return
        
        # 每次从 start 位置开始遍历而不是从 0 位置开始遍历就是为了避免重复
        # 集合跟全排列不一样，子集中 {1, 2} 和 {2, 1} 是等价的
        for i in range(start, n):
            # 选择元素：将其添加到当前子集数组 path 中
            self.track.append(nums[i])
            # 递归搜索：在选择该元素的情况下，继续递归考虑下一个位置上的元素
            # 这里的递归是基于“选择当前元素 nums[i]”的情况下，继续生成包含该元素的子集
            self.backtrack(nums, i+1)
            # 通过回溯，可以还原到上一步的状态，继续生成其他可能的子集组合
            self.track.pop()
```

- 时间复杂度：`O(n * 2^n)`
  - 对于长度为 `n` 的输入数组，总共有 `2^n` 个子集（包括空集和全集）
  - 对于每个子集，需要 `O(n)` 的时间来复制 `self.track` 到结果列表中
- 空间复杂度
  - 递归调用栈的最大深度为 `n`，占用 `O(n)` 的空间
  - `self.track` 在最坏情况下可能包含所有 `n` 个元素，占用 `O(n)` 的空间
  - `self.res` 包含所有 `2^n` 个子集，每个子集平均长度为 `n/2`，因此占用 `O(n * 2^n)` 的空间

### 思路 2: 选或不选（输入的视角）

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # 获取数组长度，递归时用到
        n = len(nums)
        # res: 存放最终的所有子集结果
        # track: 当前递归路径，即当前构造中的子集
        res = []
        track = []

        # 定义一个递归函数 backtrack(i)，表示当前正在决策是否选第 i 个元素
        def backtrack(i: int) -> None:
            # 递归终止条件：已经走到了数组末尾
            # 说明这个分支已经形成了一个完整子集，将其加入 res
            # 用 copy() 是为了保存当前状态的副本，否则后续回溯会修改原路径
            if i == n:  
                res.append(track.copy())  # 复制 path，也可以写 path[:]
                return
                
            # 不选 nums[i]
            # 第一种选择：跳过当前元素 nums[i]，继续决策下一个元素
            # 此时 track 不变
            backtrack(i + 1)
            
            # 选 nums[i]
            # 第二种选择：选择当前元素，将其加入路径 track
            # 递归调用下一个元素
            # 然后回溯：撤销上一步选择（pop），为其他分支恢复现场
            track.append(nums[i])
            backtrack(i + 1)
            track.pop() 
        
        # 从索引 0 开始递归；返回所有子集
        backtrack(0)
        return res
```

- 时间复杂度：`O(n × 2^n)`
  - 总共有 `2^n` 个子集
  - 每个子集最多有 `n` 个元素，复制路径 `track` 也要 `O(n)` 时间
- 空间复杂度：`O(n)`
  - 最多递归 `n` 层
  - `track` 最长为 `n`
  - 不计输出所占空间