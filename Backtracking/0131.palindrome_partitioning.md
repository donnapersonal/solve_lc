# 131.分割回文串

题目链接：[131.分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

## 题目大意

给一个字符串 `s`，请将 `s` 分割成一些子串，使每个子串都是`回文串`，返回 `s` 所有可能的分割方案

```js
Example 1:
Input: s = "aab"
Output: [["a","a","b"],["aa","b"]]

Example 2:
Input: s = "a"
Output: [["a"]]
```

限制：
- 1 <= s.length <= 16
- s contains only lowercase English letters.

## 解题

暴力解法
- 尝试所有可能的切割方式，再逐一判断每组是否是回文
- 组合数为指数级，效率极低

回溯（Backtracking）+ 剪枝优化

**写法 1**
- 将问题看成：从左往右尝试每一个可能的切割点，只在满足回文的情况下递归
- 核心思路：
  - 每次从 `start` 开始遍历字符串
  - 尝试切出子串 `s[start:i+1]`
  - 如果是回文，则加入路径中，继续从 `i+1` 开始切
  - 直到切完为止，将路径加入结果

**写法 2**

思路：
- 利用 `DFS` 遍历所有可能的切割路径
- 在切每一段时就判断是否是回文串：
  - 是 → 递归继续
  - 否 → 剪枝，跳过该路径
- 当遍历到字符串结尾，说明形成一个完整方案，记录下来

```js
var partition = function(s) {
    let res = [], track = [];
    const backtrack = function(s, start) {
        if (s.length == start) {
            res.push([...track]);
            return;
        }

        for (let i = start; i < s.length; i++) {
            if (!isPalindrome(s, start, i)) continue;
            track.push(s.substring(start, i+1));
            backtrack(s, i+1);
            track.pop();
        }
    };

    backtrack(s, 0);
    return res;
};

var isPalindrome = function(s, l, h) {
    while (l < h) {
        if (s.charAt(l) != s.charAt(h)) {
            return false;
        }
        l++;
        h--;
    }
    return true;
};
```
```python
# 写法 1
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        # self.res: 用于存储所有合法的结果（二维列表）
        # self.track: 当前路径下的回文划分（如 ["a", "a"]）
        self.res, self.track = [], []
        # 从索引 0 开始回溯
        self.backtrack(s, 0)
        return self.res

    # 定义递归函数，从索引 start 开始进行回文划分尝试
    def backtrack(self, s, start):
        n = len(s)
        # 递归终止条件：如果已经切到字符串末尾，则当前路径是完整方案；将当前路径复制加入结果列表
        if start == n:
            self.res.append(self.track[:])
            return
        
        # 尝试从 start 开始，向后切分每一个子串 s[start:i+1]
        for i in range(start, n):
            # 剪枝优化：如果当前子串不是回文，跳过本次尝试
            if not self.isPalindrome(s, start, i):
                continue
            
            # 选择当前回文段，加入路径
            self.track.append(s[start:i+1])
            # 递归进入下一段切割，从 i+1 开始
            self.backtrack(s, i+1)
            # 回溯：撤销上一步的选择，尝试其他分割方式
            self.track.pop()
    
    # 判断字符串 s[l:h+1] 是否为回文串
    def isPalindrome(self, s, l, h):
        # 左右指针法逐步向中间移动，只要左右字符不等就直接返回 False
        while l < h:
            if s[l] != s[h]:
                return False
            
            l += 1
            h -= 1
        
        # 全部字符匹配，说明是回文串，返回 True
        return True

# 写法 2
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        n = len(s)
        res = []
        path = []

        # 定义内部 DFS 函数，参数 i 表示当前切割起点
        def dfs(i: int) -> None:
            # 终止条件：
            # - 若 i 达到字符串末尾（i == n），说明当前路径是完整切割方案
            # - 将 path 深拷贝加入 res
            if i == n:  
                res.append(path.copy())  
                return
            
            # 从当前起点 i 向后尝试每一个可能的终点 j，形成子串 s[i:j+1]
            for j in range(i, n):  
                # 取出子串 t，从索引 i 到 j
                t = s[i: j + 1]  
                # 判断是否是回文串：
                # - 利用 Python 的切片反转技巧：t[::-1]
                # - 若正反相同，即为回文
                if t == t[::-1]: 
                    # 若是回文：
                    # - 将当前子串加入路径
                    # - 递归从下一个起点 j+1 继续
                    # - 回溯时撤销选择，尝试其他切割方式
                    path.append(t)
                    dfs(j + 1)
                    path.pop()  
        
        # 从索引 0 开始 DFS；返回结果列表 res
        dfs(0)
        return res
```

- 时间复杂度：`O(n * 2^n)`
  - isPalindrome 方法：最坏情况下需比较字符串的一半长度；单次调用的时间复杂度为 `O(n)`，`n` 是子串的长度
  - backtrack 方法：这是一个回溯算法，最坏情况下会生成所有可能的分割。对于长度为 `n` 的字符串，有 `2^(n-1)` 种可能的分割方式，每次分割都需调用 `isPalindrome` 来检查
- 空间复杂度：不计入结果所占空间时是 `O(n)`，否则 `O(n * 2^n)`
  - 递归调用栈：最深的递归深度为字符串的长度 `n`，空间复杂度: `O(n)`
  - `self.res` 存储所有有效的分割结果，在最坏情况下，可能有 `2^(n-1)` 种分割；`self.track` 在任何时候最多存储 `n` 个字符串