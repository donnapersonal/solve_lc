# 51.N 皇后

题目链接：[51.N 皇后](https://leetcode.cn/problems/n-queens/)

## 题目大意

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子

`n` 皇后问题研究的是如何将 `N` 个皇后放置在 `n×n` 的棋盘上，且使皇后彼此之间不能相互攻击

给一个整数 `n`，返回所有不同的 `n` 皇后问题的解决方案

每种解法包含一个不同的 `n` 皇后问题的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.1vyz8ncdmf.webp)

限制：
- 1 <= n <= 9

## 解题

暴力解法：
- 枚举棋盘上所有的 `n` 个位置组合
- 对每种组合检查是否合法
- 时间复杂度极高：组合数量是指数级别（`C(n², n)`）

### 思路 1: 回溯

**写法 1：回溯 + 剪枝**
思路：
- 一行一行地尝试摆放皇后
- 每次选择当前行的一个合法位置放置皇后，然后进入下一行
- 如果当前行没有可选位置，则返回上一层（回溯）
- 使用辅助函数判断当前位置是否有效（不会被已有皇后攻击）

这个方法利用了「每行只能放一个皇后」的性质，降低了组合数量；且通过对列、主对角线、副对角线的合法性判断，大大剪枝

**写法 2：回溯 + 位置信息标记优化**
思路：
- 按“行”从上到下依次放置皇后
- 每行选择一个“安全”的列
- 使用辅助数组记录哪些 列、主对角线、副对角线 被占用
- 通过状态记录实现快速判断，无需每次遍历全棋盘（相比朴素版 `isValid` 有效剪枝）

```js
var solveNQueens = function(n) {
    let res = [];
    let board = Array.from({length: n}, () => '.'.repeat(n));

    const isValid = function(board, row, col) {
        // 检查列是否有皇后互相冲突
        for (let i = 0; i <= row; i++) {
            if (board[i][col] === 'Q') return false;
        }

        // 检查右上方是否有皇后互相冲突
        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] === 'Q') return false;
        }

        // 检查左上方是否有皇后互相冲突
        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }

        return true;
    };

    const backtrack = function(board, row) {
        // 触发结束条件
        if (row == board.length) {
            res.push(board.slice());
            return;
        }

        for (let col = 0; col < n; col++) {
            if (!isValid(board, row, col)) continue;
            board[row] = board[row].slice(0, col) + "Q" + board[row].slice(col + 1);
            backtrack(board, row + 1);
            board[row] = board[row].slice(0, col) + '.' + board[row].slice(col + 1);
        }
    };
    backtrack(board, 0);
    return res;
};
```
```python
# 写法 1
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        # 用于存放所有合法的棋盘布局解法（最终返回）
        self.res = []
        # 初始化空棋盘，每个位置默认是 "."，表示没有皇后
        board = [["." for _ in range(n)] for _ in range(n)]
        # 从第 0 行开始进行回溯搜索
        self.backtrack(board, 0)
        return self.res
    
    # 定义回溯函数，参数为当前棋盘 board 和当前处理的行号 row
    def backtrack(self, board: List[List[str]], row: int) -> None:
        # 当 row 等于 n，表示所有皇后都成功放置，将当前棋盘作为一组解加入结果中
        if row == len(board):
            self.res.append(["".join(row) for row in board])
            return 
        
        # 遍历当前行的每一列，尝试放置皇后
        for col in range(len(board[row])):
            # 调用辅助函数判断 (row, col) 是否是合法位置，如果不合法则跳过
            if not self.isValid(board, row, col):
                continue
            
            # 在 (row, col) 位置放置皇后
            board[row][col] = "Q"
            # 递归进入下一行进行搜索
            self.backtrack(board, row + 1)
            # 撤销选择（回溯），清除该位置的皇后
            board[row][col] = "."
    
    # 辅助函数，用于判断 (row, col) 是否可以放皇后
    def isValid(self, board: List[List[str]], row: int, col: int) -> bool:
        n = len(board)
        # 检查列方向是否已有皇后
        for i in range(row + 1):
            if board[i][col] == "Q":
                return False
        
        # 假设正在第 row 行放置皇后，当前行以下的行还没有放置皇后，所以不可能与当前皇后冲突
        # 这是为什么在检查对角线时，只需检查上方的对角线即可，即左上对角线和右上对角线
        # 检查右上方是否有皇后互相冲突
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
            if board[i][j] == "Q":
                return False
        
        # 检查左上方斜线方向是否有皇后
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == "Q":
                return False
        
        # 如果三个方向都没有冲突，返回 True 表示合法
        return True

# 写法 2
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        # 用于收集所有合法的结果
        res = []
        # queens[i] = j 表示第 i 行的皇后放在第 j 列。用于构造最终输出格式
        queens = [0] * n 
        # 记录每一列是否被皇后占用
        col = [False] * n
        # 记录主对角线 row + col 是否被占用。共有 2n - 1 条主对角线
        diag1 = [False] * (n * 2 - 1)
        # 记录副对角线 row - col 是否被占用。由于可能出现负数，为了防止下标越界，统一偏移为非负
        diag2 = [False] * (n * 2 - 1)
        # 定义递归函数，r 表示当前正在尝试放皇后的行数
        def dfs(r: int) -> None:
            # 递归终止条件：所有行都已成功放置皇后
            if r == n:
                # 根据 queens 中存储的列信息，构造当前棋盘状态，将其加入结果中
                res.append(['.' * c + 'Q' + '.' * (n - 1 - c) for c in queens])
                return
            
            # 遍历所有列的位置，c 是当前列，ok 是该列是否已被占用
            for c, ok in enumerate(col):
                # 只有当当前列、主对角线、副对角线都未被占用时，才考虑放置皇后
                if not ok and not diag1[r + c] and not diag2[r - c]: 
                    # 记录第 r 行皇后放置在第 c 列
                    queens[r] = c 
                    # 将当前列与对应的两个对角线标记为已占用
                    col[c] = diag1[r + c] = diag2[r - c] = True 
                    # 递归搜索下一行
                    dfs(r + 1)
                    # 回溯：撤销本次选择，恢复占用标记
                    col[c] = diag1[r + c] = diag2[r - c] = False  
        dfs(0)
        return res
```

- 时间复杂度：`O(n!)`
  - 主要的时间消耗来自于回溯过程（`backtrack` 函数）
  - 在最坏情况下，算法需要尝试所有可能的放置方式
    ```js
    第一行有 n 种选择
    第二行最多有 n-1 种选择
    第三行最多有 n-2 种选择
    ... 以此类推
    ```
  - 这形成了一个决策树，其中每个节点最多有 `n` 个子节点，树的深度为 `n`
  - 对于每次尝试，`isValid` 函数需 `O(n)` 的时间来检查是否有冲突，因为需检查当前列、左上方和右上方的三个方向，最多需要扫描 `n` 个元素
  - 因此，总体的时间复杂度是：`O(n!×n)`，由于 `n!` 已经是一个非常快增长的函数，因此通常将时间复杂度简化为 `O(n!)`
- 空间复杂度：`O(n^2)`
  - 递归调用栈的深度为 `n`，每层递归中使用的额外空间是常数级的
  - `board` 数组占用 `O(n^2)` 的空间
  - 结果列表 `self.res` 在最坏情况下可能存储所有可能的解，但这不影响渐进空间复杂度
  - 因此，主要的空间消耗来自于 `board` 和递归调用栈

### 思路 2：位运算

思路：使用整数的二进制表示位掩码（bitmask）
- 将每一列、对角线都用一个整数的二进制位来表示状态
- 例如 `cols = 001001010` 表示第 `1`、第 `3`、第 `6` 列已被占用
- 通过按位与/或/非等操作快速判断和更新状态，显著减少空间占用和计算时间

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        # self.res 存放所有合法结果
        self.res = []
        self.n = n
        # 调用回溯函数 backtrack，初始从第 0 行开始，所有位掩码都为 0，queens 为空列表
        self.backtrack(0, 0, 0, 0, [])
        return self.res
    
    # 定义回溯函数：
    # row：当前正在放皇后的行号
    # cols：表示哪些列已放皇后
    # diag1：主对角线（↘）冲突标记（row + col 相等）
    # diag2：副对角线（↙）冲突标记（row - col 相等）
    # queens：记录每行皇后所放的列索引
    def backtrack(self, row: int, cols: int, diag1: int, diag2: int, queens: list):
        # 递归终止条件：如果当前行等于 n，说明所有皇后都已成功放置
        # 使用列表推导式将 queens 中记录的列索引转为字符串棋盘形式，如：".Q.."
        if row == self.n:
            self.res.append(["." * col + "Q" + "." * (self.n - col - 1) for col in queens])
            return
        
        # 这一句是位运算的核心：
        # - (1 << n) - 1：生成一个低 n 位全为 1 的掩码
        # - ~(cols | diag1 | diag2)：表示当前行哪些位置不被占用（合法位置为 1）
        # 与操作后结果 available_positions 是一个二进制数，其中每一位为 1 表示当前行对应列可以放皇后
        available_positions = ((1 << self.n) - 1) & ~(cols | diag1 | diag2)  
        # 当还有可以尝试的合法位置时，不断尝试
        while available_positions:
            # 取出最低位的 1（也就是当前尝试的列），技巧：x & -x 提取最低位为1的位置
            position = available_positions & -available_positions 
            # 将 position 减一后转为二进制，统计 1 的个数，得到该位是第几列（因为是从最低位的1开始的）
            col = bin(position - 1).count("1")  
            
            # 进入下一行递归：
            # cols | position：更新列状态
            # diag1 | position 左移一位，表示下一行 ↘ 对角线偏移
            # diag2 | position 右移一位，表示下一行 ↙ 对角线偏移
            # queens + [col] 添加当前行皇后所放列
            self.backtrack(row + 1, cols | position, (diag1 | position) << 1, (diag2 | position) >> 1, queens + [col])
            # 清除最低位的 1，准备尝试下一个合法位置
            available_positions &= available_positions - 1  
```

- 时间复杂度：仍为 `O(n!)`，但实际运行时间会显著减少
- 空间复杂度：降至 `O(n)`，因为只使用几个整数来表示棋盘状态