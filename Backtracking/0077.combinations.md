# 77.组合

题目链接：[77.组合](https://leetcode.cn/problems/combinations/)

## 题目大意

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合

可以按`任何顺序`返回答案

```js
Example 1:
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

Example 2:
Input: n = 1, k = 1
Output: [[1]]
Explanation: There is 1 choose 1 = 1 total combination.
```

限制：
- 1 <= n <= 20
- 1 <= k <= n

## 解题

暴力枚举
- 穷举 `[1..n]` 的全部子集（共 `2^n` 个），再筛选出大小为 `k` 的
- 明显低效：生成了大量无用子集

> 典型的回溯算法，`k` 限制了树的高度，`n` 限制了树的宽度

**写法 1: 枚举下一个数字选哪个** - 回溯 / DFS（标准做法） ✅
- 用路径 `track` 表示当前选择的组合；当 `len(track) == k` 时收集答案
- 通过一个参数 `start` 限定下一轮可选数字范围为 `[start..n]`：
  - 这样保证组合元素按递增顺序加入，天然避免顺序重复
  - 同时减少搜索分支（不会回头选更小的数字）

**写法 2: 回溯 + 上界剪枝**

- 如果还需选 `need = k - len(track)` 个数，而从当前 `i` 到 `n` 的剩余数量 `left = n - i + 1` 不够 `need`，则没必要再深入
- 等价实现：把 `for` 的上界直接收紧到 `n - (k - len(track)) + 1`（但 `Python` 的 `range` 右开，需再 `+1`），所以最后写成：`range(start, n - (k - len(track)) + 1 + 1)`

```js
var combine = function(n, k) {
    let res = [];
    if (k <= 0 || n <= 0) return res;
    let track = [];

    const backtrack = function(n, k, start, track) {
        if (track.length == k) {
            res.push([...track]);
            return;
        }

        for (let i = start; i <= n; i++) {
            track.push(i);
            backtrack(n, k, i+1, track);
            track.pop();
        }
    };

    backtrack(n, k, 1, track);
    return res;
};
```
```python
# 写法 1: 枚举下一个数字选哪个
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        # self.track：当前递归路径（已选择的数字）
        # self.res：最终结果集合
        self.track, self.res = [], []
        # 边界判断：如果 n 或 k 非正，直接返回空结果
        if k <= 0 or n <= 0:
            return self.res
        
        # 从 start=1 开始搜索（只能选 [1..n]）s
        self.backtrack(n, k, 1)
        return self.res
    
    def backtrack(self, n, k, start):
        # 终止条件：当前路径长度达到 k，说明形成了一个完整组合；拷贝保存并返回
        # 这里必须拷贝，避免后续回溯修改原列表
        if len(self.track) == k:
            self.res.append(self.track[:])
            return
        
        # 在当前层，尝试选择 i 作为下一个元素，i 从 start 递增到 n
        # 这样保证递增顺序添加，避免同一组合的不同排列（不产生 [2,1] 这种重复）
        for i in range(start, n+1):
            # 选择：把 i 放入路径
            self.track.append(i)
            # 递归：下一层只能从 i+1 往后选，避免回头选小数，确保不重复
            self.backtrack(n, k, i+1)
            # 撤销选择（回溯）：为尝试下一个 i 做准备
            self.track.pop()

# 写法 2：回溯 + 上界剪枝
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:  
        # self.res：存放所有组合的结果列表；self.track：当前递归路径（已选的数），严格递增
        self.res, self.track = [], []
        # 边界处理：若 n 或 k 非正，则没有合法组合，返回空列表
        #（若题目期望 k=0 返回 [[]]，可按平台要求改成特判）
        if k <= 0 or n <= 0:
            return self.res
        
        # 从 start = 1 开始搜索，只能往后选；回溯结束返回结果
        self.backtracking(n, k, 1)
        return self.res
    
    def backtracking(self, n, k, start):
        # 终止条件：当前已选数量达到 k，拷贝一份路径加入答案，然后返回
        # 必须拷贝 [:]，否则后续回溯会修改已存结果
        if len(self.track) == k:
            self.res.append(self.track[:])
            return
        
        # 上界剪枝的关键一行：
        # 还需要的数量：need = k - len(self.track)
        # - 能选的最大起点不能太大，否则“可用元素数”不足以填满 need
        # - 能选的最后一个可行 i 满足：n - i + 1 >= need → i <= n - need + 1 = n - (k - len(self.track) + 1
        # 因为 Python range 的右端是开区间，想包含这个上界，就要再 +1，所以写成
        # range(start, n - (k - len(self.track)) + 1 + 1) 
        # 等价更直观的写法：range(start, n - (k - len(self.track)) + 2)
        for i in range(start, n - (k - len(self.track)) + 1 + 1):
            # 选择当前数 i，加入路径  
            self.track.append(i)
            # 递归到下一层，只能从 i+1 往后选，保证严格递增，不会出现组合的排列重复
            self.backtracking(n, k, i + 1)
            # 回溯，撤销选择，尝试下一个 i
            self.track.pop()
```

- 时间复杂度：`O(C(n, k) * k)`，即生成所有组合的时间，`k` 是每次生成一个组合的复杂度，因为每次都要将组合存储到结果中
- 空间复杂度：`O(C(n, k) * k)`，主要是结果存储空间的复杂度，递归栈空间为 `O(k)`

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9rjpszttjv.png)

