# 282.给表达式添加运算符

题目链接：[282.给表达式添加运算符](https://leetcode.cn/problems/expression-add-operators/)

## 题目大意

给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回 所有 能够得到 target 的表达式

注意，返回表达式中的操作数 不应该 包含前导零

注意，一个数字可以包含多个数位

```js
Example 1:
Input: num = "123", target = 6
Output: ["1*2*3","1+2+3"]
Explanation: Both "1*2*3" and "1+2+3" evaluate to 6.

Example 2:
Input: num = "232", target = 8
Output: ["2*3+2","2+3*2"]
Explanation: Both "2*3+2" and "2+3*2" evaluate to 8.

Example 3:
Input: num = "3456237490", target = 9191
Output: []
Explanation: There are no expressions that can be created from "3456237490" to evaluate to 9191.
```

限制:
- 1 <= num.length <= 10
- num consists of only digits.
- -2^31 <= target <= 2^31 - 1

## 解题

设字符串 `num` 的长度为 `n`，为构建表达式，可以往 `num` 中间的 `n−1` 个空隙添加 `+` 号、`-` 号或 `*` 号，或不添加符号

此处考虑用`回溯法`来模拟过程，从左向右构建表达式并实时计算表达式的结果。由于乘法运算优先级高于加法和减法运算，还需保存最后一个连乘串（如 2*3*4）的运算结果

该递归函数分为两种情况：
- 如果 `i=n`，说明表达式已经构造完成，若此时有 `res=target`，则找到了一个可行解，将 `expr` 放入答案数组中，递归结束
- 如果 `i<n`，需枚举当前表达式末尾要添加的符号（`+` 号、`-` 号或 `*` 号），以及该符号之后需要截取多少位数字。设该符号之后的数字为 `val`，按符号分类讨论：
  - 若添加 `+` 号，则 `res` 增加 `val`，且 `val` 单独组成表达式最后一个连乘串
  - 若添加 `-` 号，则 `res` 减少 `val`，且 `−val` 单独组成表达式最后一个连乘串
  - 若添加 `*` 号，由于乘法运算优先级高于加法和减法运算，需对 `res` 撤销之前 `mul` 的计算结果，并添加新的连乘结果 `mul∗val`，即将 `res` 减少 `mul` 并增加 `mul∗val`

> 代码实现时，为避免字符串拼接所带来的额外时间开销，采用`字符数组的形式`来构建表达式。此外，运算过程中可能会产生超过 `32` 位整数的结果，要用 `64` 位整数存储中间运算结果

```js
/**
 * @param {string} num
 * @param {number} target
 * @return {string[]}
 */
var addOperators = function(num, target) {
    const n = num.length;
    const res = [];

    const backtrack = (expr, i, cur, mul) => {
        if (i === n) {
            if (cur === target) {
                res.push(expr.join(''));
            }
            return;
        }

        let signIndex = expr.length;
        if (i > 0) expr.push(''); // placeholder for operator

        let val = 0;
        for (let j = i; j < n; j++) {
            if (j > i && num[i] === '0') break; // skip leading zeros
            val = val * 10 + parseInt(num[j]);
            expr.push(num[j]);

            if (i === 0) {
                backtrack(expr, j + 1, val, val);
            } else {
                expr[signIndex] = '+';
                backtrack(expr, j + 1, cur + val, val);

                expr[signIndex] = '-';
                backtrack(expr, j + 1, cur - val, -val);

                expr[signIndex] = '*';
                backtrack(expr, j + 1, cur - mul + mul * val, mul * val);
            }
        }
        expr.splice(signIndex); // 删除当前分支的数字和操作符
    };

    backtrack([], 0, 0, 0);
    return res;
};
```
```python
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        n = len(num)
        res = []

        def backtrack(expr: List[str], i: int, cur: int, mul: int):
            if i == n:
                if cur == target:
                    res.append(''.join(expr))
                return
            signIndex = len(expr)
            if i > 0:
                expr.append('')  # placeholder for operator
            val = 0
            for j in range(i, n):
                if j > i and num[i] == '0':
                    break
                val = val * 10 + int(num[j])
                expr.append(num[j])
                if i == 0:
                    backtrack(expr, j + 1, val, val)
                else:
                    expr[signIndex] = '+'
                    backtrack(expr, j + 1, cur + val, val)
                    expr[signIndex] = '-'
                    backtrack(expr, j + 1, cur - val, -val)
                    expr[signIndex] = '*'
                    backtrack(expr, j + 1, cur - mul + mul * val, mul * val)
            del expr[signIndex:]

        backtrack([], 0, 0, 0)
        return res
```

- 时间复杂度：`O(4^n)`，其中 `n` 是字符串 `num` 的长度
  - 由于在数字之间可以选择不添加符号、添加 + 号、- 号或 * 号，一共有 4 种选择，因此时间复杂度为 `O(4^n)`
  - 注：考虑到将 `expr` 的拷贝存入答案需要花费 `O(n)` 的时间，最终的时间复杂度似乎是 O(n×4^n)。考虑合法表达式最多的情况，即 `num` 全为 `0` 且 `target=0` 的情况，由于不能有前导零，须在数字之间添加 `+ - *` 三者之一，所以合法表达式有 `3^n−1` 个，因此「将 `expr` 的拷贝存入答案」这一部分的时间开销至多为 `O(n×3^n)`
- 空间复杂度：`O(n)`，不考虑返回值的空间占用，空间复杂度取决于递归时的栈空间
