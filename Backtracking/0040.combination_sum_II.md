# 40.组合总和 II

题目链接：[40.组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

## 题目大意

给定一个候选人编号的集合 `candidates` 和一个目标数 `target`，找出 `candidates` 中所有可以使数字和为 `target` 的组合

`candidates` 中的每个数字在每个组合中只能使用一次 

注意：解集不能包含重复的组合

```js
Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]

Example 2:
Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
```

限制：
- 1 <= candidates.length <= 100
- 1 <= candidates[i] <= 50
- 1 <= target <= 30

## 解题

初始暴力思路
- 枚举所有可能的子集组合（回溯），每次遇到一个和等于 `target` 的组合就加入结果
- 问题是：输入数组有重复元素，需避免出现重复组合；同时，每个数字只能使用一次，不能重复选

这类 `组合 + 剪枝 + 排序 + 去重`的题，非常适合`回溯法`处理

核心策略：
- 排序：先对 `candidates` 进行排序，方便去重操作
- 回溯：每次尝试从当前位置往后尝试选取元素
- 剪枝：
  - 如果当前总和 `trackSum` 已经超过 `target`，就提前返回
  - 如果已经等于 `target`，就保存结果
- 去重：在同一层中遇到重复数字就跳过，避免出现相同组合

```js
var combinationSum2 = function(candidates, target) {
    let res = [], track = [];
    let trackSum = 0;
    // 先排序，让相同的元素靠在一起
    candidates.sort((a, b) => a - b);

    const backtrack = function(candidates, target, start) {
        if (trackSum == target) {
            res.push([...track]);
            return;
        }

        if (trackSum > target) return;
        for (let i = start; i < candidates.length; i++) {
            if (i > start && candidates[i] == candidates[i-1]) continue;
            track.push(candidates[i]);
            trackSum += candidates[i];
            backtrack(candidates, target, i+1);
            trackSum -= candidates[i];
            track.pop();
        }
    };

    backtrack(candidates, target, 0);
    return res;
};
```
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        # self.res 用于存放最终所有满足条件的组合
        # self.track 是当前正在构建的组合路径
        self.res, self.track = [], []
        # 记录当前路径中元素的和，便于剪枝
        self.trackSum = 0
        # 对数组排序，方便后续的剪枝与去重操作
        candidates.sort()
        # 调用回溯函数，从索引 0 开始搜索，最后返回结果
        self.backtrack(candidates, target, 0)
        return self.res

    # 定义一个回溯函数：
    # - candidates：原数组
    # - target：目标值
    # - start：当前回溯从哪一个索引开始，确保每个元素只用一次
    def backtrack(self, candidates, target, start):
        # 当路径和等于目标值时，将当前路径加入结果中，注意用 [:] 创建副本
        if self.trackSum == target:
            self.res.append(self.track[:])
            return
        
        # 剪枝：如果当前路径和已经大于目标值，就没必要继续回溯了，提前返回
        if self.trackSum > target:
            return
        
        # 从 start 开始遍历 candidates，保证每个数字只用一次
        for i in range(start, len(candidates)):
            # 关键去重逻辑：如果当前数字等于前一个数字，且在同一层中（i > start），就跳过，避免重复组合
            if i > start and candidates[i] == candidates[i-1]:
                continue
            
            # 将当前数字加入路径中；更新路径和
            self.track.append(candidates[i])
            self.trackSum += candidates[i]
            # 递归调用，注意 i+1，表示当前数字不能再选（每个数字最多使用一次）
            self.backtrack(candidates, target, i+1)
            # 回溯：撤销选择，恢复现场
            self.trackSum -= candidates[i]
            self.track.pop()
```

- 时间复杂度：`O(2^n × n)`，其中 `n` 是数组 `candidates` 的长度
  - 每个元素可以选择或不选择，因此在最坏情况下，可以形成一个二叉递归树，其最大深度为 `n`（`n` 是 `candidates` 数组的长度）；完全展开的二叉递归树可能会生成 `2^n` 种子集（每个元素选与不选的可能性）
  - 由于去重机制，某些分支不会被探索；但只能保证某些重复子集不会被计算，仍然可能需要考虑指数级的组合数
  - 每次找到一个合法解时，需要 `O(n)` 的时间存储；由于最坏情况下，可能有 `O(2^n)` 组解，每次存储 `O(n)`，最终复杂度为：`O(2^n × n)`，这个比排序的 `O(nlogn)` 要大，因此可以忽略排序的时间
- 空间复杂度：`O(n)`。除了存储答案的数组外，需要 `O(n)` 的空间路径存储列表、以及递归需要的栈