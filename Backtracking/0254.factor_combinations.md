# 254.因子的组合

题目链接：[254.因子的组合](https://leetcode.cn/problems/factor-combinations/)

## 题目大意

整数可以被看作是其因子的乘积

例如：

8 = 2 x 2 x 2;
  = 2 x 4.

请实现一个函数，该函数接收一个整数 `n` 并返回该整数所有的因子组合

注意：
- 可以假定 `n` 为永远为正数
- 因子必须大于 `1` 并且小于 `n`

```js
Example 1:
Input: n = 1
Output: []

Example 2:
Input: n = 12
Output: [[2,6],[3,4],[2,2,3]]

Example 3:
Input: n = 37
Output: []

Example 4:
Input: n = 32
Output: [
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]
```

限制：
- 1 <= n <= 10^7

## 解题

> 这题的本质是「分解质因数的所有组合」问题

暴力解法
- 生成所有可能组合，再检查乘积是否等于 `n`
- 组合过多、效率极低，且无法避免重复

### 思路 1

可使用回溯来解决这个问题。这个想法是递归地尝试不同的因子并建立因子组合，找出所有乘积等于 `n` 的因数组合

从“组合问题”的角度来看，可以将它建模为：
- 从数字 `[2, sqrt(n)]` 开始，尝试所有可以整除 `n` 的因子 `i`，每次将 `n` 变成 `n // i`，继续递归地分解，直到无法再分解

> 为什么可以剪枝到 `sqrt(n)`？
> - 假设找到了一个因子 `i`，`i > sqrt(n)`，则 `n // i < sqrt(n)`，这个组合在之前递归时已经被枚举过了，没必要重复

我们可以这么想：假设现在手里有一个数字 `n = 12`，想从小到大找它的所有因子 `i`（`2` 到 `sqrt(n)`），如果 `i` 能整除 `n`，就把它当成一部分，然后把 `n` 缩小成 `n / i`，对剩下的部分 继续分解

思路：
- 从数字 `n` 开始，尝试用 `2` 到 `n-1` 之间的因数除以它
- 对于每个因子 `f`，如果 `n%f==0`，则：
  - 将 `f` 添加到当前组合
  - 递归查找 `f/n` 的因子
- 当找不到其他因子时停止
- 使用回溯探索所有可能的组合

> 为什么不会出现重复组合？
> 如 [2,6] 和 [6,2]：每次从 `start` 开始往上枚举，这样就不可能出现 `[6, 2]`，因为 `6` 是大于 `2` 的，不会先被尝试

```js
var getFactors = function(n) {
    function backtrack(start, n, path, res) {
        for (let i = start; i * i <= n; i++) {
            if (n % i === 0) {
                res.push([...path, i, n / i]);
                backtrack(i, n / i, [...path, i], res);
            }
        }
    }
    
    const res = [];
    backtrack(2, n, [], res);
    return res;
};
```
```python
class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        # 初始化结果列表，用于存放所有合法的因数组合
        res = []
        # 定义一个回溯函数：
        # - start：从哪个数开始尝试因数（为了保证升序组合）
        # - n：当前要被分解的数
        # - track：当前构造中的组合路径（例如 [2, 3]）
        # - res：结果列表
        def backtrack(start, n, track, res):
            # 枚举可能的因子 i，从 start 到 sqrt(n)
            # 为什么是 sqrt(n)？- 避免重复组合，如 [2,6] 和 [6,2] 实际是同一个组合
            for i in range(start, int(n**0.5) + 1):
                # 判断 i 是否为 n 的因子，如果不是则跳过
                # 找到了一个因子 i，说明：n = i × (n // i)
                if n % i == 0:
                    # 找到一个合法组合：[track..., i, n//i]，直接将 [当前路径 + i + n//i] 加入结果中
                    # 把这个组合加入结果里，比如 [2, 6]、[3, 4]
                    res.append(track + [i, n // i])
                    # 继续递归，把 n 变为 n // i，探索更长的因数组合
                    # 注意：从 i 开始而不是 2，保证组合中数字是非递减的（避免重复）
                    # 当前 path 加入了 i
                    # 下一轮继续从 i 开始（防止出现 [3,2,2] 这种降序）
                    backtrack(i, n // i, track + [i], res)
        
        # 从因数 2 开始枚举因子（1 不算有效因数），启动递归回溯过程
        backtrack(2, n, [], res)
        return res
```


- 时间复杂度：`O(√nlogn)`
  - 由于 `n` 的因子最多到 `sqrt(n)`，所以主循环的时间复杂度为：`O(√n)`
  - 每次递归调用时，输入的 `n` 至少被 `i`（因子）整除，即 `n` 逐步减少。在最坏情况下，每层递归 `n` 至少除以 `2`，因此递归深度为：`O(logn)`，在每一层递归中，最多会检查 `O(sqrt(n))` 个因子
- 空间复杂度：`O(logn)`，由于递归调用回溯方法时，输入的数字每次至少除以 `2`，因此空间复杂度是 `O(logn)`

### 思路 2

`分治递归 + 限制起始因子`，将问题转化为递归子问题：
- 对于当前数字 `n`，从 `start` 开始尝试找因子 `x`，若 `x` 是 `n` 的因子，则将其记录，然后递归求解 `n // x` 的因数组合，并将 `x` 作为后续因子的最小值，以保证结果递增、避免重复
- 用分治思想处理每一个子问题
- 子问题是“对 `n//x` 再进行分解”，这就是进入下一层递归的方式
- 最终的组合就是 `[x] + solve(n//x)`

具体来说，只需把 `n` 拆分出一个因子就行，比方说拆分出了一个因子 `x`，就可递归求解 `n / x` 的所有因子的组合，然后把 `x` 和 `n / x` 的所有因子组合放在一起，就是 `n` 的所有因子组合

```js
var getFactors = function(n) {
    return solveSubProblem(n, 2);
};

var solveSubProblem = function(n, start) {
    let res = [];
    // base case，当 n <= 3 时，不再进行分解
    if (n <= 3) return res;
    for (let x = start; x <= Math.sqrt(n); x++) {
        if (n % x !== 0) continue;
        // x * n/x 这对因子是一定要加进去的
        res.push([x, n / x]);
        // 然后，去递归求解子问题 n/x 的所有因子组合，注意控制算法跳过小于 x 的因子，避免结果重复
        let subResult = solveSubProblem(n / x, x);
        for(let list of subResult) {
            // 把 x 和子问题的因子凑起来，就是构成 n 的因子了
            list.push(x);
            res.push(list);
        }
    }
    return res;
};
```
```python
class Solution:
    def getFactors(self, n: int) -> List[List[int]]:
        # 在第一次调用时，开始查找因子从 2 开始，因为 1 不是有效因子（题目要求因子必须大于 1）
        # 传入的 2 代表：我们只从 2 开始往上找因数（而不是从 1 开始），以避免 [1,12] 这类无意义组合
        return self.solve_sub_problem(n, 2)
    
    def solve_sub_problem(self, n: int, start: int) -> List[List[int]]:
        res = []
        # base case，当 n <= 3 时，不再进行分解
        # 由于因子必须大于 1 并小于 n，当 n ≤ 3 时没有符合条件的因子，所以返回空列表
        if n <= 3:
            return res
        
        # 因子从 start 开始，查找的上限是 math.sqrt(n)，枚举 x 从 start 到 sqrt(n)（含）
        # 如果 x 是 n 的因子，那么 n/x 也是 n 的因子，考虑到因子对称性，只需检查到 math.sqrt(n) 即可
        # x > sqrt(n)，则 (x, n // x) 组合的对称形式 (n//x, x) 一定在前面枚举过了，避免重复
        for x in range(start, int(math.sqrt(n)) + 1):
            # 如果 x 不是 n 的因子，跳过，继续下一个 x
            # 否则说明找到一个有效因子对 (x, n//x)
            if n % x != 0:
                continue
            
            # 对于每个找到的因子 x，将对应的因子对 [x, n/x] 作为一组有效的因子组合加入结果 res
            res.append([x, n // x])
            # 对 n // x 进一步分解（子问题）去递归求解子问题 n/x 的所有因子组合，注意控制算法跳过小于 x 的因子，避免结果重复
            # 在递归调用时第二个参数仍传递 x，确保子问题只考虑不小于 x 的因子，确保后续组合不降序（如 [3,2,2] 不会被加入）
            sub_result = self.solve_sub_problem(n // x, x)

            # 遍历子问题返回的组合列表
            # 对每一个组合 list，把当前因子 x 加到末尾（组合完整了）
            # 再加入最终结果中
            # 注意：这种写法构造的组合是 逆序 的（如 [3,2,2]），但由于枚举方式已经保证不生成 [6,2] 类型的重复组合
            for list in sub_result:
                list.append(x)
                res.append(list)
        
        # 返回当前层所有合法组合
        return res
```

