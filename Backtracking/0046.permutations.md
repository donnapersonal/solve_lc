# 46.全排列

题目链接：[46.全排列](https://leetcode.cn/problems/permutations/)

## 题目大意

给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列，可以按任意顺序返回答案

```js
Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]

Example 3:
Input: nums = [1]
Output: [[1]]
```

限制：
- 1 <= nums.length <= 6
- -10 <= nums[i] <= 10
- All the integers of nums are unique.

## 解题

初始思路：穷举法 / 递归构建全排列
- 我们希望输出的是所有可能的排列（不是组合），因此：
  - 每个位置都可以选择数组中 尚未使用 的任意一个数
  - 对每个数进行尝试，直到填满一组排列为止
  - 最后回退（回溯）到上一步，尝试下一个可选的数字

最优解：`回溯法（Backtracking）`
> 回溯法是一种`深度优先搜索（DFS）+ 恢复现场`的策略，适合解决排列组合问题

写法 1 思路：
- 每次递归构建一个排列路径 `track`
- 如果 `track` 长度等于 `nums` 数组长度，说明形成一个完整排列，加入结果集
- 遍历 `nums` 数组中的每个元素：
  - 若当前元素已在路径中，用 `continue` 跳过
  - 若未使用，加入路径并进入下一层递归
  - 回溯时移除最后一个加入的元素，尝试下一个选项

写法 2：回溯法（Backtracking） + 状态标记
- 构造一条「排列路径 track」，每次在当前路径上选择一个还没用过的数字
- 用一个 `used[]` 布尔数组来标记哪些数字已被使用
- 一旦`路径长度 == len(nums)`，就表示当前是一个合法的排列，将其加入结果集

写法 3：- 优化版本：`预分配 track[]，直接写入索引 i`
- 相比经典回溯写法（动态 append 和 pop），该方法做了以下优化：

| 优化点 | 描述 |
| --- | --- |
| 预分配 `track` | 用固定长度数组代替动态列表，避免频繁扩容和复制 |
| 用 `track[i] = nums[j]` | 直接在 index `i` 位置上写入，清晰、性能好 |
| 不需 `pop` 回退 | 因为每次都直接覆盖，无需移除元素 |

```js
// 写法 1
var permute = function(nums) {
    let res = [], track = [];

    const backtrack = function(nums) {
        if (track.length == nums.length) {
            res.push([...track]);
            return;
        }

        for (let i = 0; i < nums.length; i++) {
            if (track.includes(nums[i])) continue;
            track.push(nums[i]);
            backtrack(nums);
            track.pop();
        }
    };

    backtrack(nums);
    return res;
};

// 写法 2
var permute = function(nums) {
    let res = [], track = [], used = [];
    const backtrack = function(nums) {
        if (track.length == nums.length) {
            res.push([...track]);
            return;
        }
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            used[i] = true;
            track.push(nums[i]);
            backtrack(nums);
            track.pop();
            used[i] = false;
        }
    };
    
    backtrack(nums);
    return res;
};
```
```python
# 写法 1
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        # self.res: 存放最终结果的二维列表（所有排列）；self.track: 当前递归中的排列路径，逐步构造中
        self.res, self.track = [], []
        # 调用回溯函数，开始生成排列
        self.backtrack(nums)
        # 返回最终结果
        return self.res

    def backtrack(self, nums):
        # 递归终止条件：当 track 路径长度等于 nums 的长度，表示已经构成一个完整的排列
        # 使用 [:] 创建一份当前路径的副本加入结果中，防止后续修改影响结果
        # 然后 return 返回上一层，进行回溯
        if len(self.track) == len(nums):
            self.res.append(self.track[:])
            return 
        
        # 遍历 nums 中的每一个数字
        for i in range(len(nums)):
            # 如果该数字已经出现在当前路径中，就跳过；保证每个数字只在排列中使用一次
            if nums[i] in self.track:
                continue
            
            # 做出选择：将当前数字加入路径
            self.track.append(nums[i])
            # 递归进入下一层，继续构造剩下的排列
            self.backtrack(nums)
            # 撤销选择（回溯）：移除刚才加入路径的数字，尝试下一个可能
            self.track.pop()

# 写法 2
# 使用 used 存储元素判断是否重复
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.res, self.track = [], []
        self.used = [False] * len(nums)
        self.backtrack(nums)
        return self.res
    
    def backtrack(self, nums):
        if len(self.track) == len(nums):
            self.res.append(self.track.copy())
            return
            
        for i in range(len(nums)):
            if self.used[i]:
                continue
            self.track.append(nums[i])
            self.used[i] = True
            self.backtrack(nums)
            self.track.pop()
            self.used[i] = False


# 写法 3
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        res = []
        # 初始化固定长度的路径数组 track，用于构造当前排列
        track = [0] * n 
        # 布尔数组 used[]：标记 nums[j] 是否已被使用，避免重复
        used = [False] * n
        # 定义递归函数 backtracking(i)：
        # - 参数 i 表示当前构造的路径已经填到了第 i 位（还没填）
        # - 所以目标是构造 track[0] 到 track[n-1]
        def backtracking(i: int) -> None:
            # 终止条件：如果路径已经填满（长度为 n），说明构造出一个完整排列
            # 复制当前 track，加入结果集
            # 使用 copy() 或切片 [:]，避免后续修改影响结果
            if i == n:
                res.append(track.copy())  # 也可以写 track[:]
                return

            # 枚举所有数字的索引 j；on 表示 nums[j] 是否已经被使用过
            for j, on in enumerate(used):
                # 如果该数字没有被用过，就可以使用
                if not on:
                    # 将当前数字 nums[j] 放入当前路径的第 i 位
                    track[i] = nums[j]  
                    # 标记 nums[j] 已使用，防止后续重复选它
                    used[j] = True  
                    # 递归进入下一位，即填 track[i+1]
                    backtracking(i + 1)
                    # 回溯时撤销选择：恢复 used[j]，为下一个路径分支释放该数的使用权
                    used[j] = False 
                    # 注意 track 无需恢复现场，因为排列长度固定，直接覆盖就行
                    # 一个重要的优化点：
                    # - 因为 track[i] 会在下一轮直接被覆盖
                    # - 所以不需要像传统回溯那样 pop() 删除元素
        
        # 从第 0 位开始构造排列
        backtracking(0)
        # 最终返回所有合法排列组成的列表
        return res
```

- 时间复杂度：`O(n * n!)`
  - 生成全排列的递归操作涉及遍历数组，每次操作的复杂度为 `O(n)`
  - 总共有 `n!` 种全排列，回溯搜索的时间复杂度主要由递归树的大小决定：
    - 在第一层，有 `n` 个选择
    - 在第二层，有 `n-1` 个选择
    - 在第三层，有 `n-2` 个选择
    - 依此类推，直到 `n!` 个叶子节点（完整排列）
- 空间复杂度：`O(n)`，返回值不计入
  - 递归调用栈（`O(n)` 层递归）
  - `track` 变量存储当前路径（最大 `O(n)`）
  - `res` 变量存储最终 `n!` 个排列，每个排列 `O(n)`