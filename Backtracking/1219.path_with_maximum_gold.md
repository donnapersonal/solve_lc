# 1219.黄金矿工

题目链接：[1219.黄金矿工](https://leetcode.cn/problems/path-with-maximum-gold/)

## 题目大意

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0

为了使收益最大化，矿工需要按以下规则来开采黄金：
- 每当矿工进入一个单元，就会收集该单元格中的所有黄金
- 矿工每次可以从当前位置向上下左右四个方向走
- 每个单元格只能被开采（进入）一次
- 不得开采（进入）黄金数目为 0 的单元格
- 矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止

```js
Example 1:
Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.

Example 2:
Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.
```

限制:
- m == grid.length，n == grid[i].length
- 1 <= m, n <= 15
- 0 <= grid[i][j] <= 100
- There are at most 25 cells containing gold.

## 解题

暴力 DFS：
- 尝试从每一个非 0 格子出发进行 DFS 搜索，记录路径上的黄金总量
- 每一步尝试上下左右四个方向，遇到 0 或已访问的格子则剪枝。

关键点：
- 不需要考虑回到起点或走所有路径，仅需最大值
- 不需要记录整条路径，只需当前最大值
- 回溯要“还原”格子状态，以便下次访问

✅ 最优解策略（DFS + 回溯）：
- 从每一个非 0 起点格子进行 DFS 搜索
- 使用「就地修改」或布尔数组标记路径，防止重复访问
- 回溯时记得恢复现场
- 维护一个全局变量记录最大值

```js
var getMaximumGold = function(grid) {
    const m = grid.length, n = grid[0].length;
    let maxGold = 0;

    const dfs = (x, y, curr) => {
        curr += grid[x][y];
        maxGold = Math.max(maxGold, curr);

        const temp = grid[x][y];
        grid[x][y] = 0;

        for (const [dx, dy] of [[-1,0],[1,0],[0,-1],[0,1]]) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] !== 0) {
                dfs(nx, ny, curr);
            }
        }

        grid[x][y] = temp;
    };

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] !== 0) {
                dfs(i, j, 0);
            }
        }
    }

    return maxGold;
};
```
```python
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        # 获取网格大小 m 行 n 列
        m, n = len(grid), len(grid[0])
        # 初始化 max_gold 存储最大路径总和
        max_gold = 0

        def dfs(x: int, y: int, curr_gold: int) -> int:
            # 使用 nonlocal 来更新外部 max_gold 值
            nonlocal max_gold
            # 累加当前格子黄金
            curr_gold += grid[x][y]
            # 更新最大黄金总量
            max_gold = max(max_gold, curr_gold)

            # 临时保存当前格子值
            temp = grid[x][y]
            # 标记为 0 表示访问过（防止走回头路）
            grid[x][y] = 0  

            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:  # 上下左右
                # 遍历上下左右四个方向；计算相邻格子坐标
                nx, ny = x + dx, y + dy
                # 如果相邻格子合法且未访问，继续 DFS
                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] != 0:
                    dfs(nx, ny, curr_gold)
            
            # 回溯：恢复当前格子为原始值，为其他路径使用
            grid[x][y] = temp  
        
        # 枚举所有非 0 起点格子，作为 DFS 起点
        for i in range(m):
            for j in range(n):
                if grid[i][j] != 0:
                    dfs(i, j, 0)
        
        # 返回找到的最大黄金总和
        return max_gold
```

- 时间复杂度：`O(mn+min(mn,T)⋅3^min(mn,T))`，其中 `T=25` 表示最多包含黄金的单元格数量
  - 枚举起点需要 `O(mn)` 的时间，可以成为起点的位置必须有黄金，那么可能的起点有 `min(mn,T)` 个
  - 对于每一个起点，第一步最多有 `4` 个可行的方向，后面的每一步最多有 `3` 个可行的方向，因此可以粗略估计出一次搜索需要的时间为 `O(4×3^min(mn,T)−2)=O(3^min(mn,T))`
- 空间复杂度：`O(min(mn,T))`，即为递归需要的栈空间