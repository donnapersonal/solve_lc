# 滑动窗口

## 定长滑动窗口

总结成三步：入 - 更新 - 出
- `入`：下标为 `i` 的元素进入窗口，更新相关统计量
- `更新`：更新答案，`一般是更新最大值/最小值`
- `出`：下标为 `i−k+1` 的元素离开窗口，更新相关统计量

以上三步适用于所有定长滑窗题目

```python
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        res = count = 0
        for i, c in enumerate(s):
            # 1. 进入窗口
            if c in "aeiou":
                count += 1
            if i < k - 1:  # 窗口大小不足 k
                continue
            # 2. 更新答案
            res = max(res, count)
            # 3. 离开窗口
            if s[i - k + 1] in "aeiou":
                count -= 1
        return res
```

## 基于“滑动窗口 + 字符频率 + valid 计数”的模板

适用场景：
- 判断是否包含某些字符/异位词
- 找到所有异位词
- 最小窗口包含所有字符（如 LeetCode 76）
- 子串满足特定频率要求

通用模板代码（Python）：

```python
from collections import defaultdict

def sliding_window_template(s: str, t: str) -> str:
    need = defaultdict(int)
    window = defaultdict(int)
    for c in t:
        need[c] += 1

    left = right = 0
    valid = 0  # 记录当前窗口满足 need 条件的字符种类数

    # 根据题意定义结果变量，例如最小长度、起始位置、答案列表等
    res = []

    while right < len(s):
        # c 是将要加入窗口的字符
        c = s[right]
        right += 1

        # 更新窗口内数据
        if c in need:
            window[c] += 1
            if window[c] == need[c]:
                valid += 1

        # 判断左侧窗口是否需要收缩
        while right - left >= len(t):  # 对于固定长度匹配，如异位词
        # while valid == len(need):     # 对于所有 need 被满足，如最小覆盖子串
            # 如果满足条件，更新结果
            if valid == len(need):
                res.append(left)  # 对于找异位词，记录当前窗口起点
                # res = s[left:right]    # 对于最小覆盖子串，更新最小结果

            # d 是将要从窗口移除的字符
            d = s[left]
            left += 1

            # 更新窗口内数据
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1

    return res  # 或返回符合条件的子串、长度等
```

使用说明

| 场景 | 如何修改模板 |
| --- | --- |
| 找到所有异位词（如：LeetCode 438）| 保持 `right - left >= len(t)`，每次 `valid == len(need)` 就 `res.append(left)` |
| 判断是否包含异位词（如：LeetCode 567）| 一旦满足 `valid == len(need)` 就 `return True` |
| 最小覆盖子串（如：LeetCode 76）| 条件是 `valid == len(need)`，然后维护 `min_len` 和 `start`，不断缩小窗口 |
| 包含所有字符的最短子串 | 同上，但需在窗口满足后尽量缩小 `left` |

## 滑动窗口的动机从何而来？

| 触发因素 | 对应判断 |
| --- | --- |
| 目标包含连续区间 | 窗口思想可行 |
| 区间大小固定 | 固定长度窗口 |
| 需高效判断区间中是否所有元素满足某条件 | 滑窗 + 条件检查 |
| 可提前剪枝跳过无效区间 | 滑窗结构天然适合 |

> 滑动窗口仅在所有数字都非负时才有效，因为窗口扩展/收缩依赖于总和单调性

## 从两端拿固定长度

这可以使用逆向思维，从两端变成从中间

# 双指针

## 排序 + 双指针

`排序 + 双指针`是解决三数问题的经典模式，它利用数组的有序性缩小搜索范围，避免冗余计算

逻辑高效清晰，适合在任意三数组合问题中应用

# 快慢指针移除元素

何时使用该模式：
- 从数组中就地移除特定元素
- 在空间受限的情况下过滤数组
- 类似于 283（移动零）、26（移除重复项）、80（最多两个重复项）

# 图论

## DFS / BFS

`DFS`：找连通块、判断是否有环等
`BFS`：求最短路、扩展传播类问题（多源 BFS）
`DFS+BFS`：求类似“一个区域扩展覆盖另一个区域”的问题，可优先考虑 `DFS+BFS` 的组合方式


## 拓扑排序

把拓扑排序想象成一个黑盒，给它一堆杂乱的先修课约束，它会给你一个井井有条的课程学习安排

这一种在图上的「排序」，可以把杂乱的点排成一排
- 就是把一幅无环图「拉平」，且这个「拉平」的图里面所有箭头方向都是一致的：
  ![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m4610s7ji.webp)
- 前提条件：图中无环，从而保证每条边都是从排在前面的点指向排在后面的点
- 即对于任意有向边 `x→y`，`x` 一定在 `y` 之前

拓扑排序可使用 `DFS` 算法，图的后序遍历结果进行反转就是拓扑排序结果

另外，也可用 `BFS` 算法借助每个节点的入度进行拓扑排序

拓扑排序正是用于处理：
- 有向图
- 依赖关系
- 按顺序处理所有节点，且没有环
- 换句话说，它非常适合解决`课程依赖`这种任务调度类型的问题

选择解法（`DFS` VS. `BFS` 解法的对比）

| 方法 | 原理 | 特点 | 是否返回顺序 | 是否返回顺序 | 适用 |
| --- | --- | --- | --- | --- | --- |
| 拓扑排序（`BFS/Kahn` 算法）| 如果不能遍历所有节点 → 有环 | 递归思路清晰，适合链式依赖 | 可拓扑排序 | 可检测环（3 色状态）| 更倾向层级式任务调度 |
| `DFS + visited` 状态标记 | `DFS` 路径中再次遇到“正在访问”的节点 → 有环 | 更直观，基于入度 | 可拓扑排序 | 可检测环（剩余节点）| 更适合递归链式依赖 |

## Dijkstra 算法

适合边权为正的图中求单源最短路径，适合图的单源最短路径

## Union-Find

树的定义是无环的连通图，具有以下性质：
- 图中没有环
- 图是连通的（即所有节点都可以相互到达）

> 而判断两个节点是否连通（是否在同一个连通分量中）就是 `Union-Find` 并查集算法的拿手绝活

要判断一个无向图是否是树，可以使用以下条件：
- 边的数量：如果图是树，那么它有 `n` 个节点和 `n-1` 条边；如果边数不等于 `n-1`，则直接返回 `False`
- 连通性和无环性：可以使用`并查集`或`深度优先搜索 (DFS)`来判断
  - 并查集用于检测环：如果添加一条边导致两个节点的根相同，则出现了环
  - 并查集还可以帮助检查连通性

并查集方法的优点：

| 要素 | DFS/BFS | Union-Find |
| --- | --- | --- |
| 循环检测 | 需要严谨的逻辑 | 使用 find 就可简单检测 |
| 连通性    | 须跟踪访问次数 | 若边数 = n-1，则可保证 |
| 时间复杂度 | O(n + e) | O(nα(n)) ≈ O(n) |
| 空间复杂度 | Medium | Very clean |

## 欧拉路径

涉及到 `Hierholzer` 算法

当被要求构建一条路径，使每条边恰好使用一次 — 这本质上是在有向图中寻找一条欧拉路径

可用`DFS + 回溯`模拟 `Hierholzer` 算法（后序入栈）

## Floyd 算法

全源最短路：Floyd 算法

Floyd-Warshall 是处理「所有点对最短路径」的经典方法，适用于 `n` 不大的`稠密图`

## Dijkstra 算法

单源最短路：Dijkstra 算法

> - 邻接表+Dijkstra：O(n(n+m))
> - 邻接矩阵+Dijkstra：O(n^2)
> - 堆 + Dijkstra：O(mlogm)
> - Bellman_Ford：O(nm)
> - SPFA：O(km−nm)

可以对每一个节点求解单源最短路，即某一个节点到其它所有节点的最短距离

与 `Floyd-Warshall` 相比，`Dijkstra` 更适合`稀疏图`，节省空间与时间

## 最小生成树

涉及到 Kruskal 算法和 Prim 算法

# 栈

`括号匹配是使用栈解决的经典问题`，由于栈结构的特殊性，非常适合做对称匹配类的题目
> 编译器在词法分析过程中处理括号、花括号等这个符号的逻辑，也是使用了`栈`这种数据结构

使用栈来处理嵌套的编码问题

# 队列

## 单调队列

单调队列 = 滑动窗口 + 单调栈

入队、出队、更新答案，这三步的顺序如何思考？- 有两种情况
- 如果更新答案时，用到的数据包含当前元素，则就需先入队，再更新答案
- 如果用到的数据不包含当前元素，则就需要先更新答案，再入队
- 至于出队，一般写在前面，每遍历到一个新的元素，就看看队首元素是否失效（不满足要求），失效则弹出队首

单调队列（Monotonic Queue）的典型用途：
- 维护一个区间的最小值/最大值
- 保证每次都能以 `O(1)` 拿到最优解
- 每个状态最多入队和出队一次，整个过程总共是 `O(n)`

# 二叉树

## 递归

递归本质上就是`深度优先搜索（DFS）`的一种形式

> 递归法 & DFS
> - 递归（Recursion）是一种 实现方式，它利用函数调用自身来遍历结构化数据（如树）
> - DFS（Depth-First Search，深度优先搜索）是一种 遍历策略，指的是 先往深处走到底，再回溯，适用于树和图的遍历

## Morris 中序遍历

`Morris` 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 `O(1)`

> `Morris` 遍历使用`线索二叉树（Threaded Binary Tree）`，让树本身暂时充当栈来存储路径信息

`Morris` 遍历算法整体步骤如下（假设当前遍历到的节点为 `cur`）
- 如果 `cur` 无左孩子，先将 `cur` 的值加入答案数组，再访问 `cur` 的右孩子，即 `cur=cur.right`
- 如果 `cur` 有左孩子，则找到 `cur` 左子树上最右的节点（即左子树中序遍历的最后一个节点，`cur` 在中序遍历中的前驱节点），记为 `predecessor`。根据 `predecessor` 的右孩子是否为空，进行如下操作
  - 如果 `predecessor` 的右孩子为空，则将其右孩子指向 `cur`，然后访问 `cur` 的左孩子，即 `cur=cur.left`
  - 如果 `predecessor` 的右孩子不为空，则此时其右孩子指向 `cur`，说明我们已经遍历完 `cur` 的左子树，我们将 predecessor 的右孩子置空，将 `cur` 的值加入答案数组，然后访问 `cur` 的右孩子，即 `cur=cur.right`
- 重复上述操作，直至访问完整棵树

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/morris.13lwj1eaxs.webp)

# 贪心

## 贪心策略

有两种基本贪心策略：
- 从最小/最大开始贪心，优先考虑最小/最大的数，从小到大/从大到小贪心。在此基础上，衍生出了反悔贪心
- 从最左/最右开始贪心，思考第一个数/最后一个数的贪心策略，把 n 个数的原问题转换成 n−1 个数（或更少）的子问题

对于无法排序的题目，尝试从左到右/从右到左贪心
- 思考第一个数/最后一个数的贪心策略，把 `n` 个数的原问题转换成 `n−1` 个数（或更少）的子问题

## 区间贪心

区间贪心有如下经典问题：
- `不相交区间（单机器调度/活动安排）`：给定一些区间，从中选出尽量多的两两互不相交的区间
- `区间分组（任务调度/会议室）`：给定一些区间，把这些区间分成最少的组，使得每组内的区间互不相交
- `区间选点（射气球，Interval Stabbing）`：给定一些区间，在数轴上放置最少的点，使得每个区间都包含至少一个点。最少要放置多少个点？
- `区间覆盖（灌溉花园）`：给定一些区间，从中选出尽量少的区间，覆盖一条指定线段 `[s,t]`

## 字符串贪心

**字典序最小/最大**
字典序的定义如下：
- 对于两个字符串 `a` 和 `b`，从左到右依次比较 `a[i]` 和 `b[i]` 的字符 `ASCII` 值的大小
- `a[i] 不等于 b[i]` 时，如果 `a[i]<b[i]`，那么 `a` 的字典序更小，否则 `b` 的字典序更小
- 如果没有出现 `a[i] 不等于 b[i]`，则短的字符串字典序更小
- 如果两个字符串的长度和内容均相同，那么两个字符串的字典序一样
  
字典序的定义也可以推广到数组上，按照上述方法比较两个数组的字典序

# 数学

## 如何遍历一个整数

如果不把 `x` 转成字符串，要怎么做？

可以不断地取 `x` 的最低位（`模 10`），去掉 `x` 的最低位（`除以 10`），直到 `x=0`

如 `x=123`：
- 通过 `x mod 10` 取到个位数 `3`，然后把 `x` 除以 `10`（下取整），得到 `x=12`
- 再次 `x mod 10` 取到十位数 `2`，然后把 `x` 除以 `10`（下取整），得到 `x=1`
- 最后 `x mod 10` 取到百位数 `1`，然后把 `x` 除以 `10`（下取整），得到 `x=0`，此时完成遍历退出循环

## 如何反转一个整数

比如现在有一个数 `56`，如何把 `7` 加到 `56` 的末尾？
- 把 `56` 乘以 `10`，再加上 `7`，就得到了 `567`
- 一般地，如果要把数字 `b` 加到整数 `a` 的末尾，可以计算 `a⋅10+b`

如果要把 `x=123` 反转，我们可以按照前置知识一中的方法，从低到高遍历 `x` 的每一位，即 `3,2,1`

初始化 `rev=0`，依次把 `3,2,1` 加到 `rev` 的末尾，即：
- 更新 `rev` 为 `rev⋅10+3=3`
- 更新 `rev` 为 `rev⋅10+2=32`
- 更新 `rev` 为 `rev⋅10+1=321`
- 最终得到了 `x` 反转后的结果 `rev=321`

## 三角形成立条件

三角形成立条件：设三边为 `a ≤ b ≤ c`，成立三角形的条件是 `a + b > c`

这就是「三角形不等式」：`任意两边之和 > 第三边`

## 质数

> 质数的定义：大于 `1` 且只能被 `1` 和自身整除的正整数

