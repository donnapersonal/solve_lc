# 1081.不同字符的最小子序列

题目链接：[1081.不同字符的最小子序列](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

## 题目大意

返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次

```js
Example 1:
Input: s = "bcabc"
Output: "abc"

Example 2:
Input: s = "cbacdcbc"
Output: "acdb"
```

限制：
- 1 <= s.length <= 1000
- s consists of lowercase English letters.

## 解题

初始思路：`枚举所有子序列 + 去重 + 比较字典序`
- 问题：所有子序列数量是指数级（2^n），不可行
- 结论：暴力 + 去重 + 排序不可接受，需贪心优化

`思路演进：单调栈 + 贪心 + 记录字符最后出现位置`
- 要维护一个结果栈，保证：
  - 栈内是一个合法解（没有重复字符）
  - 栈内字符顺序保证字典序最小（可在安全前提下“移除更大的字符”）
- 遇到当前字符 `s[i]` 时：
  - 如果它已在栈中（已处理过），跳过
  - 否则：
    - 把栈中比当前字符大的字符移除（前提是后面还会再出现它们）
    - 然后将当前字符压入栈
- 需要三样东西：
  - `count`: 每个字符最后一次出现的位置
  - `res`: 当前构建的结果（候选答案）
  - `seen`: 用来判断某个字符是否已经在栈中

```js
```
```python
```

- 时间复杂度：`O(n)`，其中 `n` 为 `s` 的长度
  - 写了一个二重循环，看上去是 `O(n^2)` 的，但是考虑到每个 `s[i]` 加到 `stack` 中至多一次，从 `stack` 中去掉也至多一次
  - 所以整体上看，算法的时间复杂度是 `O(n)` 的
- 空间复杂度：`O(∣Σ∣)`，其中 `∣Σ∣` 为字符集的大小，本题中字符均为小写字母，所以 `∣Σ∣=26`，注意 `stack` 的长度不会超过 `∣Σ∣`