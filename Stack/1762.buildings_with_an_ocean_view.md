# 1762.能看到海景的建筑物

题目链接：[1762.能看到海景的建筑物](https://leetcode.cn/problems/buildings-with-an-ocean-view/)

## 题目大意

有 n 座建筑物。给你一个大小为 n 的整数数组 heights 表示每一个建筑物的高度

建筑物的右边是海洋。如果建筑物可以无障碍地看到海洋，则建筑物能看到海景。确切地说，如果一座建筑物右边的所有建筑都比它 矮 时，就认为它能看到海景

返回能看到海景建筑物的下标列表（下标 从 0 开始 ），并按升序排列

```js
Example 1:
Input: heights = [4,2,3,1]
Output: [0,2,3]
Explanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.

Example 2:
Input: heights = [4,3,2,1]
Output: [0,1,2,3]
Explanation: All the buildings have an ocean view.

Example 3:
Input: heights = [1,3,2,4]
Output: [3]
Explanation: Only building 3 has an ocean view.
```

限制:
- 1 <= heights.length <= 10^5
- 1 <= heights[i] <= 10^9

## 解题

- 从右向左遍历，记录右边的最高建筑 `max_right`
- 对每个建筑：
  - 如果 `heights[i] > max_right` → 能看到海洋 → 加入结果
  - 更新 `max_right = max(max_right, heights[i])`
- 核心原因：
  - 只需要知道右边的最高建筑即可判断是否挡住视线
  - 遍历一次即可完成判断
- 遍历时从右向左可以直接保证顺序，最后再翻转结果列表即可

```js
var findBuildings = function(heights) {
    const n = heights.length;
    const res = [];
    let maxRight = 0;

    for (let i = n - 1; i >= 0; i--) {
        if (heights[i] > maxRight) {
            res.push(i);
            maxRight = heights[i];
        }
    }

    return res.reverse();
};
```
```python
class Solution:
    def findBuildings(self, heights: List[int]) -> List[int]:
        n = len(heights)
        # 存储可以看到海洋的建筑索引
        res = []
        # 记录当前建筑右边最高的高度。初始化为 0，因为高度 >= 1
        max_right = 0 
        # 从最右侧建筑向左遍历
        for i in range(n-1, -1, -1):
            # 当前建筑比右边所有建筑都高 → 可以看到海洋
            if heights[i] > max_right:
                # 将索引加入结果
                res.append(i)
                # 更新右边最高建筑
                max_right = heights[i]
        
        # 因为从右向左遍历，最终索引需要升序 → 翻转
        return res[::-1]
```

- 时间复杂度：`O(n)`，遍历一次数组，每次比较和更新 `max_right` 为 `O(1)`
- 空间复杂度：`O(n)`，用于存储结果数组；额外空间 `O(1)`