# 2679.矩阵中的和

题目链接：[2679.矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/)

## 题目大意

给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：
- 矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除
- 在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中

请返回最后的 分数 

```js
Example 1:
Input: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
Output: 15
Explanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.

Example 2:
Input: nums = [[1]]
Output: 1
Explanation: We remove 1 and add it to the answer. We return 1.
```

限制：
- 1 <= nums.length <= 300
- 1 <= nums[i].length <= 500
- 0 <= nums[i][j] <= 103

## 解题

初始思路（暴力模拟）：
- 每一轮：从每一行找到最大值，记录下来，删掉这个数
- 然后在这轮中被删除的所有数里找最大值，加到总分
- 重复进行直到矩阵为空
- 🧨问题：直接模拟每轮会导致每次都需要从每一行中查最大并删除，时间复杂度较高（O(mn²)）

**最优思路（排序 + 列遍历）：**
- 核心观察：
  - 每一轮都是从每一行中删去一个数，即每一行总共会被删去 len(row) 次
  - 实际上，从每一行中每次删除最大值，最终删除顺序就相当于对行做降序排列，从左往右依次删去
- 等价变换：
  - 先把每一行都降序排列（大的在前，模拟优先删除大数）
  - 然后按「列」来遍历，从左往右取出当前列所有数中最大的数，加入到总分中
- 好处：
  - 只需对每一行排序一次，然后扫描每一列最大值即可
  - 时间复杂度大大降低：O(m * n log n)（m 行，n 列）

```js
/**
 * @param {number[][]} nums
 * @return {number}
 */
var matrixSum = function(nums) {
    for (let row of nums) {
        row.sort((a, b) => b - a);
    }

    let res = 0;

    for (let i = 0; i < nums[0].length; i++) {
        let maxInCol = 0;

        for (let j = 0; j < nums.length; j++) {
            maxInCol = Math.max(maxInCol, nums[j][i]);
        }

        res += maxInCol;
    }

    return res;
};
```
```python
class Solution:
    def matrixSum(self, nums: List[List[int]]) -> int:
        # 初始化总得分
        res = 0
        m = len(nums)
        n = len(nums[0])
        # 先对每一行进行降序排序，确保每行最大值在最前面
        for row in nums:
            row.sort(reverse=True)  
        
        # 遍历每一列（列数等于每行的长度）
        for col in range(n):
            # 当前列的最大值
            max_in_col = 0
            # 取当前列所有行的最大值
            for row in range(m):
                max_in_col = max(max_in_col, nums[row][col])

            # 本轮最大值加到得分中
            res += max_in_col
        
        # 返回总分
        return res
```

- 时间复杂度：`O(mnlogn)`，其中 `m`, `n` 分别为矩阵的行数与列数
  - 对矩阵中一行元素进行排序需要的时间复杂度为 `nlogn`，一共有 `m` 行，因此矩阵所有行排序的时间复杂度为 `O(mnlogn)` - 遍历矩阵中的所有元素需要的时间复杂度为 `O(mn)`，因此总的时间复杂度为 `O(mnlogn+mn)=O(mnlogn)`
- 空间复杂度：
  - `O(mlogn)`，对矩阵中每一行进行排序需要的空间为 `logn`，矩阵一共有 `m` 行，因此总的空间复杂度为 `O(mlogn)`
  - `O(1)`，忽略排序时的栈开销，仅用到若干额外变量，原地排序，没有额外结构