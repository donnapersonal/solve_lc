# 218.天际线问题

题目链接：[218.天际线问题](https://leetcode.cn/problems/the-skyline-problem/)

## 题目大意

城市的 天际线 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 由这些建筑物形成的 天际线 

每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [left_i, right_i, height_i] 表示：
- left_i 是第 i 座建筑物左边缘的 x 坐标
- right_i 是第 i 座建筑物右边缘的 x 坐标
- height_i 是第 i 座建筑物的高度
  
你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上

天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 x 坐标 进行 排序 。关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分

注意：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]

![alt text](https://github.com/donnapersonal/picx-images-hosting/raw/master/image.4clcmhqsjn.webp)

限制:
- 1 <= buildings.length <= 10^4
- 0 <= lefti < righti <= 2^31 - 1
- 1 <= heighti <= 231 - 1
- buildings is sorted by lefti in non-decreasing order.

## 解题

**初始思路（暴力扫描）**
- 想法：枚举从 `min(left)` 到 `max(right)` 的每个 `x`，找出当前位置有哪些楼覆盖，并选最大高度。然后比较和前一个高度是否变化，变化就记下来
- 问题：时间复杂度太高，且难以处理楼层高度交错的变化时机，不适合面试

**最优思路（扫描线 + 最大堆）**
- 核心思想
  - 把所有楼拆成两个事件：进入事件 `(x=left, -height, right)`，离开事件 `(x=right, 0, 0)`
  - 事件按 `x` 从小到大排序，若 `x` 相等：
    - 优先进入事件（高度为负，为了堆排序方便）
    - 离开事件其次（高度为 `0`）
- 利用`最大堆`维护当前所有楼的高度
  - 用最大堆（Python 中用最小堆 + 负值模拟）维护当前有效楼层高度
  - 每次处理完事件，查看当前最大高度是否与前一次不同，如果不同说明 `skyline` 有变化，记录下 `[x, new_height]`
  - 如果某栋楼结束了，要从堆中移除对应高度（通过 `right endpoint` 判断）

```python
class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        events = []
        for l, r, h in buildings:
            events.append((l, -h, r))  # 进入事件：负高度用于最大堆排序
            events.append((r, 0, 0))   # 离开事件：高度为0，不影响堆
        
        events.sort()
        res = []  # 结果集
        heap = [(0, float("inf"))]  # 最大堆：(-高度, 结束位置)，初始为地面高度0，直到无限远
        prev_height = 0  # 上一次的最大高度

        for x, neg_h, r in events:
            # 1️⃣ 当前是进入事件
            if neg_h != 0:
                heappush(heap, (neg_h, r))  # 加入当前楼层（负高度）
            else:
                # 2️⃣ 当前是离开事件：清理所有已经过期的楼（结束位置 ≤ 当前 x）
                while heap and heap[0][1] <= x:
                    heappop(heap)

            curr_height = -heap[0][0]  # 当前堆顶的最大高度（注意取负）
            if curr_height != prev_height:
                res.append([x, curr_height])
                prev_height = curr_height
            
        return res
```

- 时间复杂度：`O(nlogn)`，其中 `n` 为建筑数量。每座建筑至多只需要入队与出队一次，单次时间复杂度为 `O(logn)`
- 空间复杂度：`O(n)`，其中 `n` 为建筑数量。数组 `boundaries` 和优先队列的空间占用均为 `O(n)`