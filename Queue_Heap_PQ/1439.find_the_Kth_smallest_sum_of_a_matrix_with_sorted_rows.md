# 1439.有序矩阵中的第 k 个最小数组和

题目链接：[1439.有序矩阵中的第 k 个最小数组和](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)

## 题目大意

给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列

你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和

```js
Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.

Example 2:
Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17

Example 3:
Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9. 
```

限制:
- m == mat.length, n == mat.length[i]
- 1 <= m, n <= 40
- 1 <= mat[i][j] <= 5000
- 1 <= k <= min(200, nm)
- mat[i] is a non-decreasing array.

## 解题

暴力解法（TLE）
- 对于每一行取一个数，总共 `m` 行，即为 `m` 重循环
- 所有组合的个数是：`n^m`，对于每个组合算和后排序取第 `k` 小
- 缺点：
  - 暴力枚举所有组合时间复杂度是指数级 `O(n^m)`，即使 m = 5, n = 40，也无法接受
  - 会超时，无法通过测试用例

最优解法：`优先队列 + k 小数组和合并`
- 类似于合并两个有序数组中的前 `k` 小“数对和”问题
- 从第一行开始，依次将其与下一行进行“数组和合并”，每次只保留前 `k` 小的组合和
- 最后得到的是全部组合中最小的 `k` 个数组和，取最后一个即为结果
- 解法要点：
  - 将“二维数组和组合”的问题，转化为不断合并两个一维数组的前 `k` 小和问题
  - 使用堆来合并两个数组的前 `k` 小组合和 → 经典题 `“373. Find K Pairs with Smallest Sums”`
  - 每次只关注最小的 `k` 个组合和，避免无效扩展

```python
class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        # a 是当前维护的最小组合和数组，初始为第一行前 k 项
        # 初始化：取第一行前 k 个数（本身是有序的）
        a = mat[0][:k]
        # 遍历后续行，每次将当前行与已有数组 a 合并，并保留前 k 个最小和
        for row in mat[1:]:
            # 逐行合并当前行与已有的组合和
            a = self.kSmallestPairs(row, a, k)
        
        # 最终数组中第 k 小的值就是最后一个
        return a[-1]
    
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        res = []
        # 初始化堆，取 nums1[i] + nums2[j] 的和，初始从 (0,0) 开始
        # 小根堆，元素为 (和, i, j)
        heap = [(nums1[0] + nums2[0], 0, 0)]
        while heap and len(res) < k:
            # 每次弹出当前堆顶（最小和），加入结果数组
            _, i, j = heappop(heap)
            res.append(nums1[i] + nums2[j])  # 记录当前最小的组合和

            # 只在 j==0 的时候推进 i，是为了避免重复组合（如 (i+1,j) 和 (i,j+1) 会交叉）
            if j == 0 and i + 1 < len(nums1):
                heappush(heap, (nums1[i + 1] + nums2[0], i + 1, 0))
            
            # 推进 j，可以从当前组合拓展到新的组合 (i,j+1)
            if j + 1 < len(nums2):
                heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))

        return res
```

- 时间复杂度：`O(mklogmin(n,k))`，其中 `m` 和 `n` 分别为 `mat` 的行数和列数
  - 每次循环相当于解决一遍第 373 题，时间为 `O(klogmin(n,k))`，所以总的时间复杂度为 `O(mklogmin(n,k))`
- 空间复杂度：`O(min(n,k))`。堆中至多有 `O(min(n,k))` 个元素
